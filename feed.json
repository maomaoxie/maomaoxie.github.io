{
    "version": "https://jsonfeed.org/version/1",
    "title": "Mawchu 貓奴前端的天空",
    "description": "Mawchu 貓奴前端，為熱愛平面設計與貓咪的前端工程師 - 謝佳芳（毛球）的技術部落格，喜歡撰寫技術文章幫助自己在前端之路成長，涉及 Javascript、Vue、Laravel 與其他程式相關的討論與學習",
    "home_page_url": "http://maomaoxie.github.io",
    "items": [
        {
            "id": "http://maomaoxie.github.io/2022/10/13/difference-between-gateway-and-router/",
            "url": "http://maomaoxie.github.io/2022/10/13/difference-between-gateway-and-router/",
            "title": "閘道與路由的基礎介紹",
            "date_published": "2022-10-13T08:50:21.000Z",
            "content_html": "<html><head></head><body><p>閘道（gateway）與路由（router）在網絡早期的世界裡並無區別，且與 TCP/IP 通訊層有密不可分的關係。<br>在現今發達的網絡世界中逐漸分化了兩者的功能：</p>\n<h1 id=\"閘道（gateway）\"><a href=\"#閘道（gateway）\" class=\"headerlink\" title=\"閘道（gateway）\"></a>閘道（gateway）</h1><p>A Gateway, on the other hand, joins dissimilar systems.<br>Gateway it is defined as a network entity that allows a network to interface with another network with different protocols.<br>閘道（gateway）能合併不同的系統，旨在允許不同協定（protocols）的網絡之間互相介接的網路裝置。</p>\n<p>Device that converts one protocol or format to another.<br>A network gateway converts packets from one protocol to another.<br>The gateway functions as an entry/exit point to the network.<br>將一種網路協定規格或封包轉換成另一種的裝置。<br>閘道功能當作是進入網絡的節點與進入點。</p>\n<h3 id=\"透過運算轉化規格\"><a href=\"#透過運算轉化規格\" class=\"headerlink\" title=\"透過運算轉化規格\"></a>透過運算轉化規格</h3><p>The gateway interprets the system of networks as endpoints from packet to packet.<br>閘道（gateway）的主要任務就是透過運算與轉換將一種協定（protocols）的網絡轉換成另一種，使資料在不同協定之間傳遞不受阻。</p>\n<p>A gateway can only operate on five layers.<br>閘道僅能在 OSI 模型的應用層第五層運作。</p>\n<h5 id=\"附加的特色\"><a href=\"#附加的特色\" class=\"headerlink\" title=\"附加的特色\"></a>附加的特色</h5><p>network access control, protocol conversion, etc</p>\n<h1 id=\"路由（router）\"><a href=\"#路由（router）\" class=\"headerlink\" title=\"路由（router）\"></a>路由（router）</h1><p>A router is a device that is capable of sending and receiving data packets between computer networks, also creating an overlay network.<br>路由（router）是一個能在電腦網絡之間傳遞與接收資料封包的裝置，亦可創造覆蓋網路（overlay network）。</p>\n<p>Based on internal routing tables, routers read each incoming packet and decide how to forward it.<br>根據內部的路由表格，讀取每個進入的封包並決定如何繼續傳遞。</p>\n<p>Routers work at the network layer (layer 3) of the protocol<br>路由主要在 OSI 模型的應用層第三層或第四層運作。</p>\n<h5 id=\"附加的特色-1\"><a href=\"#附加的特色-1\" class=\"headerlink\" title=\"附加的特色\"></a>附加的特色</h5><p>wireless networking, static routing, NAT, DHCP server, etc</p>\n<h3 id=\"可選擇傳遞的路徑（ip）\"><a href=\"#可選擇傳遞的路徑（ip）\" class=\"headerlink\" title=\"可選擇傳遞的路徑（ip）\"></a>可選擇傳遞的路徑（ip）</h3><p>路由可以在網路（network）之間互相分享與傳遞資料封包，也可以選擇傳遞的路徑。</p>\n<img src=\"/images/difference-between-gateway-and-router/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"difference-between-gateway-and-router\">\n\n<h1 id=\"兩者如何共同工作\"><a href=\"#兩者如何共同工作\" class=\"headerlink\" title=\"兩者如何共同工作\"></a>兩者如何共同工作</h1><h3 id=\"閘道（gateway）關卡\"><a href=\"#閘道（gateway）關卡\" class=\"headerlink\" title=\"閘道（gateway）關卡\"></a>閘道（gateway）關卡</h3><p>Before arriving at the router, packets go to the gateway channel first, and the gateway checks the header information at once.<br>在資料抵達路由以前會間在閘道頻道上檢查資訊頭（the header information）。</p>\n<p>After checking for any kind of error in the destination IP address and packet.<br>According to the needs of the destination network,it carries out data conversion and protocol conversion on the packet,<br>which is also the most critical step.<br>檢查完畢目的地的 IP 位址與數據包無任何異常後，閘道會攜出轉換協定（protocols）的封包，這中間經歷的步驟最為嚴謹。</p>\n<h3 id=\"路由（router）關卡\"><a href=\"#路由（router）關卡\" class=\"headerlink\" title=\"路由（router）關卡\"></a>路由（router）關卡</h3><p>Finally, the processed packet is forwarded to the router to establish intelligent communication between the two different networks.<br>最後當封包傳遞到路由上後，會建立兩個不同網路（networks）的智能通訊。</p>\n<p>The router extracts the destination address from the received packet, determines the network number in the address,<br>and then looks up the routing table to find the entry matching the destination network.<br>路由從封包中提取目的地的位址並且決定位址中的網絡號碼，查看路由表格對應的目的地網路進入點。</p>\n<p>The routing table determines the next stop, destination, output interface, and other routing-related parameters that match the current packet.<br>路由表格會查看符合當前封包的路由相關參數，以決定好封包的下一站、目的地與傳輸出去的介面。</p>\n<p>Finally, the packet is sent to the computer with the best route.<br>最後封包被傳遞到電腦中最適宜的路由道路上。</p>\n<h1 id=\"閘道就是大門，路由就是樓層間的電梯\"><a href=\"#閘道就是大門，路由就是樓層間的電梯\" class=\"headerlink\" title=\"閘道就是大門，路由就是樓層間的電梯\"></a>閘道就是大門，路由就是樓層間的電梯</h1><p>In layman’s terms, gateways and routers are like the gates and elevators of a castle.<br>口語化來說，閘道就是大門，路由就是樓層間的電梯。</p>\n<p>they must first pass the inspection and arrangement through the gate.<br>必須經過檢查與安排才能透過大門。</p>\n<p>Then the elevator headquarters will choose the fastest elevator for them according to the characteristics and purpose of these strangers and finally,<br>arrive at the destination.<br>電梯總部人員根據性質與訴求選擇最適合最快的電梯協助抵達目的地。</p>\n<h1 id=\"選擇閘道還是路由\"><a href=\"#選擇閘道還是路由\" class=\"headerlink\" title=\"選擇閘道還是路由\"></a>選擇閘道還是路由</h1><p>If your devices are on the same network, then routers and gateways can be peer to peer.<br>若你的多個裝置是同個網路，則路於與閘道可以進行對等式網路 peer to peer（P2P）</p>\n<p>But if you want to connect two different networks with different protocols, the gateway can suit your demands.<br>若你想連接兩個不同協定的不同網絡，閘道可以符合需求。</p>\n<p>Some routers and gateways in the market can already replace each other.<br>有些市面上的閘道與路由已經可以互相取代了。</p>\n<p>The technology and capabilities of gateways and routers will continue to evolve and become more sophisticated over the next few years.<br>往後的幾年兩者的技術與可能性會互相演變得更細分精緻。</p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/10/09/google-analytics-knowhow/",
            "url": "http://maomaoxie.github.io/2022/10/09/google-analytics-knowhow/",
            "title": "關於 Google Analytics GA 你應該知道的事",
            "date_published": "2022-10-09T06:20:19.000Z",
            "content_html": "<html><head></head><body><p>Google Analytics 也就是 GA ，即將在 2023 年 7 月 1 日起不再提供<strong>通用版本（Universal Analytics）</strong><br>的資料分析了，全面升級至 GA4 是每個網站與應用程式必須面對的問題。</p>\n<p>而訪客區分為新訪客與舊訪客，以及舊訪客的回訪率等資料。那麼 Google 要如何去區分呢？來了解一下：</p>\n<h1 id=\"GA-如何區分與追蹤同一瀏覽人次\"><a href=\"#GA-如何區分與追蹤同一瀏覽人次\" class=\"headerlink\" title=\"GA 如何區分與追蹤同一瀏覽人次\"></a>GA 如何區分與追蹤同一瀏覽人次</h1><h3 id=\"client-ID\"><a href=\"#client-ID\" class=\"headerlink\" title=\"client ID\"></a>client ID</h3><p>該數據是 GA 用來判定此瀏覽器使用者是否為重複瀏覽的人次，紀錄方式透過 Cookie 裡的 _ga 查看內容的話，<br>會有一段追蹤碼記錄此用戶的 client ID，一旦清除 GA 偵測不到就會判定為新的瀏覽使用者。</p>\n<img src=\"/images/google-analytics-knowhow/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"google-analytics-knowhow\">\n<blockquote><p>由於 GA 判斷新訪客、舊訪客是使用「用戶裝置瀏覽器」來做區別，因此同一個用戶跨裝置訪問網站亦會被計入成兩個用戶，為了精準了解新訪客和舊訪客，事實上引入 User ID 作為統計方式會最為準確，而這一部份我待後續文章分享。</p>\n<footer><strong>author</strong><cite><a href=\"https://medium.com/peerone-technology-%E7%9A%AE%E5%81%B6%E7%8E%A9%E4%BA%92%E5%8B%95%E7%A7%91%E6%8A%80/%E4%B8%80%E7%AA%BA-ga-pageview-%E7%9A%84%E8%BF%BD%E8%B9%A4%E5%8A%9B%E9%87%8F-ga-%E7%B3%BB%E5%88%97-3-afbb42dbb8b5\">一窺 GA PageView 的追蹤力量- GA 系列 (3)</a></cite></footer></blockquote>\n\n<p>GA 參數（這裡指的是事件 event 參數）旨在追蹤與分析使用者在你的網站或 app 上所有的互動行為，<br>提供蒐集來的、具商業行為參考價值的數據。</p>\n<blockquote><p>Parameters provide additional information about the ways users interact with your website. </p>\n<footer><strong>google analytics</strong><cite><a href=\"https://developers.google.com/analytics/devguides/collection/ga4/event-parameters?client_type=gtm\">Set up event parameters</a></cite></footer></blockquote>\n<p>以下初步揭開 GA 的基礎輪廓：</p>\n<h1 id=\"使用者的著陸網頁（Landing-Page）\"><a href=\"#使用者的著陸網頁（Landing-Page）\" class=\"headerlink\" title=\"使用者的著陸網頁（Landing Page）\"></a>使用者的著陸網頁（Landing Page）</h1><p>訪客來到網站的第一個頁面，是整個工作階段（Session）的起始點並且開啟一個工作階段的流程，</p>\n<h1 id=\"基本追蹤事件\"><a href=\"#基本追蹤事件\" class=\"headerlink\" title=\"基本追蹤事件\"></a>基本追蹤事件</h1><p>GA 有<strong>基本追蹤事件</strong>提供開通帳號的使用者，一窺網站或應用程式埋好 GA 追蹤碼之後的<strong>事件（event）</strong>概覽數據，<br>這篇先來簡單介紹 GA 常見的、自動蒐集的數據：</p>\n<p><a href=\"https://support.google.com/analytics/answer/9234069#user_engagement\">官方說明文件</a></p>\n<h3 id=\"網頁瀏覽（page-view）\"><a href=\"#網頁瀏覽（page-view）\" class=\"headerlink\" title=\"網頁瀏覽（page_view）\"></a>網頁瀏覽（page_view）</h3><p>在指定的時間區段內，所有使用者在網站或應用程式的網頁瀏覽（造訪）量；<br>其中使用者的分母根據 Client ID 計次，來得知網站有多少不重複使用者。</p>\n<img src=\"/images/google-analytics-knowhow/2.png\" class=\"\" width=\"600\" height=\"200\" title=\"google-analytics-knowhow\">\n\n\n<h3 id=\"締結互動（user-engagement）\"><a href=\"#締結互動（user-engagement）\" class=\"headerlink\" title=\"締結互動（user_engagement）\"></a>締結互動（user_engagement）</h3><blockquote><p>The User engagement metric shows the time that your app screen was in the foreground or your web page was in focus. When your site or app is running but no page or screen is displayed, Analytics doesn’t collect the metric. The metric can help you understand when users actively use your website or app.</p>\n<footer><strong>google link What is user engagement on Google Analytics?</strong></footer></blockquote>\n\n<p>不負責任翻譯：<br>The User engagement 計量表示當你的應用程式或網站呈現在使用者畫面前景上並且被使用者聚焦，<br>與網站締結了互動行為，若應用程式或網站尚未載入完成或呈現出來，GA 不會蒐集該項指標。<br>這個計量可以幫助你了解目前應用程式或網站花了多少時間獲得使用者的聚焦，以及即時有多少活躍的使用者。</p>\n<h5 id=\"互動活躍時間（engagement-time-msec）\"><a href=\"#互動活躍時間（engagement-time-msec）\" class=\"headerlink\" title=\"互動活躍時間（engagement_time_msec）\"></a>互動活躍時間（engagement_time_msec）</h5><p>計算使用者在與網站或應用程式締結互動之後開始計算，在網站上活躍的時間毫秒（msec）。</p>\n<h3 id=\"campaign（活動分類）\"><a href=\"#campaign（活動分類）\" class=\"headerlink\" title=\"campaign（活動分類）\"></a>campaign（活動分類）</h3><p>可以在 GA 預設的 <strong>Click 事件</strong>裡查閱的參數，若是透過外部廣告（例如 Google Ads）等方式進入你的網站或應用程式，<br>campaign　參數就會被記錄，通常會顯示（referral）或（organic），有三大分類，<br>有時會帶括號有時不會（不知為啥知道的人請解惑一下XD）。</p>\n<h5 id=\"organic\"><a href=\"#organic\" class=\"headerlink\" title=\"(organic)\"></a>(organic)</h5><p>透過搜尋而來的自然流量（主動）。</p>\n<h5 id=\"referral\"><a href=\"#referral\" class=\"headerlink\" title=\"(referral)\"></a>(referral)</h5><p>透過外部媒體網站進來（被動）瀏覽的使用者，也就是行銷常講的外連（外部連結）。</p>\n<h5 id=\"none\"><a href=\"#none\" class=\"headerlink\" title=\"(none)\"></a>(none)</h5><p>直接進入網站的使用者，例如在 url 輸入網址。</p>\n<h3 id=\"medium（媒介分類）\"><a href=\"#medium（媒介分類）\" class=\"headerlink\" title=\"medium（媒介分類）\"></a>medium（媒介分類）</h3><p>使用者透過甚麼媒介方式進來你的網站，類別同上：</p>\n<h3 id=\"source（媒介-origin）\"><a href=\"#source（媒介-origin）\" class=\"headerlink\" title=\"source（媒介 origin）\"></a>source（媒介 origin）</h3><p>透過外部廣告進來的 url，例如透過 Google 搜尋進來的就會顯示 <code>https://www.google.com/</code>；<br>透過外部網站進來的就會顯示外部網站的 Origin URL。</p>\n<img src=\"/images/google-analytics-knowhow/5.png\" class=\"\" width=\"500\" height=\"200\" title=\"google-analytics-knowhow\">\n\n<h3 id=\"事件參數\"><a href=\"#事件參數\" class=\"headerlink\" title=\"事件參數\"></a>事件參數</h3><p>每個事件都有詳細參數可以閱覽，有機個是預設的（照順序），實際查看發現與官方文件的說明項目有出入。</p>\n<h1 id=\"GA-如何計算一個互動的單位\"><a href=\"#GA-如何計算一個互動的單位\" class=\"headerlink\" title=\"GA 如何計算一個互動的單位\"></a>GA 如何計算一個互動的單位</h1><h3 id=\"工作階段（Session-Start）\"><a href=\"#工作階段（Session-Start）\" class=\"headerlink\" title=\"工作階段（Session Start）\"></a>工作階段（Session Start）</h3><p>GA 的工作階段以 30 分鐘為一個單位，若這段期間使用者並未對網站進行任何互動（例如起來去廁所），<br>當前的工作階段就會結束。每個單位的工作流程可以包含多個互動事件（Event）或是從事商業行為，例如社交互動（Social Interaction）、電子商戶交易行為（Transaction），直到一個單位的工作階段結束（離開網站或是閒置超過 30 分鐘）。</p>\n<h5 id=\"工作階段強制切割\"><a href=\"#工作階段強制切割\" class=\"headerlink\" title=\"工作階段強制切割\"></a>工作階段強制切割</h5><ul>\n<li>只要時間來到<strong>隔日凌晨 00:00:00 時分</strong>，無論當前的工作階段是否有持續進行互動，都會被強制切割成另一個新的工作階段。</li>\n<li>當使用者更換了網站的來源媒介（medium 例如從廣告點進來、重新搜尋網站進入），都會被強制切割成另一個新的工作階段，無論使用者是否有停止當前的工作階段。</li>\n</ul>\n<h3 id=\"到達頁面（UA-通用版稱呼）\"><a href=\"#到達頁面（UA-通用版稱呼）\" class=\"headerlink\" title=\"到達頁面（UA 通用版稱呼）\"></a>到達頁面（UA 通用版稱呼）</h3><p>每一個工作階段開始的第一個頁面。</p>\n<h3 id=\"離開率\"><a href=\"#離開率\" class=\"headerlink\" title=\"離開率\"></a>離開率</h3><p>一個工作階段中「最後一個」瀏覽的網頁，在所有網頁瀏覽量的占比。</p>\n<p>參考資料：<br><a href=\"https://awoo.ai/zh-hant/blog/google-analytics-session/\">正確理解Google Analytics「工作階段」定義、計算、重要性</a></p>\n</body></html>",
            "tags": [
                "Google Analytics",
                "GA",
                "GA4",
                "Google Tag Manager",
                "GTM"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/10/05/google-tag-manager-start-up/",
            "url": "http://maomaoxie.github.io/2022/10/05/google-tag-manager-start-up/",
            "title": "Google Tag Manager 起手式",
            "date_published": "2022-10-05T01:46:48.000Z",
            "content_html": "<html><head></head><body><p>GTM（Google Tag Manager）是集合了 Google Analaytics、Google ADs、facebook pixel 等追蹤碼片段的一個總攬平台，<br>可以更方便的管理放置在網站上所有的追蹤行為，是這三大追蹤技術的綜觀介面，甚至可以使用這個 UI 平台放置更多的追蹤碼而不需要手動埋 code，<br>（第一步放置 GTM 追蹤碼還是需要的），是身為行銷、網頁工程師應該知道的追蹤技術。</p>\n<h1 id=\"GTM-起手式\"><a href=\"#GTM-起手式\" class=\"headerlink\" title=\"GTM 起手式\"></a>GTM 起手式</h1><p>首先需要將<strong>網站（website）當作一個容器</strong>來啟動 GTM 帳號，並且將追蹤 code 放置在網站每一頁的 <code>&lt;head&gt;...&lt;/head&gt;</code>以及 <code>&lt;body&gt;...&lt;/body&gt;</code>，<br>完成 GTM 的安裝，並且使用 chrome 的外掛程式來確保安裝完成！</p>\n<img src=\"/images/google-tag-manager-start-up/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"google-tag-manager-start-up\">\n\n<h1 id=\"輔助工具\"><a href=\"#輔助工具\" class=\"headerlink\" title=\"輔助工具\"></a>輔助工具</h1><p>可以安裝 chrome 的 Google 行銷工具用的外掛（plugin），Tag Asistant Legacy（by google）在測試網站上點選錄製（Record）後，<br>過段時間偵測是否有安裝成功！</p>\n<img src=\"/images/google-tag-manager-start-up/2.png\" class=\"\" width=\"800\" height=\"200\" title=\"google-tag-manager-start-up\">\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/09/28/google-apps-script-try/",
            "url": "http://maomaoxie.github.io/2022/09/28/google-apps-script-try/",
            "title": "Google Apps Script 輕鬆寫入表單",
            "date_published": "2022-09-28T06:54:00.000Z",
            "content_html": "<html><head></head><body><p>先前自己的一個小專案使用了 Google 官方的 Sheet Api v4 來寫入花費明細，除了要自幹一套 Node.js 搞定 Sheet API 的 OAuth 之外，還要忍受每過七天 tkn 就會失效的痛苦，終於在茫茫文件海中發現到 App 小天堂 Google Apps Script 這套輕量型的 Paas 平台，讓你撰寫一段小小的 javascript code 就能一秒產生 API endpoint！</p>\n<h1 id=\"啟用-GCP-Google-Apps-Script\"><a href=\"#啟用-GCP-Google-Apps-Script\" class=\"headerlink\" title=\"啟用 GCP Google Apps Script\"></a>啟用 GCP Google Apps Script</h1><p>首先要準備好的就是你 GCP 上的 API 要記得啟用，打開 Google Sheets API 以及 APPs Script API：</p>\n<img src=\"/images/google-apps-script-try/0.png\" class=\"\" width=\"600\" height=\"200\" title=\"google-apps-script-try\">\n\n<p>打開之後去建立一個空白表單來產生需要的 Sheet ID，會在表單連結裡 <code>d/</code> 後方的一串亂碼．</p>\n<img src=\"/images/google-apps-script-try/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"google-apps-script-try\">\n\n<p>接著把表單存取權限開到最大，讓任何知道連結的人都可以編輯表單：</p>\n<img src=\"/images/google-apps-script-try/2.png\" class=\"\" width=\"800\" height=\"200\" title=\"google-apps-script-try\">\n\n<h1 id=\"透過-Google-Apps-Script-建立應用程式\"><a href=\"#透過-Google-Apps-Script-建立應用程式\" class=\"headerlink\" title=\"透過 Google Apps Script 建立應用程式\"></a>透過 Google Apps Script 建立應用程式</h1><h2 id=\"撰寫程式\"><a href=\"#撰寫程式\" class=\"headerlink\" title=\"撰寫程式\"></a>撰寫程式</h2><p>接下來是重頭戲，建立寫入 Google 表單的 app，點案這裡進入 Google Apps Script 介面，撰寫以下的程式碼：<br>來源之後補上：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">doPost</span>(<span class=\"hljs-params\">e</span>) {</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 取得輸入參數</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> params = e.<span class=\"hljs-property\">parameter</span>; </span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> name = params.<span class=\"hljs-property\">name</span>;</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> mail = params.<span class=\"hljs-property\">mail</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"hljs-comment\">// 初始化試算表</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> <span class=\"title class_\">SpreadSheet</span> = <span class=\"title class_\">SpreadsheetApp</span>.<span class=\"title function_\">openById</span>(<span class=\"hljs-string\">\"輸入你斜線 d 後面的表單 id\"</span>);</span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> <span class=\"title class_\">Sheet</span> = <span class=\"title class_\">SpreadSheet</span>.<span class=\"title function_\">getSheets</span>()[<span class=\"hljs-number\">0</span>]; <span class=\"hljs-comment\">// 指定第一張試算表</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">let</span> <span class=\"title class_\">LastRow</span> = <span class=\"title class_\">Sheet</span>.<span class=\"title function_\">getLastRow</span>(); <span class=\"hljs-comment\">// 取得最後一列有值的索引值</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">// 寫入試算表</span></span><br><span class=\"line\">  <span class=\"title class_\">Sheet</span>.<span class=\"title function_\">getRange</span>(<span class=\"title class_\">LastRow</span>+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>).<span class=\"title function_\">setValue</span>(name);</span><br><span class=\"line\">  <span class=\"title class_\">Sheet</span>.<span class=\"title function_\">getRange</span>(<span class=\"title class_\">LastRow</span>+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>).<span class=\"title function_\">setValue</span>(mail);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"hljs-comment\">// 回傳結果</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> <span class=\"title class_\">ContentService</span></span><br><span class=\"line\">  .<span class=\"title function_\">createTextOutput</span>(<span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>({ <span class=\"hljs-attr\">result</span>: <span class=\"hljs-string\">'成功'</span>, <span class=\"hljs-attr\">version</span>: <span class=\"hljs-string\">'1.0'</span> }))</span><br><span class=\"line\">      .<span class=\"title function_\">setMimeType</span>(<span class=\"title class_\">ContentService</span>.<span class=\"hljs-property\">MimeType</span>.<span class=\"hljs-property\">JSON</span>); </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n<h2 id=\"部屬程式\"><a href=\"#部屬程式\" class=\"headerlink\" title=\"部屬程式\"></a>部屬程式</h2><p>點選右上方的部屬，選擇類型為「網頁應用程式」．以及呼叫 API 的權限設定要記得選擇，所有人都可以呼叫這個程式並且寫入：</p>\n<img src=\"/images/google-apps-script-try/4.png\" class=\"\" width=\"800\" height=\"200\" title=\"google-apps-script-try\">\n<img src=\"/images/google-apps-script-try/5.png\" class=\"\" width=\"800\" height=\"200\" title=\"google-apps-script-try\">\n\n<h2 id=\"獲得端點-API\"><a href=\"#獲得端點-API\" class=\"headerlink\" title=\"獲得端點 API\"></a>獲得端點 API</h2><p>部屬完成會有 API 網址產生，這時候就可以複製起來然後使用 postman 操作看看是否成功囉!</p>\n<img src=\"/images/google-apps-script-try/6.png\" class=\"\" width=\"800\" height=\"200\" title=\"google-apps-script-try\">\n<img src=\"/images/google-apps-script-try/7.png\" class=\"\" width=\"800\" height=\"200\" title=\"google-apps-script-try\">\n\n<p>來查看一下 google sheet 這邊是否成功寫入：</p>\n<img src=\"/images/google-apps-script-try/8.png\" class=\"\" width=\"800\" height=\"200\" title=\"google-apps-script-try\">\n\n<p>大功告成囉!</p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/09/28/zh-tw/restful-api-intro/",
            "url": "http://maomaoxie.github.io/2022/09/28/zh-tw/restful-api-intro/",
            "title": "restful-api-intro",
            "date_published": "2022-09-28T02:42:52.000Z",
            "content_html": "<html><head></head><body><p>RESTful API 的簡單介紹：</p>\n<h1 id=\"統一資源對外傳輸的接界窗口\"><a href=\"#統一資源對外傳輸的接界窗口\" class=\"headerlink\" title=\"統一資源對外傳輸的接界窗口\"></a>統一資源對外傳輸的接界窗口</h1><p>可以透過資源分類命名，例如 <a href=\"https://www.example.com/books\">https://www.example.com/books</a> 就是關於書的相關 API 資料</p>\n<h1 id=\"API-端口彼此獨立，不須互相依賴\"><a href=\"#API-端口彼此獨立，不須互相依賴\" class=\"headerlink\" title=\"API 端口彼此獨立，不須互相依賴\"></a>API 端口彼此獨立，不須互相依賴</h1><p>資源按照端口分開接收，沒有次序或是參數依賴的問題</p>\n<h1 id=\"從-Client-端發送需求（request）\"><a href=\"#從-Client-端發送需求（request）\" class=\"headerlink\" title=\"從 Client 端發送需求（request）\"></a>從 Client 端發送需求（request）</h1><p>API 的資源傳送是分離式的，client 裝置發送 request 而 server 提供資源</p>\n<h1 id=\"具有-cache-機制\"><a href=\"#具有-cache-機制\" class=\"headerlink\" title=\"具有 cache 機制\"></a>具有 cache 機制</h1><p>可以在 API 資源第一次返回時下載在客戶端裝置，存取在瀏覽器等暫時記憶位置，避免耗時重複讀取相同的資源，例如網站圖片或靜態資源</p>\n<h1 id=\"可架接中間層系統\"><a href=\"#可架接中間層系統\" class=\"headerlink\" title=\"可架接中間層系統\"></a>可架接中間層系統</h1><p>在 API 流量評估的中間層設置負載平衡機制，適時的管控與擴充當下 API 使用情況以免伺服器負荷過大</p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/09/26/zh-tw/js-weird-parts-default-values/",
            "url": "http://maomaoxie.github.io/2022/09/26/zh-tw/js-weird-parts-default-values/",
            "title": "克服 Javascript 的奇怪部分 預設值",
            "date_published": "2022-09-26T09:15:05.000Z",
            "content_html": "<html><head></head><body><p>JavaScript 引擎在函式建立當下會創造一個執行環境（execution context），以及未被建立的變數都會賦予 <code>undefined</code> 的值，相對應來講參數也是一種變數。</p>\n<h1 id=\"預設參數\"><a href=\"#預設參數\" class=\"headerlink\" title=\"預設參數\"></a>預設參數</h1><p>當預設參數沒有被指定的情況下，JavaScript 引擎會默認為<code>undefined</code> 的值：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">greetings</span>(<span class=\"hljs-params\">name</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"hljs-string\">'Hello, '</span>, name + <span class=\"hljs-string\">'.'</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">greetings</span>(<span class=\"hljs-string\">'Jamie'</span>); <span class=\"hljs-comment\">// Hello, Jamie.</span></span><br><span class=\"line\"><span class=\"title function_\">greetings</span>(); <span class=\"title class_\">Hello</span>, <span class=\"hljs-literal\">undefined</span>.</span><br></pre></td></tr></tbody></table></figure>\n<p>這其中也有字串的隱式型轉，<code>Hello</code> + <code>String(undefined)</code>，獲得 <code>Hello, undefined.</code>的結果。</p>\n<h1 id=\"善用-OR（-）搭配布林型轉-設定預設值\"><a href=\"#善用-OR（-）搭配布林型轉-設定預設值\" class=\"headerlink\" title=\"善用 OR（||）搭配布林型轉 設定預設值\"></a>善用 OR（||）搭配布林型轉 設定預設值</h1><p>OR（||）運算子的特性就是回傳表達式兩邊，Boolean 型轉第一個為 <code>true</code> 的值：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">greetings</span>(<span class=\"hljs-params\">name</span>) {</span><br><span class=\"line\">    name = name || <span class=\"hljs-string\">'&lt;你的名字&gt;'</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">greetings</span>(); <span class=\"hljs-comment\">// '&lt;你的名字&gt;'</span></span><br></pre></td></tr></tbody></table></figure>\n<p><code>name = name || '&lt;你的名字&gt;'</code> 轉換過程中會將 name 賦值 <code>undefined</code>，undefined || ‘&lt;你的名字&gt;’ 透過布林型轉為 false || true，<br>並且返回 <code>true</code> 的值 <code>'&lt;你的名字&gt;'</code>，可以透過這種布林型轉小技巧來設定預設值。</p>\n<h1 id=\"OR（-）回傳第一個-true-的值\"><a href=\"#OR（-）回傳第一個-true-的值\" class=\"headerlink\" title=\"OR（||）回傳第一個 true 的值\"></a>OR（||）回傳第一個 true 的值</h1><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-literal\">true</span> || <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// true</span></span><br><span class=\"line\"><span class=\"hljs-literal\">true</span> || <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// true</span></span><br><span class=\"line\"><span class=\"hljs-literal\">false</span> || <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// false</span></span><br><span class=\"line\"><span class=\"hljs-literal\">undefined</span> || <span class=\"hljs-string\">'1'</span>; <span class=\"hljs-comment\">// '1'</span></span><br><span class=\"line\"><span class=\"hljs-string\">'apple'</span> || <span class=\"hljs-string\">'banana'</span>; <span class=\"hljs-comment\">// 'apple' </span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"使用-OR（-）設定預設值\"><a href=\"#使用-OR（-）設定預設值\" class=\"headerlink\" title=\"使用 OR（||）設定預設值\"></a>使用 OR（||）設定預設值</h2><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-literal\">undefined</span> || <span class=\"hljs-string\">'Jakie'</span>;</span><br><span class=\"line\"><span class=\"hljs-literal\">null</span> || <span class=\"hljs-string\">'existence'</span>;</span><br><span class=\"line\"><span class=\"hljs-string\">''</span> || <span class=\"hljs-string\">'預設文字'</span>;</span><br></pre></td></tr></tbody></table></figure></body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/09/26/zh-tw/js-weird-parts-boolean-vs-existence/",
            "url": "http://maomaoxie.github.io/2022/09/26/zh-tw/js-weird-parts-boolean-vs-existence/",
            "title": "克服 Javascript 的奇怪部分 布林與存在",
            "date_published": "2022-09-26T08:32:21.000Z",
            "content_html": "<html><head></head><body><h1 id=\"布林值的型轉\"><a href=\"#布林值的型轉\" class=\"headerlink\" title=\"布林值的型轉\"></a>布林值的型轉</h1><p>布林型轉遇到代表著空值、不存在或者未定義的值時就會轉換為假值（falsy），例如以下範例：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Boolean</span>(<span class=\"hljs-literal\">undefined</span>); <span class=\"hljs-comment\">// false</span></span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>(<span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">// false</span></span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>(<span class=\"hljs-string\">''</span>); <span class=\"hljs-comment\">// false</span></span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// false</span></span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>(<span class=\"title class_\">NaN</span>); <span class=\"hljs-comment\">// false</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>需要注意的是字串0使用布林型轉會獲得真值（truthy）：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Boolean</span>(<span class=\"hljs-string\">'0'</span>); <span class=\"hljs-comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>(<span class=\"hljs-string\">'-0'</span>); <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"if-陳述句的型轉\"><a href=\"#if-陳述句的型轉\" class=\"headerlink\" title=\"if 陳述句的型轉\"></a>if 陳述句的型轉</h1><h3 id=\"用來檢查某變數是否存在\"><a href=\"#用來檢查某變數是否存在\" class=\"headerlink\" title=\"用來檢查某變數是否存在\"></a>用來檢查某變數是否存在</h3><p>if 陳述句會將大括號中（parenthesis）的值做布林轉換，也可以使用隱式型轉的特性來檢查某變數是否存在：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a;</span><br><span class=\"line\">... <span class=\"hljs-comment\">// 做了些甚麼</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">if</span> (a) { <span class=\"hljs-comment\">// 被布林型轉</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"hljs-string\">'a 非空值或未定義！'</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"當-falsy-值有可能是零\"><a href=\"#當-falsy-值有可能是零\" class=\"headerlink\" title=\"當 falsy 值有可能是零\"></a>當 falsy 值有可能是零</h3><p>由於 0 的布林型轉也會是 false，可能會造成 if 陳述句的條件判斷下剔除的對象，這時候可以搭配前篇提到的優先性（Precedence），使用優先性較高的三等號（===）加上 OR（||）來介入型轉判斷：</p>\n<img src=\"/images/js-weird-parts-boolean-vs-existence/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-boolean-vs-existence\">\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"hljs-keyword\">if</span> (a || a === <span class=\"hljs-number\">0</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"hljs-string\">'0會被列入考慮'</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>由於優先性先判斷後方 <code>a === 0</code> 為 true，繼續判斷表達式<code>a || true</code> 為 <code>false || true</code>，OR（||）兩邊任一方為 true 印出 true，條件式成立印出 console.log(‘0會被列入考慮’)。</p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/09/23/zh-tw/js-weird-parts-coercion/",
            "url": "http://maomaoxie.github.io/2022/09/23/zh-tw/js-weird-parts-coercion/",
            "title": "克服 Javascript 的奇怪部分 動態型別",
            "date_published": "2022-09-23T07:31:26.000Z",
            "content_html": "<html><head></head><body><p>運算過程中由於 Javascript 是弱型別，沒有辦法強制規範型別，所以會在運算過程中發生隱式（動態）型別轉換，稱之為 Corecion。</p>\n<blockquote><p>Converting a value from one type to another.</p>\n</blockquote>\n\n<h1 id=\"算術運算子的隱式轉換\"><a href=\"#算術運算子的隱式轉換\" class=\"headerlink\" title=\"算術運算子的隱式轉換\"></a>算術運算子的隱式轉換</h1><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-number\">1</span> + <span class=\"hljs-string\">'2'</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// 12</span></span><br></pre></td></tr></tbody></table></figure>\n<p>上方範例可以印證 Javascript 引擎將數字 <code>1</code> 與字串 <code>2</code> 相加的過程中產生的動態型別的轉換，獲得了字串 <code>12</code>。<br>在某些強型別的語言中，這樣做是會噴 error 的，但 Javascript 不會，這也造成開發過程時常會發生不如預期的結果。</p>\n<h1 id=\"比較運算子的隱式轉換\"><a href=\"#比較運算子的隱式轉換\" class=\"headerlink\" title=\"比較運算子的隱式轉換\"></a>比較運算子的隱式轉換</h1><p>從以下的範例我們可以很自然地獲得 true 的結果：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-number\">3</span> &gt; <span class=\"hljs-number\">2</span> &gt; <span class=\"hljs-number\">1</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></tbody></table></figure>\n<p>然而以下的範例卻出乎意料之外也獲得了 true：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-number\">3</span> &lt; <span class=\"hljs-number\">2</span> &lt; <span class=\"hljs-number\">1</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></tbody></table></figure>\n<p>這也是動態型別的轉換在作怪，一一拆解一下過程是這樣的，比較運算子 <code>&lt;</code> 在前一篇的相依性有提到：</p>\n<img src=\"/images/js-weird-parts-coercion/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-coercion\">\n<p>當運算子相同時會採用相依性的方向來決定計算次序，比較運算子 <code>&lt;</code> 是左相依性（left-to-right associactivity），<br>所以背後的 Javascript 引擎會如是計算：<br><code>3 &lt; 2</code> 獲得 false，<code>false &lt; 1</code> 由於型別不同 Javascript 引擎強制將 false 使用數字包裹器轉換為數字型別：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Number</span>(<span class=\"hljs-literal\">false</span>)); <span class=\"hljs-comment\">// 0</span></span><br></pre></td></tr></tbody></table></figure>\n<p><code>0 &lt; 1</code> 獲得 true。</p>\n<h1 id=\"強制型轉\"><a href=\"#強制型轉\" class=\"headerlink\" title=\"強制型轉\"></a>強制型轉</h1><p>型轉分為主動式強制型轉（Explicit Coercion）與被動式隱式型轉（Implicit Coercion），強制型轉有幾個基本型：</p>\n<ol>\n<li>toString</li>\n<li>toNumber</li>\n<li>toBoolean</li>\n<li>toPrimitive</li>\n</ol>\n<h3 id=\"toNumber-數字型轉範例\"><a href=\"#toNumber-數字型轉範例\" class=\"headerlink\" title=\"toNumber 數字型轉範例\"></a>toNumber 數字型轉範例</h3><p>以下是幾個特殊的案例：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Number</span>(<span class=\"title class_\">Undefined</span>); <span class=\"hljs-comment\">// NaN</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>(<span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">// 0</span></span><br></pre></td></tr></tbody></table></figure>\n\n\n<h3 id=\"雙等號型轉的悲劇\"><a href=\"#雙等號型轉的悲劇\" class=\"headerlink\" title=\"雙等號型轉的悲劇\"></a>雙等號型轉的悲劇</h3><p>雙等號（double Equality）會造成嚴重的動態型別轉換，引發不可預期的後果，例如以下的範例：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-literal\">false</span> == <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// true</span></span><br><span class=\"line\"><span class=\"hljs-literal\">null</span> == <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// true</span></span><br><span class=\"line\"><span class=\"hljs-literal\">null</span> &lt; <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// true</span></span><br><span class=\"line\"><span class=\"hljs-string\">\"\"</span> == <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// true</span></span><br><span class=\"line\"><span class=\"hljs-string\">\"\"</span> &lt; <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"動態型別呼叫的包裹器？\"><a href=\"#動態型別呼叫的包裹器？\" class=\"headerlink\" title=\"動態型別呼叫的包裹器？\"></a>動態型別呼叫的包裹器？</h4><p>Javascript 引擎在型別轉換背後做了許多事情，但也非沒有規則可循，<br>以下的範例是 JavaScript 最難以理解的一部分型別轉換：</p>\n<h5 id=\"比較運算子呼叫-toString\"><a href=\"#比較運算子呼叫-toString\" class=\"headerlink\" title=\"比較運算子呼叫 toString\"></a>比較運算子呼叫 toString</h5><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] == <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>([]); <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>這實在是太詭異了!!不過理解一下背後的原理，「當 Array 拿去比較 value 的時候，toString 包裹器會被呼叫，而不是透過　Boolean 轉換」：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">String</span>([]); <span class=\"hljs-comment\">// ''</span></span><br><span class=\"line\"><span class=\"hljs-string\">''</span> == <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"有趣的-object-object\"><a href=\"#有趣的-object-object\" class=\"headerlink\" title=\"有趣的 [object object]\"></a>有趣的 [object object]</h3><p>在開發過程查詢 error 或其他型轉情境經常會看見或 alert 噴出 <code>[object object]</code> 這類特殊的值，剖析一下出現的原理：</p>\n<h4 id=\"型轉造成的-object-object\"><a href=\"#型轉造成的-object-object\" class=\"headerlink\" title=\"型轉造成的 [object object]\"></a>型轉造成的 [object object]</h4><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] + {}; <span class=\"hljs-comment\">// '[object object]'</span></span><br><span class=\"line\">{} + []; <span class=\"hljs-comment\">// 0</span></span><br></pre></td></tr></tbody></table></figure>\n<p>第一個例子 <code>[] + {};</code>，這是由於 <code>[]</code> + 號型轉為空字串 <code>''</code>，而 <code>{}</code> + 號型轉為 ‘[object object]’ 了；String() 直接調用 <code>.toString</code> 方法來轉換 <code>[]</code>。</p>\n<p>第二個例子 <code>{} + []</code> 中， <code>{}</code>被當作空區塊無作用，只會運算後方的 <code> + []</code> 調用 <code>Number([])</code>，<br>依據型轉規則，陣列屬於物件型別所以型轉數字時會調用 toString 方法來型轉成空字串 <code>String([])</code> 獲得 <code>''</code>，也就是 Number(‘’)，<br>而獲得 0 的結果。</p>\n<blockquote class=\"colorquote danger\"><p>值得注意的是 block <code>{}</code> 放置在最前方會被為 Javascript 引擎視作作用域而非空物件!</p>\n</blockquote>\n\n<h3 id=\"善用嚴格等式（Tripple-Equality）\"><a href=\"#善用嚴格等式（Tripple-Equality）\" class=\"headerlink\" title=\"善用嚴格等式（Tripple Equality）\"></a>善用嚴格等式（Tripple Equality）</h3><p>不同於雙等號造成的型轉悲劇，三等號可以確保最後獲得的比較結果不會被型轉，也能達到預期的值做開發判斷，是比較良好的開發習慣。</p>\n</body></html>",
            "tags": [
                "Javascript"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/09/21/zh-tw/js-weird-parts-operators-precendence-and-associactivity/",
            "url": "http://maomaoxie.github.io/2022/09/21/zh-tw/js-weird-parts-operators-precendence-and-associactivity/",
            "title": "克服 Javascript 的奇怪部分 運算子的相依性與優先性",
            "date_published": "2022-09-21T06:58:56.000Z",
            "content_html": "<html><head></head><body><p>在了解以下的特性以前需要知道，JavaScript 是 syncrounous 同步在執行一個表達式的，<br>所以一次只能執行一個片段的程式碼，也就是一個表達式，一個表達式只能包含一個運算子與兩個參數，所以需要決定執行的次序．</p>\n<h1 id=\"優先性（precendence）\"><a href=\"#優先性（precendence）\" class=\"headerlink\" title=\"優先性（precendence）\"></a>優先性（precendence）</h1><blockquote><p>When there is more than one operators in one executable code, which operator will be called in order of precedence.</p>\n</blockquote>\n<p>當某片段的執行碼具有多個運算子時，那個先執行取決於優先性（precendence）</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">4</span> * <span class=\"hljs-number\">5</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// 23</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>從以下圖表可以檢視優先性：</p>\n<img src=\"/images/js-weird-parts-operators-precendence-and-associactivity/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-operators-precendence-and-associactivity\">\n<p>由於 * 運算子的優先性大於 + 運算子，所以 Javacript 會優先執行 <code>4 * 5</code> 爾後執行 <code>20 + 3</code>；<br>等號的優先性只有 2，所以會最後執行 <code>a = 23</code>。</p>\n<h1 id=\"相依性（Associativity）\"><a href=\"#相依性（Associativity）\" class=\"headerlink\" title=\"相依性（Associativity）\"></a>相依性（Associativity）</h1><blockquote><p>The Associativity is the percedence that determines the operators being called from left to right,<br>or right to left when the percedence are all the same.</p>\n</blockquote>\n<p>當某片段程式碼中所有的運算子優先性相同時，由相依性來決定執行次序為左相依性還是右相依性：<br>左相依性（Left Associativity）表示由左到右執行；右相依性（Right Associativity）表示由右到左執行。</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>, b = <span class=\"hljs-number\">3</span>, c = <span class=\"hljs-number\">4</span>;</span><br><span class=\"line\">a = b = c;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// 4</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b); <span class=\"hljs-comment\">// 4</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c); <span class=\"hljs-comment\">// 4</span></span><br></pre></td></tr></tbody></table></figure>\n\n<img src=\"/images/js-weird-parts-operators-precendence-and-associactivity/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-operators-precendence-and-associactivity\">\n<p>從上圖可以了解到 = 運算子的相依性是右相依性（right to left, Right Associativity），<br>當運算子的優先性都相同時 Javacript 會優先執行右邊的運算子，然後向左一個一個執行。<br><code>a = b = c;</code> 表達式會先執行 <code>b = 4</code>，並且回傳 4 之後執行 <code>a = 4</code>。</p>\n<h1 id=\"大括號（parentheses）最優先\"><a href=\"#大括號（parentheses）最優先\" class=\"headerlink\" title=\"大括號（parentheses）最優先\"></a>大括號（parentheses）最優先</h1><img src=\"/images/js-weird-parts-operators-precendence-and-associactivity/2.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-operators-precendence-and-associactivity\">\n<p>當一個表達式中具有多個運算子，大括號（parentheses）裡的運算會最優先：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a = (<span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">4</span>) * <span class=\"hljs-number\">5</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// 35</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"amp-amp-優先性（precedence）比較\"><a href=\"#amp-amp-優先性（precedence）比較\" class=\"headerlink\" title=\"&amp;&amp; || 優先性（precedence）比較\"></a>&amp;&amp; || 優先性（precedence）比較</h1><img src=\"/images/js-weird-parts-operators-precendence-and-associactivity/3.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-operators-precendence-and-associactivity\">\n<p>在判斷式中經常同時使用 &amp;&amp;（and）與 ||（or），需要特別注意 &amp;&amp;（and）優先級是大於 ||（or）的，<br>不過若專案中有使用到 eslint 則會提示盡量補上大括號（parentheses），來協助辨認次序唷！</p>\n</body></html>",
            "tags": [
                "Javascript"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/09/21/zh-tw/js-weird-parts-operators/",
            "url": "http://maomaoxie.github.io/2022/09/21/zh-tw/js-weird-parts-operators/",
            "title": "克服 Javascript 的奇怪部分 運算子",
            "date_published": "2022-09-21T06:28:51.000Z",
            "content_html": "<html><head></head><body><p>在閱讀本篇文章以前，先給予一個結論方便後續理解：<br>運算子不過就是一種函式而已，而且會回傳一個運算結果的值．</p>\n<p>Javascript 的運算子（operators）有個奇妙的現象就是，運算過程會造成動態型別的轉換而獲得不如預期的結果．</p>\n<h1 id=\"運算子（operators）的定義\"><a href=\"#運算子（operators）的定義\" class=\"headerlink\" title=\"運算子（operators）的定義\"></a>運算子（operators）的定義</h1><h3 id=\"實際上為一種函式\"><a href=\"#實際上為一種函式\" class=\"headerlink\" title=\"實際上為一種函式\"></a>實際上為一種函式</h3><blockquote><p>A special function that is syntactically (written) differently.</p>\n</blockquote>\n\n<h3 id=\"需要兩個參數獲得結果\"><a href=\"#需要兩個參數獲得結果\" class=\"headerlink\" title=\"需要兩個參數獲得結果\"></a>需要兩個參數獲得結果</h3><blockquote><p>Generally, an operator take two parameters and return one result.</p>\n</blockquote>\n\n<h3 id=\"中綴寫法\"><a href=\"#中綴寫法\" class=\"headerlink\" title=\"中綴寫法\"></a>中綴寫法</h3><p>運算子其實就是一種表達式必備的元素，丟進去參數然後運算 return 結果，只是不同於一般的函式寫法，它是使用中綴（infix　notation）的寫法，將參數寫在函式符號的兩邊：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">4</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// 7</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>老式的計算機都是使用後綴的寫法：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span> +;</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"型別轉換\"><a href=\"#型別轉換\" class=\"headerlink\" title=\"型別轉換\"></a>型別轉換</h3><p>Javascript 的運算子造成的隱式型別轉換數不勝數，例如比較運算子（Relational operators），會將數字型別轉換成布林值（Boolean）。</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">3</span> &gt; <span class=\"hljs-number\">4</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// false</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><blockquote><p>Operators are actually spacial types of functions, these parameters are being pass into those functions,<br>and the value  is being returned.<br>There is pre written codes that javaScript engine provides to do or invoke those functions.</p>\n</blockquote>\n<p>運算子只是已經寫好的函式（function）提供使用而已，寫法稍有不同於一般函式，為中綴（infix　notation）的寫法。</p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/09/15/zh-tw/wordpress-ga-track/",
            "url": "http://maomaoxie.github.io/2022/09/15/zh-tw/wordpress-ga-track/",
            "title": "如何在 wordpress 埋入 GA code",
            "date_published": "2022-09-15T02:42:04.000Z",
            "content_html": "<html><head></head><body><p>目前 Google Analytics 已經升級至 GA4，從前綴的追蹤碼 UA- 開頭轉換為 G- 開頭，令許多前端框架的套件還趕不上變化。<br>以下介紹如何在 wordpress 介面插入追蹤碼：</p>\n<h1 id=\"在-GA-建立帳號與資源\"><a href=\"#在-GA-建立帳號與資源\" class=\"headerlink\" title=\"在 GA 建立帳號與資源\"></a>在 GA 建立帳號與資源</h1><p>這一步公司目前已經建置完成，建置的方法須先建立網站資源（網址 url），建立完畢後可在進階選項同時安裝新舊版的 GA code．</p>\n<h1 id=\"wordpress-安裝-GA-步驟\"><a href=\"#wordpress-安裝-GA-步驟\" class=\"headerlink\" title=\"wordpress 安裝 GA 步驟\"></a>wordpress 安裝 GA 步驟</h1><h3 id=\"安裝外掛-Insert-Headers-and-Footers\"><a href=\"#安裝外掛-Insert-Headers-and-Footers\" class=\"headerlink\" title=\"安裝外掛 Insert Headers and Footers\"></a>安裝外掛 Insert Headers and Footers</h3><p>安裝任何外掛程式前先 google wp 外掛黑名單，查看安全並安裝後記得跑跑看網站以免中毒．</p>\n<h3 id=\"埋入-GA-code\"><a href=\"#埋入-GA-code\" class=\"headerlink\" title=\"埋入 GA code\"></a>埋入 GA code</h3><p>舊版 UA- 開頭</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>GA3</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- <span class=\"title class_\">Global</span> site tag (gtag.<span class=\"hljs-property\">js</span>) - <span class=\"title class_\">Google</span> <span class=\"title class_\">Analytics</span> --&gt;</span><br><span class=\"line\"><span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">async</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXXXX-1\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"hljs-language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"><span class=\"variable language_\">window</span>.<span class=\"hljs-property\">dataLayer</span> = <span class=\"variable language_\">window</span>.<span class=\"hljs-property\">dataLayer</span> || [];</span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">gtag</span>(<span class=\"hljs-params\"></span>){dataLayer.<span class=\"title function_\">push</span>(<span class=\"variable language_\">arguments</span>);}</span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"><span class=\"title function_\">gtag</span>(<span class=\"hljs-string\">'js'</span>, <span class=\"hljs-keyword\">new</span> <span class=\"title class_\">Date</span>());</span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"></span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"><span class=\"title function_\">gtag</span>(<span class=\"hljs-string\">'config'</span>, <span class=\"hljs-string\">'UA-XXXXXXXXX-1'</span>);</span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>新版 G- 開頭</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>GA4</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- <span class=\"title class_\">Google</span> tag (gtag.<span class=\"hljs-property\">js</span>) --&gt;</span><br><span class=\"line\"><span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">async</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"hljs-language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"><span class=\"variable language_\">window</span>.<span class=\"hljs-property\">dataLayer</span> = <span class=\"variable language_\">window</span>.<span class=\"hljs-property\">dataLayer</span> || [];</span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">gtag</span>(<span class=\"hljs-params\"></span>){dataLayer.<span class=\"title function_\">push</span>(<span class=\"variable language_\">arguments</span>);}</span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"><span class=\"title function_\">gtag</span>(<span class=\"hljs-string\">'js'</span>, <span class=\"hljs-keyword\">new</span> <span class=\"title class_\">Date</span>());</span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"></span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"><span class=\"title function_\">gtag</span>(<span class=\"hljs-string\">'config'</span>, <span class=\"hljs-string\">'G-XXXXXXXXXX'</span>);</span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure></body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/09/14/zh-tw/touch-and-click-event/",
            "url": "http://maomaoxie.github.io/2022/09/14/zh-tw/touch-and-click-event/",
            "title": "touch 與 click 事件",
            "date_published": "2022-09-14T01:38:48.000Z",
            "content_html": "<html><head></head><body><p>製作完一個 swipe 專案之後發覺 click 事件會同時觸發 touch 事件，造成綁定同一個 dom 時觸發兩次，解決方式有幾種：</p>\n<h1 id=\"針對-click-與-touch-綁定不同的-dom\"><a href=\"#針對-click-與-touch-綁定不同的-dom\" class=\"headerlink\" title=\"針對 click 與 touch 綁定不同的 dom\"></a>針對 click 與 touch 綁定不同的 dom</h1><p>例如輪播可以針對箭頭按鈕綁定 click，輪播對象綁定 touch。</p>\n<h1 id=\"改用-mousedown-amp-up-取代-click-事件\"><a href=\"#改用-mousedown-amp-up-取代-click-事件\" class=\"headerlink\" title=\"改用 mousedown &amp; up 取代 click 事件\"></a>改用 mousedown &amp; up 取代 click 事件</h1><p>可以區分滑鼠的點擊事件使用 mouse 系列，與手指的點擊使用 touch 事件。</p>\n<h1 id=\"改用-pointer-event\"><a href=\"#改用-pointer-event\" class=\"headerlink\" title=\"改用 pointer event\"></a>改用 pointer event</h1><p>該事件可以適用於所有觸控裝置，包括觸控筆與手指，可以更敏銳的偵測觸控的方式，有幾種形式可以使用：</p>\n<h3 id=\"pointerover\"><a href=\"#pointerover\" class=\"headerlink\" title=\"pointerover\"></a>pointerover</h3><p>Fired when a pointer is moved into an element’s hit test boundaries.<br>當觸控進入指定區域時觸發。</p>\n<h3 id=\"ponterenter\"><a href=\"#ponterenter\" class=\"headerlink\" title=\"ponterenter\"></a>ponterenter</h3><p>Fired when a pointer is moved into the hit test boundaries of an element or one of its descendants,<br>including as a result of a pointerdown event from a device that does not support hover<br>當觸控進入指定區域或是子元素區域，及不支援 hover 的裝置上按壓時觸發．</p>\n<h3 id=\"pointerdown\"><a href=\"#pointerdown\" class=\"headerlink\" title=\"pointerdown\"></a>pointerdown</h3><p>Fired when a pointer becomes active buttons state.<br>按壓時觸發．</p>\n<h3 id=\"pointermove\"><a href=\"#pointermove\" class=\"headerlink\" title=\"pointermove\"></a>pointermove</h3><p>Fired when a pointer changes coordinates.<br>This event is also used if the change in pointer state can not be reported by other events.<br>當手指按壓並移動時觸發，亦會使用在 pointer 狀態不為其他事件所察覺時．</p>\n<h3 id=\"pointerup\"><a href=\"#pointerup\" class=\"headerlink\" title=\"pointerup\"></a>pointerup</h3><p>Fired when a pointer is no longer active buttons state.<br>當手指接觸面積離開裝置時觸發．</p>\n<h3 id=\"pointercancel\"><a href=\"#pointercancel\" class=\"headerlink\" title=\"pointercancel\"></a>pointercancel</h3><p>A browser fires this event if it concludes the pointer will no longer be able to generate events<br>(for example the related device is deactivated).<br>當裝置因設置關閉觸控等原因無法觸發 pointer 事件時，瀏覽器會偵測並觸發．</p>\n<h3 id=\"pointerout\"><a href=\"#pointerout\" class=\"headerlink\" title=\"pointerout\"></a>pointerout</h3><p>Fired for several reasons including: pointer is moved out of the hit test boundaries of an element;<br>firing the pointerup event for a device that does not support hover (see pointerup);<br>after firing the pointercancel event (see pointercancel); when a pen stylus leaves the hover range detectable by the digitizer.<br>當手指從裝置面板移開時觸發，亦會同時觸發 pointerup 事件；在 pointercancel 事件完成後也會觸發；當觸控筆離開裝置可偵測的範圍內也會觸發．</p>\n<h3 id=\"pointerleave\"><a href=\"#pointerleave\" class=\"headerlink\" title=\"pointerleave\"></a>pointerleave</h3><p>Fired when a pointer is moved out of the hit test boundaries of an element.<br>For pen devices, this event is fired when the stylus leaves the hover range detectable by the digitizer.<br>跟上面很像，只是不會觸發 pointerup；在 pointercancel 事件完成後不會觸發．</p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/28/restful-api-python/",
            "url": "http://maomaoxie.github.io/2022/08/28/restful-api-python/",
            "title": "restful-api-python",
            "date_published": "2022-08-28T07:29:29.000Z",
            "content_html": "<html><head></head><body><h1 id=\"安裝-python\"><a href=\"#安裝-python\" class=\"headerlink\" title=\"安裝 python\"></a>安裝 python</h1><p><a href=\"https://www.python.org/downloads/\">python 官方網站下載點</a><br>選擇 downloads 並且記得勾選 Add Python to PATH，就可以在終端機輸入<code>python3</code>，並且使用囉！</p>\n<h1 id=\"public-APIs\"><a href=\"#public-APIs\" class=\"headerlink\" title=\"public APIs\"></a>public APIs</h1><p>顧名思義就是開放 API（Open API），</p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/25/zh-tw/wowjs-in-vue2-typescript/",
            "url": "http://maomaoxie.github.io/2022/08/25/zh-tw/wowjs-in-vue2-typescript/",
            "title": "在 Vue2 + Typescript 專案中引入 WOW.js",
            "date_published": "2022-08-25T03:00:37.000Z",
            "content_html": "<html><head></head><body><h1 id=\"安裝模組\"><a href=\"#安裝模組\" class=\"headerlink\" title=\"安裝模組\"></a>安裝模組</h1><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install wowjs</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"引用-css\"><a href=\"#引用-css\" class=\"headerlink\" title=\"引用 css\"></a>引用 css</h1><p>這一步要注意的地方是 animate.css 的使用方式，使用 npm install 安裝的 animate.css 會在 wowjs 套件包下的 <code>css/lib/animate.css</code>，而不是透過 npm 安裝的 animate.css：</p>\n<h3 id=\"wowjs-套件包下的-animate-css\"><a href=\"#wowjs-套件包下的-animate-css\" class=\"headerlink\" title=\"wowjs 套件包下的 animate.css\"></a>wowjs 套件包下的 animate.css</h3><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'css/lib/animate.css'</span>;</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"npm-安裝的-animate-css\"><a href=\"#npm-安裝的-animate-css\" class=\"headerlink\" title=\"npm 安裝的 animate.css\"></a>npm 安裝的 animate.css</h3><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'animate.css'</span>;</span><br></pre></td></tr></tbody></table></figure>\n\n<blockquote class=\"colorquote danger\"><p>值得注意的點就是在於 css 名稱套用上的不同，wowjs 使用上不需要 animate 前綴，而 npm 安裝的需要，如果得搭配滾動視窗位置才套用動畫，需要注意 wowjs 套件包下的 <code>css/lib/animate.css</code> 引用模組方式。</p>\n</blockquote>\n\n<blockquote><p><a href=\"https://blog.csdn.net/qq_32963841/article/details/115690823\">关于wow.js在vue项目中的使用及遇到的坑（css3效果）</a></p>\n</blockquote></body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/20/zh-tw/gcp-project-switch/",
            "url": "http://maomaoxie.github.io/2022/08/20/zh-tw/gcp-project-switch/",
            "title": "gcp-project-switch",
            "date_published": "2022-08-20T10:52:22.000Z",
            "content_html": "<html><head></head><body><p>在 GCP 上部屬不同專案時需要切換專案，根據專案 ID 來切換：</p>\n<h1 id=\"查看專案-ID\"><a href=\"#查看專案-ID\" class=\"headerlink\" title=\"查看專案 ID\"></a>查看專案 ID</h1><figure class=\"highlight plaintext hljs\"><figcaption><span>GCP</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcloud projects list</span><br><span class=\"line\"></span><br><span class=\"line\">PROJECT_ID: XXX</span><br><span class=\"line\">NAME: baby-bill</span><br><span class=\"line\">PROJECT_NUMBER: XXXXX</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"切換專案\"><a href=\"#切換專案\" class=\"headerlink\" title=\"切換專案\"></a>切換專案</h1><figure class=\"highlight plaintext hljs\"><figcaption><span>GCP</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcloud config set project `PROJECT ID`</span><br></pre></td></tr></tbody></table></figure></body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/20/typescript-why-use-it/",
            "url": "http://maomaoxie.github.io/2022/08/20/typescript-why-use-it/",
            "title": "typescript-why-use-it",
            "date_published": "2022-08-20T06:42:17.000Z",
            "content_html": "<html><head></head><body><h1 id=\"Typescript-is-a-superset-of-Javascript\"><a href=\"#Typescript-is-a-superset-of-Javascript\" class=\"headerlink\" title=\"Typescript is a superset of Javascript\"></a>Typescript is a superset of Javascript</h1><p>Typescript 提升的重點就是：優化了你的原生 Javascript 型別提示。<br>Typescript 是根基在 Javascript 語言之上的一個超集，他提供更強大的特點並且優化了 Javascript 的缺陷，使其運作與開發上有更大程度的提升，但 Typescript 不能在瀏覽器引擎上運作。<br>Typescript 是 Javascript 的升級版本，最終仍會編譯成 Javascript 提供瀏覽器運作，只是相當程度上增添了許多特性與優點，例如：</p>\n<h4 id=\"在開發早期發現錯誤提示，能早點修復。\"><a href=\"#在開發早期發現錯誤提示，能早點修復。\" class=\"headerlink\" title=\"在開發早期發現錯誤提示，能早點修復。\"></a>在開發早期發現錯誤提示，能早點修復。</h4><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">addNumbers</span> (num1, num2) {</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> num1 + num2;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(addNumbers (<span class=\"hljs-string\">'1'</span>, <span class=\"hljs-string\">'2'</span>))</span><br></pre></td></tr></tbody></table></figure>\n\n<p>以上的代碼期望的結果是 <code>1+2 = 3</code>，但是 JavaScript 本身的隱性型別轉換造成截然不同的結果，得到了 <code>23</code>。</p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/20/seo-know-how/",
            "url": "http://maomaoxie.github.io/2022/08/20/seo-know-how/",
            "title": "seo-know-how",
            "date_published": "2022-08-20T02:26:25.000Z",
            "content_html": "<html><head></head><body><p>SEO 分為網站結構 &amp; 內容<br>網站競品 新聞類型 SEO 結構不能輸別人</p>\n<p>搜尋引擎</p>\n<h1 id=\"網站連結\"><a href=\"#網站連結\" class=\"headerlink\" title=\"網站連結\"></a>網站連結</h1><h3 id=\"任何頁面必須可以內連\"><a href=\"#任何頁面必須可以內連\" class=\"headerlink\" title=\"任何頁面必須可以內連\"></a>任何頁面必須可以內連</h3><p>孤兒頁面對收錄到 SEO 非常扣分</p>\n<h4 id=\"蜘蛛網結構\"><a href=\"#蜘蛛網結構\" class=\"headerlink\" title=\"蜘蛛網結構\"></a>蜘蛛網結構</h4><p>網站內部蜘蛛網結構的互連非常重要，越多就越能被 Google 搜尋到，會比提交來的重要</p>\n<h3 id=\"權重高的網站外連\"><a href=\"#權重高的網站外連\" class=\"headerlink\" title=\"權重高的網站外連\"></a>權重高的網站外連</h3><p>由權重高的網站，例如新聞網站有連結過來就能大大提高收錄機會</p>\n<h1 id=\"網站結構\"><a href=\"#網站結構\" class=\"headerlink\" title=\"網站結構\"></a>網站結構</h1><h3 id=\"sitemap\"><a href=\"#sitemap\" class=\"headerlink\" title=\"sitemap\"></a>sitemap</h3><p>加入檢索隊列(Crawl Queue)的行為可以透過提交網站結構的 sitemap 至 google search console，而且不能造假也沒有無效的網頁連結（ex. 404、500 等）<br>sitemap是有上限的</p>\n<h3 id=\"robots-txt\"><a href=\"#robots-txt\" class=\"headerlink\" title=\"robots.txt\"></a>robots.txt</h3><p>開發階段不想曝光的網頁可以設定 robots.txt 不被收錄，但並非百分百有效<br>最好是設定密碼登入去擋內容，或是不要上線</p>\n<h1 id=\"domain-knowledge\"><a href=\"#domain-knowledge\" class=\"headerlink\" title=\"domain knowledge\"></a>domain knowledge</h1><p>領域專長<br>產業的核心知識 了解TA需求</p>\n<h1 id=\"breadcrumb\"><a href=\"#breadcrumb\" class=\"headerlink\" title=\"breadcrumb\"></a>breadcrumb</h1><p>網站麵包屑</p>\n<h1 id=\"you-may-like\"><a href=\"#you-may-like\" class=\"headerlink\" title=\"you may like\"></a>you may like</h1><p>你可能會喜歡的相關文章</p>\n<p>文章序號丟API 運算連結之間的關係(AI 資料工程師)</p>\n<h1 id=\"js-做的連結不會收錄\"><a href=\"#js-做的連結不會收錄\" class=\"headerlink\" title=\"js 做的連結不會收錄\"></a>js 做的連結不會收錄</h1><p>可以追蹤：</p>\n<figure class=\"highlight plaintext hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=\"https://example.com\"&gt;</span><br><span class=\"line\">&lt;a href=\"/relative/path/file\"&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>無法追蹤：</p>\n<figure class=\"highlight plaintext hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a routerLink=\"some/path\"&gt;</span><br><span class=\"line\">&lt;span href=\"https://example.com\"&gt;</span><br><span class=\"line\">&lt;a onclick=\"goto('https://example.com')\"&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n\n<h1 id=\"網站更新頻率要勤\"><a href=\"#網站更新頻率要勤\" class=\"headerlink\" title=\"網站更新頻率要勤\"></a>網站更新頻率要勤</h1><p>經常更新的網站才會被 google 將排名提前</p>\n<h1 id=\"UI-amp-UX-要好\"><a href=\"#UI-amp-UX-要好\" class=\"headerlink\" title=\"UI &amp; UX 要好\"></a>UI &amp; UX 要好</h1><p>網站體驗好 SEO 就會好，SEO 好廣告投入就可以降低</p>\n<h1 id=\"更新時間\"><a href=\"#更新時間\" class=\"headerlink\" title=\"更新時間\"></a>更新時間</h1><p>網站的 sitemap 會註明網站更新時間，對 google 的 SEO 排名也有影響</p>\n<h1 id=\"網站的-canonical-標準網址\"><a href=\"#網站的-canonical-標準網址\" class=\"headerlink\" title=\"網站的 canonical 標準網址\"></a>網站的 canonical 標準網址</h1><p>主網址會被 google 拿來計算收錄的頁面數量</p>\n<figure class=\"highlight plaintext hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=\"canonical\" href=\"\" &gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"網頁未加入索引\"><a href=\"#網頁未加入索引\" class=\"headerlink\" title=\"網頁未加入索引\"></a>網頁未加入索引</h3><p>不同網址但內容一樣會扣分，記得設定 canonical</p>\n<h1 id=\"基本要設定的\"><a href=\"#基本要設定的\" class=\"headerlink\" title=\"基本要設定的\"></a>基本要設定的</h1><title>網頁標題</title>\n<meta name=\"description\" content=\"\">\n// 設定網站縮圖\n<link rel=\"image_src\" href=\"\">\n\n<p>可以設定的</p>\n<figure class=\"highlight plaintext hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta content=\"\" name=\"copyright\"&gt;</span><br><span class=\"line\">&lt;meta content=\"\" name=\"author\"&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>要小心的</p>\n<figure class=\"highlight plaintext hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=\"keywords\" content=\"關鍵字1, 關鍵字2\" /&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"社群媒體\"><a href=\"#社群媒體\" class=\"headerlink\" title=\"社群媒體\"></a>社群媒體</h1><p>可以透過<a href=\"https://metatags.io/\">metatags</a>協助產生網站的縮圖</p>\n<h1 id=\"移除外部連結的權重\"><a href=\"#移除外部連結的權重\" class=\"headerlink\" title=\"移除外部連結的權重\"></a>移除外部連結的權重</h1><p>其目的在於告訴搜尋引擎不要索引抓取這個連結，同時也不要給予他權重。<br>Nofollow 反向連結是只將 <code>&lt;a href=\"https://example.com.tw\"&gt;Example&lt;/a&gt;</code> 加入 <code>rel=\"nofollow\"</code> 標籤<br><a href=\"https://example.com.tw\" ref=\"nofollow\">Example</a>。</p>\n<h1 id=\"使用者體驗\"><a href=\"#使用者體驗\" class=\"headerlink\" title=\"使用者體驗\"></a>使用者體驗</h1><p>內容要與主題相符</p>\n<h1 id=\"https\"><a href=\"#https\" class=\"headerlink\" title=\"https\"></a>https</h1><p>cloudflare 有提供免費的 https </p>\n<h1 id=\"AWD-AMP-PWA\"><a href=\"#AWD-AMP-PWA\" class=\"headerlink\" title=\"AWD AMP PWA\"></a>AWD AMP PWA</h1><p>提升行動裝置的網站架構亦可以提升網站體驗與速度</p>\n<h1 id=\"網站核心體驗三大指標\"><a href=\"#網站核心體驗三大指標\" class=\"headerlink\" title=\"網站核心體驗三大指標\"></a>網站核心體驗三大指標</h1><h3 id=\"LCP\"><a href=\"#LCP\" class=\"headerlink\" title=\"LCP\"></a>LCP</h3><p>最大內容繪製，2.5 秒可以渲染完畢</p>\n<h3 id=\"FID\"><a href=\"#FID\" class=\"headerlink\" title=\"FID\"></a>FID</h3><p>首次輸入的延遲時間，頁面互動的反應時間</p>\n<h3 id=\"CLS\"><a href=\"#CLS\" class=\"headerlink\" title=\"CLS\"></a>CLS</h3><p>累積版面配置轉移，還未讀取到的資料先將空間撐開（lazyload），避免使用者捲到的位置空間還未撐開，例如以下：</p>\n<figure class=\"highlight plaintext hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img width=\"200\" height=\"300\" /&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"SEO-v-s-廣告\"><a href=\"#SEO-v-s-廣告\" class=\"headerlink\" title=\"SEO v.s 廣告\"></a>SEO v.s 廣告</h1><p>在網站內放置廣告版位會對 SEO 扣分，但收入又需要靠廣告，是一種互相牴觸的生態</p>\n<h1 id=\"title\"><a href=\"#title\" class=\"headerlink\" title=\"title\"></a>title</h1><p>網頁的 title 都要放置網站名稱，例如：<br>網頁的內容概要、網站名稱</p>\n<h1 id=\"熱門關鍵字\"><a href=\"#熱門關鍵字\" class=\"headerlink\" title=\"熱門關鍵字\"></a>熱門關鍵字</h1><p>倘若 SEO 好熱門關鍵字也可以提升排名</p>\n<h1 id=\"SVG-圖片格式\"><a href=\"#SVG-圖片格式\" class=\"headerlink\" title=\"SVG 圖片格式\"></a>SVG 圖片格式</h1><p>img 有 alt 可以幫助搜尋引擎了解圖片內容，SVG 則可以加上 title 以及 describe 等同於 img 的 alt，結構如下：</p>\n<figure class=\"highlight plaintext hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;svg height=\"100\" width=\"100\" aria-labelledby=\"svgTitle svgDesc\" role=\"img\"&gt;</span><br><span class=\"line\">  &lt;title id=\"svgTitle\"&gt;Circle&lt;/title&gt;</span><br><span class=\"line\">  &lt;desc id=\"svgDesc\"&gt;This is a red circle&lt;/desc&gt;</span><br><span class=\"line\">  &lt;circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"3\" fill=\"red\" /&gt;</span><br><span class=\"line\">&lt;/svg&gt; </span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"SERP-結構化資料\"><a href=\"#SERP-結構化資料\" class=\"headerlink\" title=\"SERP 結構化資料\"></a>SERP 結構化資料</h1><p><a href=\"https://developers.google.com/search/docs/advanced/structured-data/intro-structured-data?hl=zh-tw\">參考資料</a></p>\n<h3 id=\"JSON-LD\"><a href=\"#JSON-LD\" class=\"headerlink\" title=\"JSON-LD\"></a>JSON-LD</h3><p>結構化資料的格式，例如 Google 提供的範例：</p>\n<figure class=\"highlight plaintext hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;Apple Pie by Grandma&lt;/title&gt;</span><br><span class=\"line\">    &lt;script type=\"application/ld+json\"&gt;</span><br><span class=\"line\">    {</span><br><span class=\"line\">      \"@context\": \"https://schema.org/\",</span><br><span class=\"line\">      \"@type\": \"Recipe\",</span><br><span class=\"line\">      \"name\": \"Apple Pie by Grandma\",</span><br><span class=\"line\">      \"author\": \"Elaine Smith\",</span><br><span class=\"line\">      \"image\": \"http://images.edge-generalmills.com/56459281-6fe6-4d9d-984f-385c9488d824.jpg\",</span><br><span class=\"line\">      \"description\": \"A classic apple pie.\",</span><br><span class=\"line\">      \"aggregateRating\": {</span><br><span class=\"line\">        \"@type\": \"AggregateRating\",</span><br><span class=\"line\">        \"ratingValue\": \"4.8\",</span><br><span class=\"line\">        \"reviewCount\": \"7462\",</span><br><span class=\"line\">        \"bestRating\": \"5\",</span><br><span class=\"line\">        \"worstRating\": \"1\"</span><br><span class=\"line\">      },</span><br><span class=\"line\">      \"prepTime\": \"PT30M\",</span><br><span class=\"line\">      \"totalTime\": \"PT1H30M\",</span><br><span class=\"line\">      \"recipeYield\": \"8\",</span><br><span class=\"line\">      \"nutrition\": {</span><br><span class=\"line\">        \"@type\": \"NutritionInformation\",</span><br><span class=\"line\">        \"calories\": \"512 calories\"</span><br><span class=\"line\">      },</span><br><span class=\"line\">      \"recipeIngredient\": [</span><br><span class=\"line\">        \"1 box refrigerated pie crusts, softened as directed on box\",</span><br><span class=\"line\">        \"6 cups thinly sliced, peeled apples (6 medium)\"</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    }</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>顯示的內容：</p>\n<img src=\"/images/seo-know-how/3.png\" class=\"\" width=\"800\" height=\"200\" title=\"seo-know-how\">\n\n<p>驗證是否有誤：<br><a href=\"https://search.google.com/test/rich-results\">驗證連結</a></p>\n<blockquote><p>參考網站：<br><a href=\"https://tools.wingzero.tw/article/sn/1187\">紅色死神 DETOOLS</a></p>\n</blockquote></body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/18/zh-tw/safari-preventDefault-bug/",
            "url": "http://maomaoxie.github.io/2022/08/18/zh-tw/safari-preventDefault-bug/",
            "title": "Safari IOS 11.3 後 preventDefault 失效問題",
            "date_published": "2022-08-18T01:12:34.000Z",
            "content_html": "<html><head></head><body><img src=\"https://i.gifer.com/2BC.gif\" class=\"\" width=\"300\" height=\"200\" title=\"safari-preventDefault-bug\">\n<p>沒錯的，我們可愛的 Safari 又又又出現了 bug，來看看這個高級 IE 的除錯日常（Safari 愛好者不要鞭我）</p>\n<h1 id=\"click-事件綁定\"><a href=\"#click-事件綁定\" class=\"headerlink\" title=\"click 事件綁定\"></a>click 事件綁定</h1><p>網站開發過程的需求是，當元件沒有 props 連結路徑時就預防 a 連結的預設跳轉行為，以下是元件的 code：</p>\n<figure class=\"highlight plaintext hljs\"><figcaption><span>component</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// HTML</span><br><span class=\"line\">&lt;a class=\"w-100 h-100\" :class=\"[ url === '' ? 'pointer-events-none' : 'url-active' ]\" @click=\"changeTab()\"&gt;</span><br><span class=\"line\">&lt;/a&gt;</span><br><span class=\"line\">// Script</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">@Component</span><br><span class=\"line\">export default class ItemCard extends Vue {</span><br><span class=\"line\">    @Prop({ default: '' }) url?: string;</span><br><span class=\"line\">    private changeTab (event: any) {</span><br><span class=\"line\">        if (this.url === '') {</span><br><span class=\"line\">        event.preventDefault();</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"contextmenu-事件綁定\"><a href=\"#contextmenu-事件綁定\" class=\"headerlink\" title=\"contextmenu 事件綁定\"></a>contextmenu 事件綁定</h1><p>後來發現 Safari 的瀏覽器，手機與電腦綁定 a 標籤 click 事件都無法達到避免預設行為的效果，於是求救谷歌大神：</p>\n<blockquote><p>To target right click events, use contextmenu rather than mousedown.</p>\n<p><code>document.querySelector(\"#GL-Surface\").addEventListener(\"contextmenu\",     function(e) {         e.preventDefault();     }); </code><br>Note that the options that appear on right click do appear only when the right click button is released, so I don’t think mousedown is at all suitable here.</p>\n<p><a href=\"https://stackoverflow.com/questions/62245019/javascript-preventdefault-not-working-in-safari\">Javascript preventDefault() not working in Safari</a></p>\n</blockquote>\n\n<p>這裡面提及的<strong>contextmenu</strong>事件是右鍵出現的選單，抱持著嘗試看看的心情監聽contextmenu事件，並綁定了一樣的函式．竟然成功了？？？</p>\n<p>第一次看到這個<strong>contextmenu</strong>事件，來瞧瞧 MDN 怎麼說：</p>\n<blockquote><p>被触发的 contextmenu 事件的默认行为被 preventDefault() 取消了，因此，在第一段右击鼠标时什么也不会发生<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/contextmenu\">contextmenu</a></p>\n</blockquote>\n\n<h1 id=\"ios11-3-版本後\"><a href=\"#ios11-3-版本後\" class=\"headerlink\" title=\"ios11.3 版本後\"></a>ios11.3 版本後</h1><p>有人提及<strong>ios11.3 and later</strong>預設行為就失效了</p>\n<blockquote><p>This is not an issue by React and is caused by the recent movement of browser vendors to improve performance on mobile devices.<br>Some events (usually those that would fire when you scroll) are <strong>getting passive by default</strong>.<br><a href=\"https://github.com/facebook/react/issues/13369\">e.preventDefault() does not work with safari in ios11.3 and later #13369</a></p>\n</blockquote>\n\n<h1 id=\"改動是為了優化體驗\"><a href=\"#改動是為了優化體驗\" class=\"headerlink\" title=\"改動是為了優化體驗\"></a>改動是為了優化體驗</h1><p>以上的說明原由來自於性能優化的考量，由於手機裝置在滾動時觸發太多主動事件會嚴重影響體驗，因故某些事件都被調整預設為<strong>被動的（passive）</strong>，來看看以下說明：<br>（附上不負責任翻譯）</p>\n<blockquote><p>We know that scrolling responsiveness is critical to the user’s engagement with a website on mobile, yet touch event listeners often cause serious scrolling performance problems.<br>在手機裝置中滾動事件的敏感度放大了使用者的體驗，可能造成延遲或性能不好。</p>\n<p>Chrome has been addressing this by allowing touch event listeners to be passive (passing the {passive: true} option to addEventListener()) and shipping the pointer events API. These are great features to drive new content into models that don’t block scrolling, but developers sometimes find them hard to understand and adopt.<br>Chrome 在事件監聽上預設了被動參數為 true，避免滾動事件被阻擋。</p>\n<p>Developer-defined “passive event listeners” solve this. When you add a touch event with a {passive: true} object as the third parameter in your event handler then you are telling the browser that the touchstart listener will not call preventDefault() and the browser can safely perform the scroll without blocking on the listener.<br>當你設定事件監聽被動參數為 true，該事件就不會觸發**preventDefault()**避免滾動事件卡卡的</p>\n<p><a href=\"https://developer.chrome.com/blog/scrolling-intervention/\">Making touch scrolling fast by default</a></p>\n</blockquote>\n\n<p>設定的方式與參數例如這樣：<br><code>window.addEventListener(\"touchstart\", func, {passive: true} );</code></p>\n<h1 id=\"弔詭的地方\"><a href=\"#弔詭的地方\" class=\"headerlink\" title=\"弔詭的地方\"></a>弔詭的地方</h1><ol>\n<li>以上說明是針對 Chrome 瀏覽器的性能優化改動，不是 safari 啊？</li>\n<li>MDN 提及 contextmenu 事件已經不為瀏覽器所支援，但 safari 卻必須使用 contextmenu 事件綁定並且搭配 preventDefault 才能生效？而且註明 safari ios 是唯一不支援此事件的瀏覽器？</li>\n</ol>\n<img src=\"/images/safari-preventDefault-bug/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"safari-preventDefault-bug\">\n<img src=\"https://c.tenor.com/sAMt7DszgXMAAAAC/%E9%BB%91%E4%BA%BA%E5%95%8F%E8%99%9F.gif\" class=\"\" width=\"350\" height=\"200\" title=\"safari-preventDefault-bug\">\n\n<p>也許下次可以試試看直接把監聽器的 passive 設為 false 試試看 XD</p>\n</body></html>",
            "tags": [
                "safari",
                "javaScript",
                "preventDefault",
                "ios",
                "mobile"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/17/zh-tw/js-object-fromEntries/",
            "url": "http://maomaoxie.github.io/2022/08/17/zh-tw/js-object-fromEntries/",
            "title": "Js 物件陣列轉換的方法，真香！",
            "date_published": "2022-08-17T02:22:19.000Z",
            "content_html": "<html><head></head><body><img src=\"https://exp-picture.cdn.bcebos.com/3201a8f39187031c063126496a86242fa972ec4a.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_auto/quality,q_80\" class=\"\" width=\"300\" height=\"200\" title=\"真香\">\n<p><a href=\"https://exp-picture.cdn.bcebos.com/3201a8f39187031c063126496a86242fa972ec4a.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_auto/quality,q_80\">圖片來源</a></p>\n<p>今天來介紹一下資料處理的好兄弟，<code>Object.entries</code> 以及 <code>Object.fromEntries</code>。</p>\n<p>工作上的需求情境是這樣：<br>一個物件裡有多個 key，但我只需要複製部份的 key 資料，不用全部時可以使用以下作法。</p>\n<h1 id=\"Object-entries\"><a href=\"#Object-entries\" class=\"headerlink\" title=\"Object.entries\"></a>Object.entries</h1><p>工作上的老朋友，常用在物件轉換成陣列時使用，方法特色是將物件內的 key 與 value 轉變成一個<strong>成對的陣列</strong>。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>Object.entries</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> obj = {</span><br><span class=\"line\"><span class=\"hljs-attr\">fruits</span>: <span class=\"hljs-string\">'apple'</span>,</span><br><span class=\"line\"><span class=\"hljs-attr\">beverage</span>: <span class=\"hljs-string\">'choco milk'</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> outcome = <span class=\"title class_\">Object</span>.<span class=\"title function_\">entries</span>(obj);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(outcome);</span><br><span class=\"line\"><span class=\"hljs-comment\">// [</span></span><br><span class=\"line\">    [ <span class=\"hljs-string\">'fruits'</span>, <span class=\"hljs-string\">'apple'</span> ],</span><br><span class=\"line\">    [ <span class=\"hljs-string\">'beverage'</span>, <span class=\"hljs-string\">'choco milk'</span> ],</span><br><span class=\"line\">]</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"Object-fromEntries\"><a href=\"#Object-fromEntries\" class=\"headerlink\" title=\"Object.fromEntries\"></a>Object.fromEntries</h1><p>跟上面的相反，常用在陣列轉換成物件時使用，方法特色是將成對的 key 與 value 轉變成一個<strong>物件</strong>。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>Object.fromEntries</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> obj = {</span><br><span class=\"line\"><span class=\"hljs-attr\">fruits</span>: <span class=\"hljs-string\">'apple'</span>,</span><br><span class=\"line\"><span class=\"hljs-attr\">beverage</span>: <span class=\"hljs-string\">'choco milk'</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> entries = <span class=\"title class_\">Object</span>.<span class=\"title function_\">entries</span>(obj);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"hljs-string\">'entries'</span>, entries);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> fromEntries = <span class=\"title class_\">Object</span>.<span class=\"title function_\">fromEntries</span>(entries);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"hljs-string\">'fromEntries'</span>, fromEntries);</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"綜合應用\"><a href=\"#綜合應用\" class=\"headerlink\" title=\"綜合應用\"></a>綜合應用</h1><p>回到主題，若只需要複製部份的 key 資料可以結合 filter 過濾需要的 key 值：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> obj = {</span><br><span class=\"line\"><span class=\"hljs-attr\">fruits</span>: <span class=\"hljs-string\">'apple'</span>,</span><br><span class=\"line\"><span class=\"hljs-attr\">beverage</span>: <span class=\"hljs-string\">'choco milk'</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> onlyBeverage = <span class=\"title class_\">Object</span>.<span class=\"title function_\">entries</span>(obj).<span class=\"title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">[key, value]</span>) =&gt;</span> key === <span class=\"hljs-string\">'beverage'</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(onlyBeverage);</span><br><span class=\"line\"><span class=\"hljs-comment\">// ['beverage', 'choco milk']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> transferArrayToObject = <span class=\"title class_\">Object</span>.<span class=\"title function_\">fromEntries</span>(onlyBeverage);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(transferArrayToObject);</span><br><span class=\"line\"><span class=\"hljs-comment\">// { 'beverage': 'choco milk' }</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>參考資料<a href=\"https://masteringjs.io/tutorials/fundamentals/filter-key\">在這</a></p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/09/zh-tw/http-methods-idempotent/",
            "url": "http://maomaoxie.github.io/2022/08/09/zh-tw/http-methods-idempotent/",
            "title": "RESTful API 方法觀念介紹 - idempotent",
            "date_published": "2022-08-09T07:14:24.000Z",
            "content_html": "<html><head></head><body><p>RESTful API 呼叫的方法中，離不開四個主軸 CRUD，CREATE、READ/RETREIVE、UPDATE 還有 DELETE。<br>而其中就有分是否為 <strong>Idempotent 的方法</strong>，甚麼意思呢？</p>\n<h1 id=\"甚麼是Idempotent（冪等）\"><a href=\"#甚麼是Idempotent（冪等）\" class=\"headerlink\" title=\"甚麼是Idempotent（冪等）\"></a>甚麼是Idempotent（冪等）</h1><blockquote><p>A request method is considered “idempotent” if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request. </p>\n</blockquote>\n\n<p>看為只覺得在母鯊大，沒關係我們繼續看下去：</p>\n<blockquote><p>Of the request methods defined by this specification, PUT, DELETE, and safe request methods are idempotent.</p>\n<footer><strong>Lauviah0622</strong><cite><a href=\"https://lance.coderbridge.io/2021/06/06/what-is-safe-method-and-indempotent-methods/\">[極短篇] HTTP 的 Safe method 還有 Idempotent method</a></cite></footer></blockquote>\n\n<p>dempotent（冪等）的方法不管你做一次、兩次乃至一百次，對於伺服器端資料的結果都一樣，是安全而沒有副作用的，可以安心服用；<br>相反的非 Idempotent 的方法則是需要謹慎考慮的、會改動伺服器資料庫的、有副作用的，也就是非安全請求。</p>\n<p>我們來看看更精簡好懂的解釋：</p>\n<blockquote><p>Idempotent operations produce the same result even when the operation is repeated many times. The result of the 2nd, 3rd, and 1,000th repeat of the operation will return exactly the same result as the 1st time.<br>冪等運算是指無論操作多少次結果都會與第一次相同。</p>\n<p>For example, simple mathematical examples of idempotency include:</p>\n<p>x + 0;<br>x = 5;</p>\n<p>In the first example, adding zero will never change the result, regardless of how many times you do it. In the second, x is always 5. Again, this is the case, regardless of how many times you perform the operation. Both of these examples describe an operation that is idempotent.</p>\n<p>以上兩個例子都說明了這兩個表達是無論執行幾次都會是相同結果，這就是 Idempotent（冪等）。</p>\n<footer><strong>James E.</strong><cite><a href=\"https://blog.dreamfactory.com/what-is-idempotency/\">what-is-idempotency</a></cite></footer></blockquote>\n\n<h1 id=\"冪等不等於安全請求\"><a href=\"#冪等不等於安全請求\" class=\"headerlink\" title=\"冪等不等於安全請求\"></a>冪等不等於安全請求</h1><blockquote><p>The concepts of ‘idempotent methods’ and ‘safe methods’ are often confused. A safe method does not change the value that is returned, it reads – but it never writes.<br>Therefore, all safe methods are idempotent, but not all idempotent methods are safe.</p>\n<p>HTTP methods include:<br>POST – Creates a new resource. POST is not idempotent and it is not safe.<br>GET – Retrieves a resource. GET is idempotent and it is safe.<br>HEAD – Retrieves a resource (without response body). HEAD is idempotent and it is safe<br>PUT – Updates/replaces a resource. PUT is idempotent but it is not safe<br>PATCH – Partially updates a resource. PATCH is not idempotent and it is not safe.<br>DELETE – Deletes a resource. DELETE is idempotent but it is not safe.<br>TRACE – Performs a loop-back test. TRACE is idempotent but it is not safe.</p>\n<footer><strong>James E.</strong><cite><a href=\"https://blog.dreamfactory.com/what-is-idempotency/\">what-is-idempotency</a></cite></footer></blockquote>\n\n<p>安全請求只會讀取，所以都是冪等的，但冪等方法不一定都是安全請求。</p>\n<p>學術的部份我們就此打住，了解一下冪等之於 RESTful API 的意義。</p>\n<h1 id=\"idempotent-methods-冪等的方法\"><a href=\"#idempotent-methods-冪等的方法\" class=\"headerlink\" title=\"idempotent methods 冪等的方法\"></a>idempotent methods 冪等的方法</h1><ol>\n<li>GET</li>\n<li>HEAD（只讀取資料頭而忽略身體）</li>\n<li>PUT</li>\n<li>DELETE</li>\n<li>OPTIONS</li>\n</ol>\n<p>以上方式無論發幾次 request，結果都等同於一次。</p>\n<blockquote><p>通常 DELETE 會帶上 id，所以刪除 1 次和刪除 100 次是一樣的，server 那邊找不到 id 操作就會被忽略。<br>而 PUT 也一樣，PUT 代表替代的 http 操作，你發了 1 次 request 已經取代了內容後，那即使再發 100 次也只是替代一樣的內容。</p>\n<footer><strong>Lauviah0622</strong><cite><a href=\"https://lance.coderbridge.io/2021/06/06/what-is-safe-method-and-indempotent-methods/\">[極短篇] HTTP 的 Safe method 還有 Idempotent method</a></cite></footer></blockquote>\n\n<h1 id=\"Not-idempotent-methods-非冪等的方法\"><a href=\"#Not-idempotent-methods-非冪等的方法\" class=\"headerlink\" title=\"Not idempotent methods 非冪等的方法\"></a>Not idempotent methods 非冪等的方法</h1><ol>\n<li>POST</li>\n<li>DISPATCH</li>\n</ol>\n<p>以上方法每執行一次就會造成資料變動，但並非每種使用方式都是非冪等，端看 request 的目的是在「修改」還是「增加」，修改可能並不會更改內存量（memory），但是增加就不同了，它也是修改但是擴大了內存量（變多了）：</p>\n<blockquote><p>PATCH 在語意上代表著修改資料，換句話說可能這樣：</p>\n<p><code>PATCH http://blog.com/post?id=1 body {     title: 'new title' } </code><br>發了 100 次和 1 次標題都是同樣的 new title。</p>\n<p><code>PATCH http:shop.com/item/add?id=1 body {     number: 10 }</code><br>requst 代表的是增加 10 個 item 的數量。這種情況下也符合語意（修改資料），但就不符合 Idempotent 了，100 次會新增 1000 個。那 POST 就不用提，一次和 100 次肯定是不一樣的。</p>\n<footer><strong>Lauviah0622</strong><cite><a href=\"https://lance.coderbridge.io/2021/06/06/what-is-safe-method-and-indempotent-methods/\">[極短篇] HTTP 的 Safe method 還有 Idempotent method</a></cite></footer></blockquote>\n\n<h1 id=\"結語\"><a href=\"#結語\" class=\"headerlink\" title=\"結語\"></a>結語</h1><p>讓我最意外的是 DELETE 居然是冪等方法，原因在於無論 request 幾次都只刪同一筆資料（認 id）這個觀念，與以前認為 DELETE 應該會每次刪除不同資料的想法大相逕庭。</p>\n</body></html>",
            "tags": []
        }
    ]
}