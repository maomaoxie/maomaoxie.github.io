{
    "version": "https://jsonfeed.org/version/1",
    "title": "Mawchu 貓奴前端的天空",
    "description": "Mawchu 貓奴前端，為熱愛平面設計與貓咪的前端工程師 - 謝佳芳（毛球）的技術部落格，喜歡撰寫技術文章幫助自己在前端之路成長，涉及 Javascript、Vue、Laravel 與其他程式相關的討論與學習",
    "home_page_url": "http://maomaoxie.github.io",
    "items": [
        {
            "id": "http://maomaoxie.github.io/2022/10/09/google-analytics-knowhow/",
            "url": "http://maomaoxie.github.io/2022/10/09/google-analytics-knowhow/",
            "title": "關於 Google Analytics GA 你應該知道的事",
            "date_published": "2022-10-09T06:20:19.000Z",
            "content_html": "<html><head></head><body><p>Google Analytics 也就是 GA ，即將在 2023 年 7 月 1 日起不再提供<strong>通用版本（Universal Analytics）</strong><br>的資料分析了，全面升級至 GA4 是每個網站與應用程式必須面對的問題。</p>\n<p>而訪客區分為新訪客與舊訪客，以及舊訪客的回訪率等資料。那麼 Google 要如何去區分呢？來了解一下：</p>\n<h1 id=\"GA-如何區分與追蹤同一瀏覽人次\"><a href=\"#GA-如何區分與追蹤同一瀏覽人次\" class=\"headerlink\" title=\"GA 如何區分與追蹤同一瀏覽人次\"></a>GA 如何區分與追蹤同一瀏覽人次</h1><h3 id=\"client-ID\"><a href=\"#client-ID\" class=\"headerlink\" title=\"client ID\"></a>client ID</h3><p>該數據是 GA 用來判定此瀏覽器使用者是否為重複瀏覽的人次，紀錄方式透過 Cookie 裡的 _ga 查看內容的話，<br>會有一段追蹤碼記錄此用戶的 client ID，一旦清除 GA 偵測不到就會判定為新的瀏覽使用者。</p>\n<img src=\"/images/google-analytics-knowhow/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"google-analytics-knowhow\">\n<blockquote><p>由於 GA 判斷新訪客、舊訪客是使用「用戶裝置瀏覽器」來做區別，因此同一個用戶跨裝置訪問網站亦會被計入成兩個用戶，為了精準了解新訪客和舊訪客，事實上引入 User ID 作為統計方式會最為準確，而這一部份我待後續文章分享。</p>\n<footer><strong>author</strong><cite><a href=\"https://medium.com/peerone-technology-%E7%9A%AE%E5%81%B6%E7%8E%A9%E4%BA%92%E5%8B%95%E7%A7%91%E6%8A%80/%E4%B8%80%E7%AA%BA-ga-pageview-%E7%9A%84%E8%BF%BD%E8%B9%A4%E5%8A%9B%E9%87%8F-ga-%E7%B3%BB%E5%88%97-3-afbb42dbb8b5\">一窺 GA PageView 的追蹤力量- GA 系列 (3)</a></cite></footer></blockquote>\n\n<p>GA 參數（這裡指的是事件 event 參數）旨在追蹤與分析使用者在你的網站或 app 上所有的互動行為，<br>提供蒐集來的、具商業行為參考價值的數據。</p>\n<blockquote><p>Parameters provide additional information about the ways users interact with your website. </p>\n<footer><strong>google analytics</strong><cite><a href=\"https://developers.google.com/analytics/devguides/collection/ga4/event-parameters?client_type=gtm\">Set up event parameters</a></cite></footer></blockquote>\n<p>以下初步揭開 GA 的基礎輪廓：</p>\n<h1 id=\"使用者的著陸網頁（Landing-Page）\"><a href=\"#使用者的著陸網頁（Landing-Page）\" class=\"headerlink\" title=\"使用者的著陸網頁（Landing Page）\"></a>使用者的著陸網頁（Landing Page）</h1><p>訪客來到網站的第一個頁面，是整個工作階段（Session）的起始點並且開啟一個工作階段的流程，</p>\n<h1 id=\"基本追蹤事件\"><a href=\"#基本追蹤事件\" class=\"headerlink\" title=\"基本追蹤事件\"></a>基本追蹤事件</h1><p>GA 有<strong>基本追蹤事件</strong>提供開通帳號的使用者，一窺網站或應用程式埋好 GA 追蹤碼之後的<strong>事件（event）</strong>概覽數據，<br>這篇先來簡單介紹 GA 常見的、自動蒐集的數據：</p>\n<p><a href=\"https://support.google.com/analytics/answer/9234069#user_engagement\">官方說明文件</a></p>\n<h3 id=\"網頁瀏覽（page-view）\"><a href=\"#網頁瀏覽（page-view）\" class=\"headerlink\" title=\"網頁瀏覽（page_view）\"></a>網頁瀏覽（page_view）</h3><p>在指定的時間區段內，所有使用者在網站或應用程式的網頁瀏覽（造訪）量；<br>其中使用者的分母根據 Client ID 計次，來得知網站有多少不重複使用者。</p>\n<img src=\"/images/google-analytics-knowhow/2.png\" class=\"\" width=\"600\" height=\"200\" title=\"google-analytics-knowhow\">\n\n\n<h3 id=\"締結互動（user-engagement）\"><a href=\"#締結互動（user-engagement）\" class=\"headerlink\" title=\"締結互動（user_engagement）\"></a>締結互動（user_engagement）</h3><blockquote><p>The User engagement metric shows the time that your app screen was in the foreground or your web page was in focus. When your site or app is running but no page or screen is displayed, Analytics doesn’t collect the metric. The metric can help you understand when users actively use your website or app.</p>\n<footer><strong>google link What is user engagement on Google Analytics?</strong></footer></blockquote>\n\n<p>不負責任翻譯：<br>The User engagement 計量表示當你的應用程式或網站呈現在使用者畫面前景上並且被使用者聚焦，<br>與網站締結了互動行為，若應用程式或網站尚未載入完成或呈現出來，GA 不會蒐集該項指標。<br>這個計量可以幫助你了解目前應用程式或網站花了多少時間獲得使用者的聚焦，以及即時有多少活躍的使用者。</p>\n<h5 id=\"互動活躍時間（engagement-time-msec）\"><a href=\"#互動活躍時間（engagement-time-msec）\" class=\"headerlink\" title=\"互動活躍時間（engagement_time_msec）\"></a>互動活躍時間（engagement_time_msec）</h5><p>計算使用者在與網站或應用程式締結互動之後開始計算，在網站上活躍的時間毫秒（msec）。</p>\n<h3 id=\"campaign（活動分類）\"><a href=\"#campaign（活動分類）\" class=\"headerlink\" title=\"campaign（活動分類）\"></a>campaign（活動分類）</h3><p>可以在 GA 預設的 <strong>Click 事件</strong>裡查閱的參數，若是透過外部廣告（例如 Google Ads）等方式進入你的網站或應用程式，<br>campaign　參數就會被記錄，通常會顯示（referral）或（organic），有三大分類，<br>有時會帶括號有時不會（不知為啥知道的人請解惑一下XD）。</p>\n<h5 id=\"organic\"><a href=\"#organic\" class=\"headerlink\" title=\"(organic)\"></a>(organic)</h5><p>透過搜尋而來的自然流量（主動）。</p>\n<h5 id=\"referral\"><a href=\"#referral\" class=\"headerlink\" title=\"(referral)\"></a>(referral)</h5><p>透過外部媒體網站進來（被動）瀏覽的使用者，也就是行銷常講的外連（外部連結）。</p>\n<h5 id=\"none\"><a href=\"#none\" class=\"headerlink\" title=\"(none)\"></a>(none)</h5><p>直接進入網站的使用者，例如在 url 輸入網址。</p>\n<h3 id=\"medium（媒介分類）\"><a href=\"#medium（媒介分類）\" class=\"headerlink\" title=\"medium（媒介分類）\"></a>medium（媒介分類）</h3><p>使用者透過甚麼媒介方式進來你的網站，類別同上：</p>\n<h3 id=\"source（媒介-origin）\"><a href=\"#source（媒介-origin）\" class=\"headerlink\" title=\"source（媒介 origin）\"></a>source（媒介 origin）</h3><p>透過外部廣告進來的 url，例如透過 Google 搜尋進來的就會顯示 <code>https://www.google.com/</code>；<br>透過外部網站進來的就會顯示外部網站的 Origin URL。</p>\n<img src=\"/images/google-analytics-knowhow/5.png\" class=\"\" width=\"500\" height=\"200\" title=\"google-analytics-knowhow\">\n\n<h3 id=\"事件參數\"><a href=\"#事件參數\" class=\"headerlink\" title=\"事件參數\"></a>事件參數</h3><p>每個事件都有詳細參數可以閱覽，有機個是預設的（照順序），實際查看發現與官方文件的說明項目有出入。</p>\n<h1 id=\"GA-如何計算一個互動的單位\"><a href=\"#GA-如何計算一個互動的單位\" class=\"headerlink\" title=\"GA 如何計算一個互動的單位\"></a>GA 如何計算一個互動的單位</h1><h3 id=\"工作階段（Session-Start）\"><a href=\"#工作階段（Session-Start）\" class=\"headerlink\" title=\"工作階段（Session Start）\"></a>工作階段（Session Start）</h3><p>GA 的工作階段以 30 分鐘為一個單位，若這段期間使用者並未對網站進行任何互動（例如起來去廁所），<br>當前的工作階段就會結束。每個單位的工作流程可以包含多個互動事件（Event）或是從事商業行為，例如社交互動（Social Interaction）、電子商戶交易行為（Transaction），直到一個單位的工作階段結束（離開網站或是閒置超過 30 分鐘）。</p>\n<h5 id=\"工作階段強制切割\"><a href=\"#工作階段強制切割\" class=\"headerlink\" title=\"工作階段強制切割\"></a>工作階段強制切割</h5><ul>\n<li>只要時間來到<strong>隔日凌晨 00:00:00 時分</strong>，無論當前的工作階段是否有持續進行互動，都會被強制切割成另一個新的工作階段。</li>\n<li>當使用者更換了網站的來源媒介（medium 例如從廣告點進來、重新搜尋網站進入），都會被強制切割成另一個新的工作階段，無論使用者是否有停止當前的工作階段。</li>\n</ul>\n<h3 id=\"到達頁面（UA-通用版稱呼）\"><a href=\"#到達頁面（UA-通用版稱呼）\" class=\"headerlink\" title=\"到達頁面（UA 通用版稱呼）\"></a>到達頁面（UA 通用版稱呼）</h3><p>每一個工作階段開始的第一個頁面。</p>\n<h3 id=\"離開率\"><a href=\"#離開率\" class=\"headerlink\" title=\"離開率\"></a>離開率</h3><p>一個工作階段中「最後一個」瀏覽的網頁，在所有網頁瀏覽量的占比。</p>\n<p>參考資料：<br><a href=\"https://awoo.ai/zh-hant/blog/google-analytics-session/\">正確理解Google Analytics「工作階段」定義、計算、重要性</a></p>\n</body></html>",
            "tags": [
                "Google Analytics",
                "GA",
                "GA4",
                "Google Tag Manager",
                "GTM"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/28/restful-api-python/",
            "url": "http://maomaoxie.github.io/2022/08/28/restful-api-python/",
            "title": "restful-api-python",
            "date_published": "2022-08-28T07:29:29.000Z",
            "content_html": "<html><head></head><body><h1 id=\"安裝-python\"><a href=\"#安裝-python\" class=\"headerlink\" title=\"安裝 python\"></a>安裝 python</h1><p><a href=\"https://www.python.org/downloads/\">python 官方網站下載點</a><br>選擇 downloads 並且記得勾選 Add Python to PATH，就可以在終端機輸入<code>python3</code>，並且使用囉！</p>\n<h1 id=\"public-APIs\"><a href=\"#public-APIs\" class=\"headerlink\" title=\"public APIs\"></a>public APIs</h1><p>顧名思義就是開放 API（Open API），</p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/20/zh-tw/gcp-project-switch/",
            "url": "http://maomaoxie.github.io/2022/08/20/zh-tw/gcp-project-switch/",
            "title": "gcp-project-switch",
            "date_published": "2022-08-20T10:52:22.000Z",
            "content_html": "<html><head></head><body><p>在 GCP 上部屬不同專案時需要切換專案，根據專案 ID 來切換：</p>\n<h1 id=\"查看專案-ID\"><a href=\"#查看專案-ID\" class=\"headerlink\" title=\"查看專案 ID\"></a>查看專案 ID</h1><figure class=\"highlight plaintext hljs\"><figcaption><span>GCP</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcloud projects list</span><br><span class=\"line\"></span><br><span class=\"line\">PROJECT_ID: XXX</span><br><span class=\"line\">NAME: baby-bill</span><br><span class=\"line\">PROJECT_NUMBER: XXXXX</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"切換專案\"><a href=\"#切換專案\" class=\"headerlink\" title=\"切換專案\"></a>切換專案</h1><figure class=\"highlight plaintext hljs\"><figcaption><span>GCP</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcloud config set project `PROJECT ID`</span><br></pre></td></tr></tbody></table></figure></body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/20/typescript-why-use-it/",
            "url": "http://maomaoxie.github.io/2022/08/20/typescript-why-use-it/",
            "title": "typescript-why-use-it",
            "date_published": "2022-08-20T06:42:17.000Z",
            "content_html": "<html><head></head><body><h1 id=\"Typescript-is-a-superset-of-Javascript\"><a href=\"#Typescript-is-a-superset-of-Javascript\" class=\"headerlink\" title=\"Typescript is a superset of Javascript\"></a>Typescript is a superset of Javascript</h1><p>Typescript 提升的重點就是：優化了你的原生 Javascript 型別提示。<br>Typescript 是根基在 Javascript 語言之上的一個超集，他提供更強大的特點並且優化了 Javascript 的缺陷，使其運作與開發上有更大程度的提升，但 Typescript 不能在瀏覽器引擎上運作。<br>Typescript 是 Javascript 的升級版本，最終仍會編譯成 Javascript 提供瀏覽器運作，只是相當程度上增添了許多特性與優點，例如：</p>\n<h4 id=\"在開發早期發現錯誤提示，能早點修復。\"><a href=\"#在開發早期發現錯誤提示，能早點修復。\" class=\"headerlink\" title=\"在開發早期發現錯誤提示，能早點修復。\"></a>在開發早期發現錯誤提示，能早點修復。</h4><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">addNumbers</span> (num1, num2) {</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> num1 + num2;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(addNumbers (<span class=\"hljs-string\">'1'</span>, <span class=\"hljs-string\">'2'</span>))</span><br></pre></td></tr></tbody></table></figure>\n\n<p>以上的代碼期望的結果是 <code>1+2 = 3</code>，但是 JavaScript 本身的隱性型別轉換造成截然不同的結果，得到了 <code>23</code>。</p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/20/seo-know-how/",
            "url": "http://maomaoxie.github.io/2022/08/20/seo-know-how/",
            "title": "seo-know-how",
            "date_published": "2022-08-20T02:26:25.000Z",
            "content_html": "<html><head></head><body><p>SEO 分為網站結構 &amp; 內容<br>網站競品 新聞類型 SEO 結構不能輸別人</p>\n<p>搜尋引擎</p>\n<h1 id=\"網站連結\"><a href=\"#網站連結\" class=\"headerlink\" title=\"網站連結\"></a>網站連結</h1><h3 id=\"任何頁面必須可以內連\"><a href=\"#任何頁面必須可以內連\" class=\"headerlink\" title=\"任何頁面必須可以內連\"></a>任何頁面必須可以內連</h3><p>孤兒頁面對收錄到 SEO 非常扣分</p>\n<h4 id=\"蜘蛛網結構\"><a href=\"#蜘蛛網結構\" class=\"headerlink\" title=\"蜘蛛網結構\"></a>蜘蛛網結構</h4><p>網站內部蜘蛛網結構的互連非常重要，越多就越能被 Google 搜尋到，會比提交來的重要</p>\n<h3 id=\"權重高的網站外連\"><a href=\"#權重高的網站外連\" class=\"headerlink\" title=\"權重高的網站外連\"></a>權重高的網站外連</h3><p>由權重高的網站，例如新聞網站有連結過來就能大大提高收錄機會</p>\n<h1 id=\"網站結構\"><a href=\"#網站結構\" class=\"headerlink\" title=\"網站結構\"></a>網站結構</h1><h3 id=\"sitemap\"><a href=\"#sitemap\" class=\"headerlink\" title=\"sitemap\"></a>sitemap</h3><p>加入檢索隊列(Crawl Queue)的行為可以透過提交網站結構的 sitemap 至 google search console，而且不能造假也沒有無效的網頁連結（ex. 404、500 等）<br>sitemap是有上限的</p>\n<h3 id=\"robots-txt\"><a href=\"#robots-txt\" class=\"headerlink\" title=\"robots.txt\"></a>robots.txt</h3><p>開發階段不想曝光的網頁可以設定 robots.txt 不被收錄，但並非百分百有效<br>最好是設定密碼登入去擋內容，或是不要上線</p>\n<h1 id=\"domain-knowledge\"><a href=\"#domain-knowledge\" class=\"headerlink\" title=\"domain knowledge\"></a>domain knowledge</h1><p>領域專長<br>產業的核心知識 了解TA需求</p>\n<h1 id=\"breadcrumb\"><a href=\"#breadcrumb\" class=\"headerlink\" title=\"breadcrumb\"></a>breadcrumb</h1><p>網站麵包屑</p>\n<h1 id=\"you-may-like\"><a href=\"#you-may-like\" class=\"headerlink\" title=\"you may like\"></a>you may like</h1><p>你可能會喜歡的相關文章</p>\n<p>文章序號丟API 運算連結之間的關係(AI 資料工程師)</p>\n<h1 id=\"js-做的連結不會收錄\"><a href=\"#js-做的連結不會收錄\" class=\"headerlink\" title=\"js 做的連結不會收錄\"></a>js 做的連結不會收錄</h1><p>可以追蹤：</p>\n<figure class=\"highlight plaintext hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=\"https://example.com\"&gt;</span><br><span class=\"line\">&lt;a href=\"/relative/path/file\"&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>無法追蹤：</p>\n<figure class=\"highlight plaintext hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a routerLink=\"some/path\"&gt;</span><br><span class=\"line\">&lt;span href=\"https://example.com\"&gt;</span><br><span class=\"line\">&lt;a onclick=\"goto('https://example.com')\"&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n\n<h1 id=\"網站更新頻率要勤\"><a href=\"#網站更新頻率要勤\" class=\"headerlink\" title=\"網站更新頻率要勤\"></a>網站更新頻率要勤</h1><p>經常更新的網站才會被 google 將排名提前</p>\n<h1 id=\"UI-amp-UX-要好\"><a href=\"#UI-amp-UX-要好\" class=\"headerlink\" title=\"UI &amp; UX 要好\"></a>UI &amp; UX 要好</h1><p>網站體驗好 SEO 就會好，SEO 好廣告投入就可以降低</p>\n<h1 id=\"更新時間\"><a href=\"#更新時間\" class=\"headerlink\" title=\"更新時間\"></a>更新時間</h1><p>網站的 sitemap 會註明網站更新時間，對 google 的 SEO 排名也有影響</p>\n<h1 id=\"網站的-canonical-標準網址\"><a href=\"#網站的-canonical-標準網址\" class=\"headerlink\" title=\"網站的 canonical 標準網址\"></a>網站的 canonical 標準網址</h1><p>主網址會被 google 拿來計算收錄的頁面數量</p>\n<figure class=\"highlight plaintext hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=\"canonical\" href=\"\" &gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"網頁未加入索引\"><a href=\"#網頁未加入索引\" class=\"headerlink\" title=\"網頁未加入索引\"></a>網頁未加入索引</h3><p>不同網址但內容一樣會扣分，記得設定 canonical</p>\n<h1 id=\"基本要設定的\"><a href=\"#基本要設定的\" class=\"headerlink\" title=\"基本要設定的\"></a>基本要設定的</h1><title>網頁標題</title>\n<meta name=\"description\" content=\"\">\n// 設定網站縮圖\n<link rel=\"image_src\" href=\"\">\n\n<p>可以設定的</p>\n<figure class=\"highlight plaintext hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta content=\"\" name=\"copyright\"&gt;</span><br><span class=\"line\">&lt;meta content=\"\" name=\"author\"&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>要小心的</p>\n<figure class=\"highlight plaintext hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=\"keywords\" content=\"關鍵字1, 關鍵字2\" /&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"社群媒體\"><a href=\"#社群媒體\" class=\"headerlink\" title=\"社群媒體\"></a>社群媒體</h1><p>可以透過<a href=\"https://metatags.io/\">metatags</a>協助產生網站的縮圖</p>\n<h1 id=\"移除外部連結的權重\"><a href=\"#移除外部連結的權重\" class=\"headerlink\" title=\"移除外部連結的權重\"></a>移除外部連結的權重</h1><p>其目的在於告訴搜尋引擎不要索引抓取這個連結，同時也不要給予他權重。<br>Nofollow 反向連結是只將 <code>&lt;a href=\"https://example.com.tw\"&gt;Example&lt;/a&gt;</code> 加入 <code>rel=\"nofollow\"</code> 標籤<br><a href=\"https://example.com.tw\" ref=\"nofollow\">Example</a>。</p>\n<h1 id=\"使用者體驗\"><a href=\"#使用者體驗\" class=\"headerlink\" title=\"使用者體驗\"></a>使用者體驗</h1><p>內容要與主題相符</p>\n<h1 id=\"https\"><a href=\"#https\" class=\"headerlink\" title=\"https\"></a>https</h1><p>cloudflare 有提供免費的 https </p>\n<h1 id=\"AWD-AMP-PWA\"><a href=\"#AWD-AMP-PWA\" class=\"headerlink\" title=\"AWD AMP PWA\"></a>AWD AMP PWA</h1><p>提升行動裝置的網站架構亦可以提升網站體驗與速度</p>\n<h1 id=\"網站核心體驗三大指標\"><a href=\"#網站核心體驗三大指標\" class=\"headerlink\" title=\"網站核心體驗三大指標\"></a>網站核心體驗三大指標</h1><h3 id=\"LCP\"><a href=\"#LCP\" class=\"headerlink\" title=\"LCP\"></a>LCP</h3><p>最大內容繪製，2.5 秒可以渲染完畢</p>\n<h3 id=\"FID\"><a href=\"#FID\" class=\"headerlink\" title=\"FID\"></a>FID</h3><p>首次輸入的延遲時間，頁面互動的反應時間</p>\n<h3 id=\"CLS\"><a href=\"#CLS\" class=\"headerlink\" title=\"CLS\"></a>CLS</h3><p>累積版面配置轉移，還未讀取到的資料先將空間撐開（lazyload），避免使用者捲到的位置空間還未撐開，例如以下：</p>\n<figure class=\"highlight plaintext hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img width=\"200\" height=\"300\" /&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"SEO-v-s-廣告\"><a href=\"#SEO-v-s-廣告\" class=\"headerlink\" title=\"SEO v.s 廣告\"></a>SEO v.s 廣告</h1><p>在網站內放置廣告版位會對 SEO 扣分，但收入又需要靠廣告，是一種互相牴觸的生態</p>\n<h1 id=\"title\"><a href=\"#title\" class=\"headerlink\" title=\"title\"></a>title</h1><p>網頁的 title 都要放置網站名稱，例如：<br>網頁的內容概要、網站名稱</p>\n<h1 id=\"熱門關鍵字\"><a href=\"#熱門關鍵字\" class=\"headerlink\" title=\"熱門關鍵字\"></a>熱門關鍵字</h1><p>倘若 SEO 好熱門關鍵字也可以提升排名</p>\n<h1 id=\"SVG-圖片格式\"><a href=\"#SVG-圖片格式\" class=\"headerlink\" title=\"SVG 圖片格式\"></a>SVG 圖片格式</h1><p>img 有 alt 可以幫助搜尋引擎了解圖片內容，SVG 則可以加上 title 以及 describe 等同於 img 的 alt，結構如下：</p>\n<figure class=\"highlight plaintext hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;svg height=\"100\" width=\"100\" aria-labelledby=\"svgTitle svgDesc\" role=\"img\"&gt;</span><br><span class=\"line\">  &lt;title id=\"svgTitle\"&gt;Circle&lt;/title&gt;</span><br><span class=\"line\">  &lt;desc id=\"svgDesc\"&gt;This is a red circle&lt;/desc&gt;</span><br><span class=\"line\">  &lt;circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"3\" fill=\"red\" /&gt;</span><br><span class=\"line\">&lt;/svg&gt; </span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"SERP-結構化資料\"><a href=\"#SERP-結構化資料\" class=\"headerlink\" title=\"SERP 結構化資料\"></a>SERP 結構化資料</h1><p><a href=\"https://developers.google.com/search/docs/advanced/structured-data/intro-structured-data?hl=zh-tw\">參考資料</a></p>\n<h3 id=\"JSON-LD\"><a href=\"#JSON-LD\" class=\"headerlink\" title=\"JSON-LD\"></a>JSON-LD</h3><p>結構化資料的格式，例如 Google 提供的範例：</p>\n<figure class=\"highlight plaintext hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;Apple Pie by Grandma&lt;/title&gt;</span><br><span class=\"line\">    &lt;script type=\"application/ld+json\"&gt;</span><br><span class=\"line\">    {</span><br><span class=\"line\">      \"@context\": \"https://schema.org/\",</span><br><span class=\"line\">      \"@type\": \"Recipe\",</span><br><span class=\"line\">      \"name\": \"Apple Pie by Grandma\",</span><br><span class=\"line\">      \"author\": \"Elaine Smith\",</span><br><span class=\"line\">      \"image\": \"http://images.edge-generalmills.com/56459281-6fe6-4d9d-984f-385c9488d824.jpg\",</span><br><span class=\"line\">      \"description\": \"A classic apple pie.\",</span><br><span class=\"line\">      \"aggregateRating\": {</span><br><span class=\"line\">        \"@type\": \"AggregateRating\",</span><br><span class=\"line\">        \"ratingValue\": \"4.8\",</span><br><span class=\"line\">        \"reviewCount\": \"7462\",</span><br><span class=\"line\">        \"bestRating\": \"5\",</span><br><span class=\"line\">        \"worstRating\": \"1\"</span><br><span class=\"line\">      },</span><br><span class=\"line\">      \"prepTime\": \"PT30M\",</span><br><span class=\"line\">      \"totalTime\": \"PT1H30M\",</span><br><span class=\"line\">      \"recipeYield\": \"8\",</span><br><span class=\"line\">      \"nutrition\": {</span><br><span class=\"line\">        \"@type\": \"NutritionInformation\",</span><br><span class=\"line\">        \"calories\": \"512 calories\"</span><br><span class=\"line\">      },</span><br><span class=\"line\">      \"recipeIngredient\": [</span><br><span class=\"line\">        \"1 box refrigerated pie crusts, softened as directed on box\",</span><br><span class=\"line\">        \"6 cups thinly sliced, peeled apples (6 medium)\"</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    }</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>顯示的內容：</p>\n<img src=\"/images/seo-know-how/3.png\" class=\"\" width=\"800\" height=\"200\" title=\"seo-know-how\">\n\n<p>驗證是否有誤：<br><a href=\"https://search.google.com/test/rich-results\">驗證連結</a></p>\n<blockquote><p>參考網站：<br><a href=\"https://tools.wingzero.tw/article/sn/1187\">紅色死神 DETOOLS</a></p>\n</blockquote></body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/09/zh-tw/http-methods-idempotent/",
            "url": "http://maomaoxie.github.io/2022/08/09/zh-tw/http-methods-idempotent/",
            "title": "RESTful API 方法觀念介紹 - idempotent",
            "date_published": "2022-08-09T07:14:24.000Z",
            "content_html": "<html><head></head><body><p>RESTful API 呼叫的方法中，離不開四個主軸 CRUD，CREATE、READ/RETREIVE、UPDATE 還有 DELETE。<br>而其中就有分是否為 <strong>Idempotent 的方法</strong>，甚麼意思呢？</p>\n<h1 id=\"甚麼是Idempotent（冪等）\"><a href=\"#甚麼是Idempotent（冪等）\" class=\"headerlink\" title=\"甚麼是Idempotent（冪等）\"></a>甚麼是Idempotent（冪等）</h1><blockquote><p>A request method is considered “idempotent” if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request. </p>\n</blockquote>\n\n<p>看為只覺得在母鯊大，沒關係我們繼續看下去：</p>\n<blockquote><p>Of the request methods defined by this specification, PUT, DELETE, and safe request methods are idempotent.</p>\n<footer><strong>Lauviah0622</strong><cite><a href=\"https://lance.coderbridge.io/2021/06/06/what-is-safe-method-and-indempotent-methods/\">[極短篇] HTTP 的 Safe method 還有 Idempotent method</a></cite></footer></blockquote>\n\n<p>dempotent（冪等）的方法不管你做一次、兩次乃至一百次，對於伺服器端資料的結果都一樣，是安全而沒有副作用的，可以安心服用；<br>相反的非 Idempotent 的方法則是需要謹慎考慮的、會改動伺服器資料庫的、有副作用的，也就是非安全請求。</p>\n<p>我們來看看更精簡好懂的解釋：</p>\n<blockquote><p>Idempotent operations produce the same result even when the operation is repeated many times. The result of the 2nd, 3rd, and 1,000th repeat of the operation will return exactly the same result as the 1st time.<br>冪等運算是指無論操作多少次結果都會與第一次相同。</p>\n<p>For example, simple mathematical examples of idempotency include:</p>\n<p>x + 0;<br>x = 5;</p>\n<p>In the first example, adding zero will never change the result, regardless of how many times you do it. In the second, x is always 5. Again, this is the case, regardless of how many times you perform the operation. Both of these examples describe an operation that is idempotent.</p>\n<p>以上兩個例子都說明了這兩個表達是無論執行幾次都會是相同結果，這就是 Idempotent（冪等）。</p>\n<footer><strong>James E.</strong><cite><a href=\"https://blog.dreamfactory.com/what-is-idempotency/\">what-is-idempotency</a></cite></footer></blockquote>\n\n<h1 id=\"冪等不等於安全請求\"><a href=\"#冪等不等於安全請求\" class=\"headerlink\" title=\"冪等不等於安全請求\"></a>冪等不等於安全請求</h1><blockquote><p>The concepts of ‘idempotent methods’ and ‘safe methods’ are often confused. A safe method does not change the value that is returned, it reads – but it never writes.<br>Therefore, all safe methods are idempotent, but not all idempotent methods are safe.</p>\n<p>HTTP methods include:<br>POST – Creates a new resource. POST is not idempotent and it is not safe.<br>GET – Retrieves a resource. GET is idempotent and it is safe.<br>HEAD – Retrieves a resource (without response body). HEAD is idempotent and it is safe<br>PUT – Updates/replaces a resource. PUT is idempotent but it is not safe<br>PATCH – Partially updates a resource. PATCH is not idempotent and it is not safe.<br>DELETE – Deletes a resource. DELETE is idempotent but it is not safe.<br>TRACE – Performs a loop-back test. TRACE is idempotent but it is not safe.</p>\n<footer><strong>James E.</strong><cite><a href=\"https://blog.dreamfactory.com/what-is-idempotency/\">what-is-idempotency</a></cite></footer></blockquote>\n\n<p>安全請求只會讀取，所以都是冪等的，但冪等方法不一定都是安全請求。</p>\n<p>學術的部份我們就此打住，了解一下冪等之於 RESTful API 的意義。</p>\n<h1 id=\"idempotent-methods-冪等的方法\"><a href=\"#idempotent-methods-冪等的方法\" class=\"headerlink\" title=\"idempotent methods 冪等的方法\"></a>idempotent methods 冪等的方法</h1><ol>\n<li>GET</li>\n<li>HEAD（只讀取資料頭而忽略身體）</li>\n<li>PUT</li>\n<li>DELETE</li>\n<li>OPTIONS</li>\n</ol>\n<p>以上方式無論發幾次 request，結果都等同於一次。</p>\n<blockquote><p>通常 DELETE 會帶上 id，所以刪除 1 次和刪除 100 次是一樣的，server 那邊找不到 id 操作就會被忽略。<br>而 PUT 也一樣，PUT 代表替代的 http 操作，你發了 1 次 request 已經取代了內容後，那即使再發 100 次也只是替代一樣的內容。</p>\n<footer><strong>Lauviah0622</strong><cite><a href=\"https://lance.coderbridge.io/2021/06/06/what-is-safe-method-and-indempotent-methods/\">[極短篇] HTTP 的 Safe method 還有 Idempotent method</a></cite></footer></blockquote>\n\n<h1 id=\"Not-idempotent-methods-非冪等的方法\"><a href=\"#Not-idempotent-methods-非冪等的方法\" class=\"headerlink\" title=\"Not idempotent methods 非冪等的方法\"></a>Not idempotent methods 非冪等的方法</h1><ol>\n<li>POST</li>\n<li>DISPATCH</li>\n</ol>\n<p>以上方法每執行一次就會造成資料變動，但並非每種使用方式都是非冪等，端看 request 的目的是在「修改」還是「增加」，修改可能並不會更改內存量（memory），但是增加就不同了，它也是修改但是擴大了內存量（變多了）：</p>\n<blockquote><p>PATCH 在語意上代表著修改資料，換句話說可能這樣：</p>\n<p><code>PATCH http://blog.com/post?id=1 body {     title: 'new title' } </code><br>發了 100 次和 1 次標題都是同樣的 new title。</p>\n<p><code>PATCH http:shop.com/item/add?id=1 body {     number: 10 }</code><br>requst 代表的是增加 10 個 item 的數量。這種情況下也符合語意（修改資料），但就不符合 Idempotent 了，100 次會新增 1000 個。那 POST 就不用提，一次和 100 次肯定是不一樣的。</p>\n<footer><strong>Lauviah0622</strong><cite><a href=\"https://lance.coderbridge.io/2021/06/06/what-is-safe-method-and-indempotent-methods/\">[極短篇] HTTP 的 Safe method 還有 Idempotent method</a></cite></footer></blockquote>\n\n<h1 id=\"結語\"><a href=\"#結語\" class=\"headerlink\" title=\"結語\"></a>結語</h1><p>讓我最意外的是 DELETE 居然是冪等方法，原因在於無論 request 幾次都只刪同一筆資料（認 id）這個觀念，與以前認為 DELETE 應該會每次刪除不同資料的想法大相逕庭。</p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/09/zh-tw/vuetify-slot-vhtml/",
            "url": "http://maomaoxie.github.io/2022/08/09/zh-tw/vuetify-slot-vhtml/",
            "title": "如何在 vuetify 元件中渲染 v-html",
            "date_published": "2022-08-09T04:09:43.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/vuetify-slot-vhtml/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"vuetify-slot-vhtml\">\n<p>使用 vuetify 元件時常有的狀況劇就是 - 標題的 UI 設計需要客製化，例如放上 fontawesome 的 icon，但你的元件是 vuetify 父元件（v-select），客製的對象是迴圈後的子元件（選單下的選項 v-selection），這時候要如何成功渲染 fontawesome 的 icon ?</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>vuetify</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;v-select</span><br><span class=\"line\">    :items=<span class=\"hljs-string\">\"items\"</span></span><br><span class=\"line\">    label=<span class=\"hljs-string\">\"Standard\"</span></span><br><span class=\"line\">&gt;&lt;/v-select&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"使用-lt-i-gt-lt-i-gt-標籤\"><a href=\"#使用-lt-i-gt-lt-i-gt-標籤\" class=\"headerlink\" title=\"使用 <i></i> 標籤\"></a>使用 <code>&lt;i&gt;&lt;/i&gt;</code> 標籤</h1><p>目前可以知道的小撇步就是 fontawesome 的 icon 要使用 vue v-html 渲染，必須使用 <code>&lt;i&gt;&lt;/i&gt;</code> 標籤才能成功，不能放入 vuetify  <code>&lt;v-icon&gt;&lt;/v-icon&gt;</code>，無法正確編譯成 html。</p>\n<h1 id=\"在父元件內使用-v-slot\"><a href=\"#在父元件內使用-v-slot\" class=\"headerlink\" title=\"在父元件內使用 v-slot\"></a>在父元件內使用 v-slot</h1><p>可以知道目前的元件結構會是這樣的：<br>v-select（父）<br>        ｜<br>    v-selection（子）</p>\n<p>選項是這樣：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    { <span class=\"hljs-attr\">value</span>:<span class=\"hljs-string\">\"0\"</span>,<span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">\"&lt;i class=\"</span>fab fa-apple<span class=\"hljs-string\">\"&gt;&lt;/i&gt; apple\"</span> },</span><br><span class=\"line\">    { <span class=\"hljs-attr\">value</span>:<span class=\"hljs-string\">\"1\"</span>,<span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">\"&lt;i class=\"</span>fab fa-google-drive<span class=\"hljs-string\">\"&gt;&lt;/i&gt; google\"</span> },</span><br><span class=\"line\">]</span><br></pre></td></tr></tbody></table></figure>\n\n<p>vuetify 父元件（v-select）透過 props items 選項的陣列可以使用 v-slot 轉換成 html 模板傳入：</p>\n<blockquote><p>Override the item and selection slots, and use v-html.<br>參考網址：<a href=\"https://stackoverflow.com/questions/56665185/show-raw-html-in-vuetify-v-select\">https://stackoverflow.com/questions/56665185/show-raw-html-in-vuetify-v-select</a></p>\n</blockquote>\n\n<h3 id=\"vue-2-版本\"><a href=\"#vue-2-版本\" class=\"headerlink\" title=\"vue 2 版本\"></a>vue 2 版本</h3><p>由於子元件會有 default 選項，要使用插槽針對 <strong>selection</strong> 修改；<br>而下拉選項要使用插槽針對 <strong>item</strong> 修改。</p>\n<h5 id=\"寫法-1\"><a href=\"#寫法-1\" class=\"headerlink\" title=\"寫法 1\"></a>寫法 1</h5><figure class=\"highlight javascript hljs\"><figcaption><span>slot 範例 1</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;v-select :items=<span class=\"hljs-string\">'item'</span>&gt;</span><br><span class=\"line\">    <span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:item</span>=<span class=\"hljs-string\">'{item}'</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">'item.text'</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></span></span><br><span class=\"line\">    <span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:selection</span>=<span class=\"hljs-string\">'{item}'</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">'item.text'</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></span></span><br><span class=\"line\">&lt;/v-select&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"寫法-2\"><a href=\"#寫法-2\" class=\"headerlink\" title=\"寫法 2\"></a>寫法 2</h5><figure class=\"highlight javascript hljs\"><figcaption><span>slot 範例 1</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;v-select :items=<span class=\"hljs-string\">'item'</span>&gt;</span><br><span class=\"line\">    <span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:item</span>=<span class=\"hljs-string\">'{item}'</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">'item.text'</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></span></span><br><span class=\"line\">    <span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:selection</span>=<span class=\"hljs-string\">'{item}'</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">'item.text'</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></span></span><br><span class=\"line\">&lt;/v-select&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n\n<h3 id=\"簡潔版本\"><a href=\"#簡潔版本\" class=\"headerlink\" title=\"簡潔版本\"></a>簡潔版本</h3><figure class=\"highlight javascript hljs\"><figcaption><span>slot 範例 2</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;v-select :items=<span class=\"hljs-string\">'item'</span>&gt;</span><br><span class=\"line\">    <span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">'item'</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">'{item}'</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">'item.text'</span>/&gt;</span></span></span><br><span class=\"line\">&lt;/v-select&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"vue-3-版本\"><a href=\"#vue-3-版本\" class=\"headerlink\" title=\"vue 3 版本\"></a>vue 3 版本</h3><figure class=\"highlight javascript hljs\"><figcaption><span>slot 範例 3</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template #item=<span class=\"hljs-string\">'{item}'</span>&gt;</span><br><span class=\"line\">    <span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">'item.text'</span> /&gt;</span></span></span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"vuetify-api-說明\"><a href=\"#vuetify-api-說明\" class=\"headerlink\" title=\"vuetify api 說明\"></a>vuetify api 說明</h1><p>在每個元件的 api 文件下方都有提供現成的插槽可以使用：</p>\n<img src=\"/images/vuetify-slot-vhtml/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"vuetify-slot-vhtml\"></body></html>",
            "tags": [
                "vue",
                "vuetify",
                "html"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/07/zh-tw/git-remove-submodule/",
            "url": "http://maomaoxie.github.io/2022/08/07/zh-tw/git-remove-submodule/",
            "title": "git 移除 submodule",
            "date_published": "2022-08-07T08:07:24.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/git-remove-submodule/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"git-remove-submodule\">\n<h1 id=\"git-submodule\"><a href=\"#git-submodule\" class=\"headerlink\" title=\"git submodule\"></a>git submodule</h1><p>在部屬 hexo 部落格到雲端 github 時，發現主題下的 minos git status 呈現 untracked 的狀態，搜尋後才知道該主題是 clone 遠端下來的，自動會變成一個子模塊（submodule），對於習慣專案開發的我來說在客製化後不能同步實在很不方便，還是喜歡一整包放在同一個 repository 方便管理。</p>\n<img src=\"/images/git-remove-submodule/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"git-remove-submodule\">\n\n<p>以下記錄自己如何將修改後的 minos 資料夾：</p>\n<h3 id=\"移除-git-子模塊快取\"><a href=\"#移除-git-子模塊快取\" class=\"headerlink\" title=\"移除 git 子模塊快取\"></a>移除 git 子模塊快取</h3><p>以下的指令可以清除子模塊的 git 紀錄：</p>\n<figure class=\"highlight plaintext hljs\"><figcaption><span>git cmd</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm --cached -f ./themes/minos</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"重新加入索引\"><a href=\"#重新加入索引\" class=\"headerlink\" title=\"重新加入索引\"></a>重新加入索引</h3><p>將剛才取消子模塊的 git 重新排隊至專案包中，我比較懶惰直接整包加：</p>\n<figure class=\"highlight plaintext hljs\"><figcaption><span>git cmd</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></tbody></table></figure>\n\n<p>再檢視一遍 vs code 之後就會看到檔案被追蹤到了！</p>\n</body></html>",
            "tags": [
                "git",
                "hexo",
                "submodule"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/07/zh-tw/wordpress-get-started/",
            "url": "http://maomaoxie.github.io/2022/08/07/zh-tw/wordpress-get-started/",
            "title": "開始我的第一個 wordpress 網站",
            "date_published": "2022-08-07T02:02:29.000Z",
            "content_html": "<html><head></head><body><h1 id=\"第一步-產生-ip-位址\"><a href=\"#第一步-產生-ip-位址\" class=\"headerlink\" title=\"第一步 - 產生 ip 位址\"></a>第一步 - 產生 ip 位址</h1><p>首先要租賃一台伺服器提供 ip，可以考慮較優惠的主機廠商：遠振或 bluehost。<br>要注意的是，一個 domain 可以放置很多網站資料夾，並且設定sub-domian。</p>\n<h1 id=\"第二步-DNS-註冊\"><a href=\"#第二步-DNS-註冊\" class=\"headerlink\" title=\"第二步 - DNS 註冊\"></a>第二步 - DNS 註冊</h1><p>ip 設定好之後就可以將網域指過來指定的 DNS 網域商：<br>中華電信提供的 .tw　較便宜，而 godaddy 則是 .com 較便宜。</p>\n<h1 id=\"第三步-cdn-分散流量\"><a href=\"#第三步-cdn-分散流量\" class=\"headerlink\" title=\"第三步 - cdn 分散流量\"></a>第三步 - cdn 分散流量</h1><p>常用的 cdn 廠商像是 cloudflare，可以註冊一個離主機近的（例如東京）cdn 位址，其他供應商例如 sugarhost 很便宜但連線較慢。</p>\n<h3 id=\"CDN-原理\"><a href=\"#CDN-原理\" class=\"headerlink\" title=\"CDN 原理\"></a>CDN 原理</h3><p>cdn 是把 DNS 轉向給 DNS 廠商（cloudflare），透過 DNS 指向將流量倒過去 cloudflare，在第一次 cache 過網站靜態資源後，第二次就可以直接提取cdn 伺服器上 cache　的資源以減少流量費用。</p>\n<h3 id=\"設定細節\"><a href=\"#設定細節\" class=\"headerlink\" title=\"設定細節\"></a>設定細節</h3><h5 id=\"資源類型\"><a href=\"#資源類型\" class=\"headerlink\" title=\"資源類型\"></a>資源類型</h5><p>通常都會設定 <strong>A 類型</strong>以設定網址（url）指向，例如 mailgun 的寄信功能。</p>\n<h5 id=\"防堵資安問題\"><a href=\"#防堵資安問題\" class=\"headerlink\" title=\"防堵資安問題\"></a>防堵資安問題</h5><p>cloudflare 設定其中一樣可以開啟 ddos -&gt; under Attack 來保護網站資源。<br>也可以手動清除特定檔案，例如圖片的 cache 來重新抓取檔案。</p>\n<h1 id=\"第四步-掛載-wordpress\"><a href=\"#第四步-掛載-wordpress\" class=\"headerlink\" title=\"第四步 - 掛載 wordpress\"></a>第四步 - 掛載 wordpress</h1><p>wordpress 可以當作是一個 php 建構而成的後端框架應用，串接方式有兩種：</p>\n<ol>\n<li>直接使用 wordpress hook 來渲染資料（前後端合併）。</li>\n<li>撰寫自己的前端框架（例如 vue），撰寫自己的 API（前後端分離）。</li>\n</ol>\n<h3 id=\"建立步驟\"><a href=\"#建立步驟\" class=\"headerlink\" title=\"建立步驟\"></a>建立步驟</h3><p>到  <a href=\"https://tw.wordpress.org/download/\">wordpress</a> 官方網站下載檔案，上傳到自己的網域 server。</p>\n<img src=\"/images/wordpress-get-started/14.png\" class=\"\" width=\"800\" height=\"200\" title=\"wordpress-download\">\n<p>上傳後打開網站，會有一個 UI 介面可以直接設定 wordpress 與網站資料，config 需要設定資料庫帳號密碼：</p>\n<p>要注意的是 wordpress 權限身分須從 root 改成 www-data，才能變成網站系統管理員使用 wordpress 後台。</p>\n<!-- 行情 $ 25000 (使用佈景主題)\n客製化算一頁\n定時備份以免網站被駭客\n租 GCP 靜態硬碟 \ngoogle 硬碟版本管理 資源回收桶保留30 天\nflicker\n\n設定 config 檔案 \n比較好的後台c panel 要錢\ndns 代管要 https 要使用 flexible SSL for cloudflare\n\n一類有分類的文章 slug 需要代稱(英文的)\n獨立頁面 客製化\nsiteliner 檢查有沒有壞掉的連結與重複的內容\nduplicate page\n報價高一點\n附加的css\n減少做重複的事情\n在 wordpress 上做前後端分離 -->\n</body></html>",
            "tags": [
                "wordpress",
                "dns",
                "cdn"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/05/zh-tw/hexo-rss/",
            "url": "http://maomaoxie.github.io/2022/08/05/zh-tw/hexo-rss/",
            "title": "Hexo RSS 自動產生器",
            "date_published": "2022-08-05T07:39:34.000Z",
            "content_html": "<html><head></head><body><p>RSS 訂閱功能越來越夯，可以即時通知訂閱戶更新的文章內容，增加回流的流量與網站的熱度，chrome 也有提供 RSS reader 的外掛功能直接讀取 RSS 檔案。<br>既然建立好了自己的部落格怎麼可以沒有 RSS XD?</p>\n<p>先前在專案包嘗試使用 hexo-generator-feed 套件，但是建立出來的 atom.xml 檔案會出現亂碼，後來找到一個套件甚至支援 json 與 rss 格式：</p>\n<h1 id=\"安裝-Hexo-seed-套件\"><a href=\"#安裝-Hexo-seed-套件\" class=\"headerlink\" title=\"安裝 Hexo seed 套件\"></a>安裝 Hexo seed 套件</h1><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-feed</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"檔案格式\"><a href=\"#檔案格式\" class=\"headerlink\" title=\"檔案格式\"></a>檔案格式</h3><p>hexo-feed 可以設定三種文件格式：atom、json 還有 rss，建立的模板可以透過專案包根目錄的 _config.yml 去設定模板的 path（template）：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>_config.yml</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-attr\">feed</span>:</span><br><span class=\"line\">    <span class=\"hljs-attr\">limit</span>: <span class=\"hljs-number\">20</span></span><br><span class=\"line\">    <span class=\"hljs-attr\">order_by</span>: <span class=\"hljs-string\">\"-date\"</span></span><br><span class=\"line\">    <span class=\"hljs-attr\">tag_dir</span>: <span class=\"hljs-string\">\"tag\"</span></span><br><span class=\"line\">    <span class=\"hljs-attr\">category_dir</span>: <span class=\"hljs-string\">\"category\"</span></span><br><span class=\"line\">    <span class=\"hljs-attr\">rss</span>:</span><br><span class=\"line\">        <span class=\"hljs-attr\">enable</span>: <span class=\"hljs-literal\">true</span></span><br><span class=\"line\">        <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">\"themes/layout/template/rss.ejs\"</span> </span><br><span class=\"line\">        <span class=\"hljs-attr\">output</span>: <span class=\"hljs-string\">\"rss.xml\"</span></span><br><span class=\"line\">    <span class=\"hljs-attr\">atom</span>:</span><br><span class=\"line\">        <span class=\"hljs-attr\">enable</span>: <span class=\"hljs-literal\">true</span></span><br><span class=\"line\">        <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">\"themes/layout/template/atom.ejs\"</span></span><br><span class=\"line\">        <span class=\"hljs-attr\">output</span>: <span class=\"hljs-string\">\"atom.xml\"</span></span><br><span class=\"line\">    <span class=\"hljs-attr\">jsonFeed</span>:</span><br><span class=\"line\">        <span class=\"hljs-attr\">enable</span>: <span class=\"hljs-literal\">true</span></span><br><span class=\"line\">        <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">\"themes/layout/template/json.ejs\"</span></span><br><span class=\"line\">        <span class=\"hljs-attr\">output</span>: <span class=\"hljs-string\">\"feed.json\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"模板內容\"><a href=\"#模板內容\" class=\"headerlink\" title=\"模板內容\"></a>模板內容</h3><figure class=\"highlight javascript hljs\"><figcaption><span>atom</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"hljs-string\">\"1.0\"</span>?&gt;</span><br><span class=\"line\"><span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">feed</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.w3.org/2005/Atom\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>&lt;%= config.url %&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>&lt;%= config.title %&gt;&lt;%= tag ? ` • Posts by \"${tag}\" tag` : '' %&gt;&lt;%= category ? ` • Posts by \"${category}\" category` : '' %&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"&lt;%= config.url %&gt;\"</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">updated</span>&gt;</span>&lt;%= moment(lastBuildDate).toISOString() %&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">updated</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    &lt;%_ for (const { name } of (tags || [])) { _%&gt;</span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">category</span> <span class=\"hljs-attr\">term</span>=<span class=\"hljs-string\">\"&lt;%= name %&gt;\"</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    &lt;%_ } _%&gt;</span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    &lt;%_ for (const post of posts) { _%&gt;</span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">entry</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>&lt;%= post.permalink %&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>&lt;%= post.title %&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">\"alternate\"</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"&lt;%= post.permalink %&gt;\"</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">content</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"html\"</span>&gt;</span>&lt;%= post.content %&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">content</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        &lt;%_ for (const { name } of (post.tags ? post.tags.toArray() : [])) { _%&gt;</span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">category</span> <span class=\"hljs-attr\">term</span>=<span class=\"hljs-string\">\"&lt;%= name %&gt;\"</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        &lt;%_ } _%&gt;</span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">updated</span>&gt;</span>&lt;%= moment(post.date).toISOString() %&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">updated</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">entry</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    &lt;%_ } _%&gt;</span></span><br><span class=\"line\"><span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">feed</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure></body></html>",
            "tags": [
                "hexo",
                "rss"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/02/zh-tw/hello-world/",
            "url": "http://maomaoxie.github.io/2022/08/02/zh-tw/hello-world/",
            "title": "感謝您的閱讀",
            "date_published": "2022-08-01T16:03:26.680Z",
            "content_html": "<html><head></head><body><p>這裡撰寫的都是一些自己在前端之路上每天一小步的學習，希望透過記錄與陳述來加強學習成效以及融會貫通的能力，文章內有任何問題歡迎一起討論呦!</p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/07/30/zh-tw/js-weird-parts-value/",
            "url": "http://maomaoxie.github.io/2022/07/30/zh-tw/js-weird-parts-value/",
            "title": "克服 Javascript 的奇怪部分 原始型別",
            "date_published": "2022-07-30T09:08:20.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-value/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-primitive-type\">\n<p>只要不是物件型別的值都可以看做是原始型別，例如：</p>\n<h1 id=\"undefined\"><a href=\"#undefined\" class=\"headerlink\" title=\"undefined\"></a>undefined</h1><p>當一個變數還未指派任何值之前，記憶體位置會被賦予一個 undefied 的值，通常是 Javascript 引擎指派的，應該避免將任何值的預設值設定為 undefined，避免與 Hoisting 行為混淆了。</p>\n<h1 id=\"null\"><a href=\"#null\" class=\"headerlink\" title=\"null\"></a>null</h1><p>若需要再資料回來之前給予判斷，可以將變數設定為 null 來表示該變數還未拿到任何值，也非 Javascript 引擎指派的值。</p>\n<h1 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h1><p>true 或 false 的判斷型別，值得注意的是當值存在 localstorage 或者 cookie 時應避免儲存 true 或 false，轉換過程會強制變成 string 而造成錯誤的判斷。</p>\n<h1 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\"number\"></a>number</h1><p>唯一的數字型別（numeric），不同於其他語言可能具有細緻的數字型別，例如 interger 或是 demicals，Javascript 只有一個 number type，為<strong>浮點運算（floating point number）</strong>，這種運算法為一個有效數字加上冪數來表示，電腦本身的二進制無法實現十進制的數字精確性，會造成數字計算上浮點位數的不正確，只能計算出近似值而已。</p>\n<h1 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h1><p>字串型別，一串使用雙引號或單引號標記起來的文字。</p>\n<h1 id=\"symbol\"><a href=\"#symbol\" class=\"headerlink\" title=\"symbol\"></a>symbol</h1><p>ES6 引入的新原始型別，用來表示一個獨一無二的值。產生的原因來自於物件的屬性通常都是字串（property），這樣容易造就重複的屬性而衝突，新的符號型別（symbol）於是誕生，兩個 symbol 永遠不會相等，是絕對的獨一無二。ES6 允許使用表達式 (expression) 作為屬性的名稱，語法是將 expression 放在中括號 [ ] 裡面：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>symbol</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> s = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> obj = {</span><br><span class=\"line\">    [s]: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {}</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure></body></html>",
            "tags": [
                "javascript",
                "type"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/07/30/zh-tw/js-weird-parts-types/",
            "url": "http://maomaoxie.github.io/2022/07/30/zh-tw/js-weird-parts-types/",
            "title": "克服 Javascript 的奇怪部分 型別",
            "date_published": "2022-07-30T08:35:45.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-dynamic-typing/0.png\" class=\"\" title=\"dynamic-typing\">\n<h1 id=\"Dynamic-Typing\"><a href=\"#Dynamic-Typing\" class=\"headerlink\" title=\"Dynamic Typing\"></a>Dynamic Typing</h1><p>Javascript 的型別為動態型別（Dynamic Typing），不同於 C# 等強型別語言的靜態型別（Static Typing），無須指派型別而是在引擎執行的階段（at runtime）辨認變數記憶體內的型別為何：</p>\n<blockquote class=\"colorquote info\"><p>Dynamically-typed languages are those (like JavaScript) where the interpreter assigns variables a type at runtime based on the variable’s value at the time.</p>\n</blockquote>\n\n<p>這有可能導致一個變數在每次程式執行的結果都產生不同的型別（例如 == 型別隱式轉換），而造成不如預期的結果，所以使用三等號是比較良好的撰寫習慣。</p>\n</body></html>",
            "tags": [
                "javascript",
                "type"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/07/24/zh-tw/js-weird-parts-asynchronous/",
            "url": "http://maomaoxie.github.io/2022/07/24/zh-tw/js-weird-parts-asynchronous/",
            "title": "克服 Javascript 的奇怪部分 如何執行非同步",
            "date_published": "2022-07-24T08:56:25.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-asynchronous/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"asynchronous\">\n\n<p>瀏覽器在運作的時候有三大功能要執行：render engine 畫面渲染 -&gt; JavaScript 引擎 -&gt; Http Request。</p>\n<blockquote class=\"colorquote info\"><p>A browser engine (also known as a layout engine or rendering engine) is a core software component of every major web browser. The primary job of a browser engine is to <strong>transform HTML documents and other resources of a web page into an interactive visual representation on a user’s device</strong>.</p>\n</blockquote>\n\n<p>雖然名詞解釋上為非同步，但在 JavaScript 運作上實際仍是 line by line，而且具有先後順序的，對瀏覽器而言以下三項機制才是同時運作（asynchronous）：</p>\n<img src=\"/images/js-weird-parts-asynchronous/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"asynchronous\">\n\n<h1 id=\"Http-request-amp-response\"><a href=\"#Http-request-amp-response\" class=\"headerlink\" title=\"Http request &amp; response\"></a>Http request &amp; response</h1><p>客戶端發送了頁面請求後，<strong>Http 機制</strong>開始運行收發請求與回應網路資源的文本協定，建立瀏覽器與伺服器的溝通橋樑，作為 TCP/IP 的應用層，並且將資料回應提供給 JavaScript 來處理。</p>\n<h1 id=\"Javascript\"><a href=\"#Javascript\" class=\"headerlink\" title=\"Javascript\"></a>Javascript</h1><p>一旦提及非同步就不可埋沒一大功臣，JavaScript 引擎中的<strong>事件佇列（Event Queue）</strong>。</p>\n<h4 id=\"事件佇列（Event-Queue）\"><a href=\"#事件佇列（Event-Queue）\" class=\"headerlink\" title=\"事件佇列（Event Queue）\"></a>事件佇列（Event Queue）</h4><p>當 Javascript 引擎執行完執行佇列（Execution Stack）的內容後，也就是執行佇列已經清空後，會定期（periodic）來檢視事件佇列（Event Queue）的事件排序並且執行，例如 Click 事件的回呼函式，或者是 API 收發資料的任務，才會被放置到執行佇列（Execution Stack）然後執行。在 Javascript 中的運作仍是同步的，並沒有非同步在執行程式。</p>\n<h4 id=\"微任務與宏任務\"><a href=\"#微任務與宏任務\" class=\"headerlink\" title=\"微任務與宏任務\"></a>微任務與宏任務</h4><p>部分的執行任務會被放置在事件佇列中，待執行佇列（Execution Stack）所有任務完成後才會開始執行，例如 SetTimeout（宏任務） 或是 promise（微任務） 等。</p>\n<h1 id=\"Render-engine\"><a href=\"#Render-engine\" class=\"headerlink\" title=\"Render engine\"></a>Render engine</h1><p>JavaScript 的必須仰賴瀏覽器的引擎，當瀏覽器讀取一個頁面時， JavaScript 具有觸發畫面渲染的鉤子促使<strong>渲染引擎（Render Engine）</strong>來改變畫面。</p>\n<blockquote class=\"colorquote danger\"><p>Asynchronous means that the rendering engine, the javascript engine and the HTTP requests are running asynchrounously inside the browser, what’s happening just inside the javascript is synchrounous.</p>\n</blockquote></body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/07/24/zh-tw/js-weird-parts-ES6/",
            "url": "http://maomaoxie.github.io/2022/07/24/zh-tw/js-weird-parts-ES6/",
            "title": "克服 Javascript 的奇怪部分 ES6",
            "date_published": "2022-07-24T08:30:58.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-let/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"ES6-let\">\n<h1 id=\"ES6-let\"><a href=\"#ES6-let\" class=\"headerlink\" title=\"ES6 let\"></a>ES6 let</h1><p>不同於 var 的宣告方式，let 宣告的變數在宣告時會出現暫時性死區不可取用，沒有 hoisting 現象，且變數的作用域只存在於 block 區塊中，例如 if 陳述句，而 var 則是函式作用域，若撰寫在 if 陳述句內外部仍可取用。<br>最經典的應用就是 for 迴圈，可以在每一次的 console 正確印出數值：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>for loop</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">5</span>; i++) {</span><br><span class=\"line\">  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">()=&gt;</span>{</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i)</span><br><span class=\"line\">  },<span class=\"hljs-number\">1000</span>)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/07/10/zh-tw/js-weird-parts-scope-chain/",
            "url": "http://maomaoxie.github.io/2022/07/10/zh-tw/js-weird-parts-scope-chain/",
            "title": "克服 Javascript 的奇怪部分 範圍鍊",
            "date_published": "2022-07-10T07:57:42.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-scope-chain/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"scope-chain\">\n\n<p>以下探討的幾個議題都離不開函式（function）本身：</p>\n<h1 id=\"環境變數\"><a href=\"#環境變數\" class=\"headerlink\" title=\"環境變數\"></a>環境變數</h1><p>每個執行環境（execution context）都有屬於其中的變數，可以把執行環境想作是一個<strong>空間範圍</strong>，而環境變數都附著在其中，例如全域變數（global variable）會附著在全域物件下，瀏覽器的全域執行環境則是屬於 window 物件，宣告在其中的變數都會隸屬於全域執行環境。</p>\n<h1 id=\"函式變數\"><a href=\"#函式變數\" class=\"headerlink\" title=\"函式變數\"></a>函式變數</h1><p>函式變數在函式被呼叫並觸發後創造了一個獨特的函式執行環境，該函式內有自己的變數，此變數式在函式內<strong>宣告（declaration）</strong>並且創造的，只能在該函式執行環境中可以取得，稱為區域變數（scoped variable），而變數可取用的範圍稱之作用域（scope）。</p>\n<h1 id=\"範圍鍊\"><a href=\"#範圍鍊\" class=\"headerlink\" title=\"範圍鍊\"></a>範圍鍊</h1><p>根據函式的靜態作用域、詞法作用域，也就是坐落的物理位置來向外查找可用的變數（accessible variables），而非呼叫的位置；每個函式的執行環境（execution context）都是獨立的執行堆疊（execution stack），並且都指向外部的執行環境（outer environment），一層一層的鏈結稱為範圍鍊（scope chain）。</p>\n<img src=\"/images/js-weird-parts-scope-chain/4.png\" class=\"\" width=\"800\" height=\"200\" title=\"scope-chain\">\n<blockquote class=\"colorquote info\"><p>值得注意的一點：函式 b 是在函式 a 呼叫並且執行之後才建立了函式 b 的執行環境。</p>\n</blockquote></body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/06/05/zh-tw/js-weird-parts-III/",
            "url": "http://maomaoxie.github.io/2022/06/05/zh-tw/js-weird-parts-III/",
            "title": "克服 Javascript 的奇怪部分 單執行緒與同步執行",
            "date_published": "2022-06-05T08:31:07.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-single-threaded/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-single-threaded\">\n<p>這一個章節要來講解 JavaScript 的幾個觀念。</p>\n<h1 id=\"單執行緒（Single-Threaded）\"><a href=\"#單執行緒（Single-Threaded）\" class=\"headerlink\" title=\"單執行緒（Single Threaded）\"></a>單執行緒（Single Threaded）</h1><p><strong>一次一件事</strong>是重點。<br>這個特性不是瀏覽器的特性，瀏覽器一次可能同時處理多件事情，JavaScript 引擎則是單執行緒的，就像排隊買早餐，老闆娘一次只能處理一位客人，而 JavaScript 也是一次只處理一項指令。</p>\n<h1 id=\"同步執行（Synchronous）\"><a href=\"#同步執行（Synchronous）\" class=\"headerlink\" title=\"同步執行（Synchronous）\"></a>同步執行（Synchronous）</h1><p><strong>順序</strong>是重點。<br>事情有先後順序，按照順序執行，一次執行一行（或者說一個單元的程式碼，可能是一個陳述式或表達式）。</p>\n<h1 id=\"呼叫函式（Function-Invocation）\"><a href=\"#呼叫函式（Function-Invocation）\" class=\"headerlink\" title=\"呼叫函式（Function Invocation）\"></a>呼叫函式（Function Invocation）</h1><p>觸發或執行一個函式，使用的符號為大括號（parenthesis）。<br>JavaScript 引擎在執行函式呼叫時，會發生幾件事情延續前面的章節：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>呼叫函式</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">b</span> () {</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">a</span> () {</span><br><span class=\"line\">  <span class=\"title function_\">b</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">a</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"創造階段\"><a href=\"#創造階段\" class=\"headerlink\" title=\"創造階段\"></a>創造階段</h2><ol>\n<li>全域執行環境（Global Execution Context）首先被創造。</li>\n<li>全域物件（Global object）被創造。</li>\n<li>全域 this 被創造。</li>\n<li>開始編譯階段（Parsing），編譯器巡過一遍所有程式碼發現了函式 b 與 a，在記憶體創造兩個函式的空間並且存放整個函式內容。</li>\n</ol>\n<img src=\"/images/js-weird-parts-III/1.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-III\">\n\n<h2 id=\"執行階段\"><a href=\"#執行階段\" class=\"headerlink\" title=\"執行階段\"></a>執行階段</h2><ol>\n<li><p>整個程式碼的記憶體準備完畢後，開始執行程式。</p>\n</li>\n<li><p>編譯器解析到<strong>函式 a</strong>被呼叫，立即於全域執行環境上方，產生並堆疊一個函式 a 的執行環境（Execution Context），放進<strong>執行佇列堆（Execution Stack）</strong>中，每個執行環境都有自己得記憶體空間存放著變數或函式。</p>\n<img src=\"/images/js-weird-parts-III/2.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-III\">\n</li>\n<li><p>最上方的執行佇列會優先執行，進入函式 a 的執行環境（Execution Context）並且解析到函式 b，程序暫停，立即於函式 a 的執行環境上方，產生並堆疊一個函式 b 的執行環境（Execution Context），放進<strong>執行佇列堆（Execution Stack）</strong>中。</p>\n<img src=\"/images/js-weird-parts-III/3.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-III\"></li>\n</ol>\n<p>以上執行階段也可以拆分成好幾個創造（執行環境），與執行（執行佇列堆最上方的執行環境）階段，在當下的執行環境執行過程中，只要觸發另一個函式，執行暫停然後創造（執行環境）、與執行（執行佇列堆最上方的執行環境），而下方的程式碼不會被解析，除非該執行環境執行完畢並且離開執行佇列堆（Execution Stack）後才會繼續逐行執行。</p>\n<blockquote class=\"colorquote Info\"><p>Everytime a function is called, a new execution context is created for that function, the <code>this</code> variable is created for that function, the variables in it were set up in the creation phase, then the code is executed line by line.<br>whatever is on the top of the execution stack, is currently running synchronously.</p>\n</blockquote>\n\n<p>重點整理：<br>當一個函式被觸發或是呼叫，JS 引擎會創造一個屬於該函式的執行環境（execution context）並且放置在執行緒的最上方等待被執行，而該堆疊中具有該函式獨有的執行環境與 This，開始執行並且完成後離開堆疊中（pop out）繼續執行下一個堆疊，只要解析到新的函式被呼叫就會反覆以上行為，直到堆疊不斷（pop out）剩下全域執行環境本身為止。</p>\n</body></html>",
            "tags": [
                "Javascript"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/06/04/zh-tw/js-weird-parts-II/",
            "url": "http://maomaoxie.github.io/2022/06/04/zh-tw/js-weird-parts-II/",
            "title": "克服 Javascript 的奇怪部分 Hoisting",
            "date_published": "2022-06-04T08:28:20.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-II/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-II\">\n<p>課程作者提到，<strong>Hoisting</strong> 大約是 JavaScript 裡最奇怪的行為了，而且是其他語言無法做到的特性，來了解一下怎麼回事吧！</p>\n<h1 id=\"Hoisting\"><a href=\"#Hoisting\" class=\"headerlink\" title=\"Hoisting\"></a>Hoisting</h1><p>這一段程式碼若在其他語言執行可是會發生錯誤的！但是在 JavaScript 裡卻可以安然無恙：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">b</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-string\">'123'</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">b</span> () {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"hljs-string\">'b is called!'</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<img src=\"/images/js-weird-parts-II/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-II\">\n<p>a 竟然在還未被宣告以前使用，會回傳 undefined；b 函式正常運作。<br>這就是 JavaScript 的 Hoisting 在搞鬼，但不要被 Hoisting 的提升之意混淆了，該現象並非程式碼被靜態的（physically）提升到最上方，我們來解析一下編譯器是如何執行這一段程式碼：</p>\n<h1 id=\"執行環境執行的兩階段\"><a href=\"#執行環境執行的兩階段\" class=\"headerlink\" title=\"執行環境執行的兩階段\"></a>執行環境執行的兩階段</h1><blockquote><p>There are two phases when it came to the execution context within the Javacript engine:<br>The first phase was the creation phase, when it sets up the variables and functions in memory. And the second phase was the execution phase, all those things already being set up, so now it runs your code line by line.</p>\n</blockquote>\n\n<h2 id=\"創造階段\"><a href=\"#創造階段\" class=\"headerlink\" title=\"創造階段\"></a>創造階段</h2><p>在第一個章節有提到，Javascript 並非是完全直譯的語言，其中一個佐證就是 Hoisting 的行為，如果程式碼真的是逐行翻譯然後執行，它是怎麼知道變數 a 與函式 b 會被創建的呢？</p>\n<p>這裡就能理解編譯器在執行程式以前仍存在一段<strong>編譯完成才執行</strong>的過程：<br>Javascript 引擎先將整個程式碼審視一遍，找出所有具有名稱（variable name）、<strong>並非</strong>透過區塊作用域（Block scope）的關鍵字 const 與 let ，而是 var 所宣告的的值或函式找出來，然後歸納：誰是變數就給予一個記憶體空間，存放著未定義的值（undefined）；誰是函式就給予一個記憶體空間，存放著整個函式的內容。</p>\n<img src=\"/images/js-weird-parts-II/2.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-II\">\n\n<p>也就是說創造階段可以這樣理解：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">b</span> () {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"hljs-string\">'b is called!'</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>變數 a 與函式 b 都各自被建立一個記憶體空間，接著存放著對應的值，變數 a 的記憶體空間內存放了 <code>undefined</code>，函式 b 的記憶體空間則直接放置整個函式內容。<br>關鍵就在變數的創造階段，只是<strong>宣告（declared）</strong>而已，這個階段 JavaScript 引擎並不清楚變數 a 將來的值會是甚麼，直到執行階段才會被<strong>指派（assigned）</strong>。</p>\n<h2 id=\"undefined-不等於-not-defined\"><a href=\"#undefined-不等於-not-defined\" class=\"headerlink\" title=\"undefined 不等於 not defined\"></a>undefined 不等於 not defined</h2><p>當變數通過 var 關鍵字宣告，記憶體就被建立並且放入 <code>undefined</code> 的值，如果變數未宣告就使用，則瀏覽器會噴錯誤訊息：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\"><span class=\"hljs-comment\">// Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></tbody></table></figure>\n<p>這是瀏覽器表示：嘿！我在任何記憶體都找不到這個名稱的參照，甚至連 <code>undefined</code> 都不是。</p>\n<h3 id=\"小知識\"><a href=\"#小知識\" class=\"headerlink\" title=\"小知識\"></a>小知識</h3><blockquote class=\"colorquote info\"><p>Since undefined is a longer string than null, the JIT compiler has to save 4 bytes more to memory when using undefined instead of null while parsing. Consider that memory aswell.</p>\n</blockquote>\n<p><code>undefined</code> 並非不存在的值，它是 Javacript 中的原始型別，也是純值的一種，甚至占了記憶體 4 個 bytes ，比空值<code>null</code>還要多。</p>\n<h2 id=\"良好的-coding-習慣\"><a href=\"#良好的-coding-習慣\" class=\"headerlink\" title=\"良好的 coding 習慣\"></a>良好的 coding 習慣</h2><h4 id=\"X-在宣告以前使用變數\"><a href=\"#X-在宣告以前使用變數\" class=\"headerlink\" title=\"(X)在宣告以前使用變數\"></a>(X)在宣告以前使用變數</h4><p>為了避免在執行過程被 Hoisting 汙染，最好養成先宣告後調用或賦值的習慣，可以避免一些錯誤發生，這也是為什麼 Eslint 或 Airbnb 等大宗規範都建議的撰寫規則。</p>\n<h4 id=\"X-將變數賦值為-undefined\"><a href=\"#X-將變數賦值為-undefined\" class=\"headerlink\" title=\"(X)將變數賦值為 undefined\"></a>(X)將變數賦值為 undefined</h4><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"hljs-literal\">undefined</span>;</span><br></pre></td></tr></tbody></table></figure>\n<p>倘若你這麼做了，會在除錯的時候難以辨認是 Javacript 引擎設定的還是後來你撰寫的程式所賦值的。</p>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>若要將 Hoisting 給予一個較好的解釋，我想就是「創建初始化」，給予一個初始的值以便後續利用：函式就直接賦值，變數的則填補上執行等號（=）以後的值，不過那已經是下一個<strong>執行階段</strong>的任務了。</p>\n</body></html>",
            "tags": [
                "javascript"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/06/04/zh-tw/js-weird-parts-parsing/",
            "url": "http://maomaoxie.github.io/2022/06/04/zh-tw/js-weird-parts-parsing/",
            "title": "克服 Javascript 的奇怪部分 名詞解釋篇",
            "date_published": "2022-06-04T03:07:31.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-I/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-I\">\n<p>先前滿常看到別人推薦的 Udemy 課程：克服JS的奇怪部分，原來自己已經購買且塵封在閱讀清單已久XD<br>馬上來匹乓一下吧！</p>\n<h1 id=\"執行篇\"><a href=\"#執行篇\" class=\"headerlink\" title=\"執行篇\"></a>執行篇</h1><h2 id=\"語法解析器（Syntax-Parser）\"><a href=\"#語法解析器（Syntax-Parser）\" class=\"headerlink\" title=\"語法解析器（Syntax Parser）\"></a>語法解析器（Syntax Parser）</h2><p>將你撰寫的 Javascript 編譯成電腦可以理解的一套程式語言（program），並且決定語法執行的方式以及是否合乎規範的角色，也與直譯（interprets）、轉譯（Compiler）概念雷同，其中直譯的編譯方式為逐字編譯後由電腦執行，大部分的 Javascript 程式都是直譯的，但並非全部情況。<br>編譯的過程會將 Javascript 拆解分類，依變數、函式等轉換成電腦硬體可以閱讀的語言，然後執行。</p>\n<img src=\"/images/js-weird-parts-I/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-I\">\n<p>可以想像成生產線上的作業員，持有原料工序可以生產產品。</p>\n<h2 id=\"靜態詞法作用域（Lexical-Environments）\"><a href=\"#靜態詞法作用域（Lexical-Environments）\" class=\"headerlink\" title=\"靜態詞法作用域（Lexical Environments）\"></a>靜態詞法作用域（Lexical Environments）</h2><blockquote class=\"colorquote info\"><p>Where something <strong>sits physically</strong> in the code you write,<br>determines how it interacts with other elements in the program.</p>\n</blockquote>\n<p><strong>撰寫</strong>的時候決定如何運作。<br>你撰寫語法的靜態物理位置，決定了該對象（變數、函式等）與其他對象的互動與執行關係，並且被直譯器透過這個物理關係，或者說詞彙或文法關係來統整歸坐落在硬體記憶體中的位置，但須注意的是並非所有語言皆如此（java、C# 等為動態作用域）。<br>這有助於上方的語法解析器來決定程式怎麼運作，你撰寫 code 的位置在哪？周圍有甚麼、被甚麼包圍都很重要！<br>可以想像成生產線上的主管，歸納好產品的原料工序與存放倉庫的規則。</p>\n<h2 id=\"執行環境（Execution-Context）\"><a href=\"#執行環境（Execution-Context）\" class=\"headerlink\" title=\"執行環境（Execution Context）\"></a>執行環境（Execution Context）</h2><blockquote class=\"colorquote info\"><p><strong>A wrapper</strong> to help manage the code that is running.<br>There are lots of lexical environments, which one is currently running is managed via execution context.</p>\n</blockquote>\n<p><strong>執行</strong>的時候決定如何運作。<br>靜態作用域很多，但是執行的當下順序則是由執行環境決定，也可以稱為上下文，最常見的就是每個函式建立之後產生的<code>this</code> keyword，通常為 block 作用域所包覆，在呼叫的時候決定 this 對象。<br>而執行環境不是只有與你撰寫的程式碼相關而已，也包含其他東西，例如上述的 this 就是執行函式當下的編譯過程動態產生的，編譯器在幫你翻譯給電腦讀懂以前，加油添醋了一些程序使程式碼更完整、具有前後順序給電腦執行。<br>可以想像成工廠的老闆，決定好哪批產品先出後出、出到哪裡。</p>\n<h1 id=\"變數篇\"><a href=\"#變數篇\" class=\"headerlink\" title=\"變數篇\"></a>變數篇</h1><h2 id=\"一個名稱對應一個值\"><a href=\"#一個名稱對應一個值\" class=\"headerlink\" title=\"一個名稱對應一個值\"></a>一個名稱對應一個值</h2><p>一個變數名可以更改很多次，但都只會包含一個值，而一個值裡面是更多的鍵值對。</p>\n<h2 id=\"物件\"><a href=\"#物件\" class=\"headerlink\" title=\"物件\"></a>物件</h2><p>更多鍵值對（key-value pairs）的集合。</p>\n<img src=\"/images/js-weird-parts-I/2.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-I\">\n\n<h1 id=\"全域物件與全域環境篇（Global）\"><a href=\"#全域物件與全域環境篇（Global）\" class=\"headerlink\" title=\"全域物件與全域環境篇（Global）\"></a>全域物件與全域環境篇（Global）</h1><figure class=\"highlight javascript hljs\"><figcaption><span>info</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">The</span> base execution context is your <span class=\"variable language_\">global</span> execution context.</span><br><span class=\"line\"><span class=\"title class_\">Things</span> that are accessible everywhere to everything to your code.</span><br><span class=\"line\"><span class=\"title class_\">And</span> it creates <span class=\"hljs-number\">2</span> things that you don<span class=\"hljs-string\">'t have to write about:</span></span><br><span class=\"line\"><span class=\"hljs-string\">1. Global object</span></span><br><span class=\"line\"><span class=\"hljs-string\">2. this</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"全域執行環境\"><a href=\"#全域執行環境\" class=\"headerlink\" title=\"全域執行環境\"></a>全域執行環境</h2><p>全域執行環境是所有 Javascript code 執行的基礎，所有的執行起點都存在於該環境內（being wrapped）。並且 Javascript 引擎會在執行初始建立兩個對象：全域物件與 this，即使你沒有撰寫任何程式碼，Javascript 引擎仍會自動產生。</p>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><p>其中全域執行環境中，瀏覽器底下的 this 就是指向 <strong>window</strong> (Global Object)。<br>weird-parts-I/3.png 600 200 js-weird-parts-I %}</p>\n<h2 id=\"全域物件\"><a href=\"#全域物件\" class=\"headerlink\" title=\"全域物件\"></a>全域物件</h2><p>若 Javascript 引擎是在後端執行，例如 node.js，則 全域物件就不會是 window。<br>當你在全域執行環境下靜態的撰寫變數或函式，並且詞法作用域上開放而沒有撰寫在其他函式內，就會自動附著（attached to）在全物域物件底下，全域物件意味著整個 Javascript 中的任何其他詞法作用域或者任何對象乃至整個檔案，都可以取用（accessible）這些資料。</p>\n<img src=\"/images/js-weird-parts-I/5.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-I\">\n<img src=\"/images/js-weird-parts-I/6.png\" class=\"\" width=\"500\" height=\"200\" title=\"js-weird-parts-I\">\n\n<p>以下都是指向同一個記憶體位置、同一個值：</p>\n<img src=\"/images/js-weird-parts-I/7.png\" class=\"\" width=\"500\" height=\"200\" title=\"js-weird-parts-I\">\n\n<p>在執行環境中，還有一個<strong>外部環境（Outer Environment）</strong>沒有提到，而在全域執行環境的層級中，外部環境是 null，因為全域本身就是最外層的 wrapper，沒有更外層的環境了。</p>\n<img src=\"/images/js-weird-parts-I/8.png\" class=\"\" width=\"700\" height=\"200\" title=\"js-weird-parts-I\">\n\n</body></html>",
            "tags": [
                "javascript"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/05/14/zh-tw/constructor-vs-instance/",
            "url": "http://maomaoxie.github.io/2022/05/14/zh-tw/constructor-vs-instance/",
            "title": "建構子方法與實例化方法",
            "date_published": "2022-05-14T13:37:03.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/constructor-vs-instance/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"constructor-vs-instance\">\n\n<p>在某天好奇想了解 Vue 3 的 defineProperty 原理搜尋了 <code>Object.defineProperty()</code> 這個方法時，看見以下說明：</p>\n<blockquote><p>靜態方法 <code>Object.defineProperty()</code> 會直接對一個物件定義、或是修改現有的屬性。執行後會回傳定義完的物件。<br>備註：這個方法會直接針對 Object 呼叫建構子（constructor），而不是 Object 型別的實例。</p>\n<footer><strong>MDN</strong><cite><a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\">Object.defineProperty()</a></cite></footer></blockquote>\n<p>其中的<strong>直接針對 Object 呼叫建構子（constructor），而不是 Object 型別的實例</strong>這句話突然讓我驚醒了，以前一直不能理解 javascript 中呼叫原生方法時，為何會有以下的區別：</p>\n<h2 id=\"透過建構器呼叫\"><a href=\"#透過建構器呼叫\" class=\"headerlink\" title=\"透過建構器呼叫\"></a>透過建構器呼叫</h2><p><code>Object.methods(objInstance)</code> -&gt; 例如 Object.keys(someObj)<br>這裡的 Object 是建構函式本身，未實例的藍圖（constructor）。</p>\n<h2 id=\"透過實例呼叫\"><a href=\"#透過實例呼叫\" class=\"headerlink\" title=\"透過實例呼叫\"></a>透過實例呼叫</h2><p><code>objInstance.methods(parameters)</code> -&gt; 例如 someObj.hasOwnProperty(‘prop’)<br>這裡的 Object 是實例化的物件（instance）。</p>\n<h2 id=\"Constructor-Static-Methods\"><a href=\"#Constructor-Static-Methods\" class=\"headerlink\" title=\"Constructor Static Methods\"></a>Constructor Static Methods</h2><h4 id=\"構造器-靜態方法\"><a href=\"#構造器-靜態方法\" class=\"headerlink\" title=\"構造器 靜態方法\"></a>構造器 靜態方法</h4><p>以下的例子是呼叫 Object 建構子中的原生 keys 方法，而不需要 new 一個物件實例就可以使用，靜態方法的特色是無需使用任何建構子中的 this 資料就可以直接使用。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>建構子方法</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> someone = {</span><br><span class=\"line\">  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Adam'</span>,</span><br><span class=\"line\">  <span class=\"hljs-attr\">carrer</span>: <span class=\"hljs-string\">'teacher'</span>,</span><br><span class=\"line\">  <span class=\"hljs-attr\">sex</span>: <span class=\"hljs-string\">'male'</span></span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> dataKeys = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(someone);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dataKeys);</span><br><span class=\"line\"><span class=\"hljs-comment\">// [\"name\",\"carrer\",\"sex\"]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Instance-methods\"><a href=\"#Instance-methods\" class=\"headerlink\" title=\"Instance methods\"></a>Instance methods</h3><h4 id=\"等號賦值-實例化方法\"><a href=\"#等號賦值-實例化方法\" class=\"headerlink\" title=\"等號賦值 實例化方法\"></a>等號賦值 實例化方法</h4><p>以下則是呼叫 Array 的實例化 push 方法，雖然也不是透過 new 來建立一個陣列，卻也是使用賦值一個陣列來建立陣列的實例，並且使用原生 push 方法。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>實例化方法 - 賦值</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> friends = [ <span class=\"hljs-string\">'Cally'</span>, <span class=\"hljs-string\">'Donna'</span>, <span class=\"hljs-string\">'Jell'</span> ];</span><br><span class=\"line\">friends.<span class=\"title function_\">push</span>(<span class=\"hljs-string\">'Liang'</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(friends);</span><br><span class=\"line\"><span class=\"hljs-comment\">// [\"Cally\",\"Donna\",\"Jell\",\"Liang\"]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"建構器-實例化方法\"><a href=\"#建構器-實例化方法\" class=\"headerlink\" title=\"建構器 實例化方法\"></a>建構器 實例化方法</h4><p>透過 new 來建立一個陣列。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>實例化方法 - 構造器</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> animals = <span class=\"hljs-keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"hljs-string\">'bunny'</span>, <span class=\"hljs-string\">'cat'</span>, <span class=\"hljs-string\">'puppy'</span>, <span class=\"hljs-string\">'hamster'</span>);</span><br><span class=\"line\">animals.<span class=\"title function_\">unshift</span>(<span class=\"hljs-string\">'bird'</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(animals);</span><br><span class=\"line\"><span class=\"hljs-comment\">// [\"bird\",\"bunny\",\"cat\",\"puppy\",\"hamster\"]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"構造器靜態方法補充\"><a href=\"#構造器靜態方法補充\" class=\"headerlink\" title=\"構造器靜態方法補充\"></a>構造器靜態方法補充</h2><h4 id=\"無法取得構造器的this資料\"><a href=\"#無法取得構造器的this資料\" class=\"headerlink\" title=\"無法取得構造器的this資料\"></a>無法取得構造器的this資料</h4><blockquote><ul>\n<li>The static method also cannot see the instance variable state so if we try to call the nonstatic method from the static method compiler will complain.</li>\n<li>The static method can be used to create utility functions.<br><a href=\"https://www.educba.com/javascript-static-method/\">https://www.educba.com/javascript-static-method/</a></li>\n</ul>\n</blockquote>\n\n<p>從上述可以得知靜態方法是不能取用構造器建構子（constructor）內的變數的（this binding），通常會撰寫純函式（pure function）以保持無狀態的特性，如同 Math 方法。<br>靜態方法適合用來當作全局複用的函式，適合較無副作用的邏輯。</p>\n<h2 id=\"兩種方法的原型鍊關係\"><a href=\"#兩種方法的原型鍊關係\" class=\"headerlink\" title=\"兩種方法的原型鍊關係\"></a>兩種方法的原型鍊關係</h2><p>若展開一個實例化的物件，會發現：</p>\n<ol>\n<li>建構器方法存在於建構子物件中（constructor），且只能透過建構器呼叫，例如 Object.assign()；</li>\n<li>實例化方法則存在於原型上（prototype），需要實例化之後才能呼叫，例如 objInstance.toLocaleString()</li>\n</ol>\n</body></html>",
            "tags": [
                "javascript",
                "constructor",
                "instance",
                "methods"
            ]
        }
    ]
}