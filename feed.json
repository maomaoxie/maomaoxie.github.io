{
    "version": "https://jsonfeed.org/version/1",
    "title": "Mawchu 貓奴前端的天空",
    "description": "Mawchu 貓奴前端，為熱愛平面設計與貓咪的前端工程師 - 謝佳芳（毛球）的技術部落格，喜歡撰寫技術文章幫助自己在前端之路成長，涉及 Javascript、Vue、Laravel 與其他程式相關的討論與學習",
    "home_page_url": "http://maomaoxie.github.io",
    "items": [
        {
            "id": "http://maomaoxie.github.io/2022/08/04/zh-tw/hello-world/",
            "url": "http://maomaoxie.github.io/2022/08/04/zh-tw/hello-world/",
            "title": "感謝您的閱讀",
            "date_published": "2022-08-04T05:56:06.910Z",
            "content_html": "<html><head></head><body><p>這裡撰寫的都是一些自己在前端之路上每天一小步的學習，希望透過記錄與陳述來加強學習成效以及融會貫通的能力，文章內有任何問題歡迎一起討論呦!</p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/07/30/zh-tw/js-weird-parts-value/",
            "url": "http://maomaoxie.github.io/2022/07/30/zh-tw/js-weird-parts-value/",
            "title": "克服 Javascript 的奇怪部分 原始型別",
            "date_published": "2022-07-30T09:08:20.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-value/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-primitive-type\">\n<p>只要不是物件型別的值都可以看做是原始型別，例如：</p>\n<h1 id=\"undefined\"><a href=\"#undefined\" class=\"headerlink\" title=\"undefined\"></a>undefined</h1><p>當一個變數還未指派任何值之前，記憶體位置會被賦予一個 undefied 的值，通常是 Javascript 引擎指派的，應該避免將任何值的預設值設定為 undefined，避免與 Hoisting 行為混淆了。</p>\n<h1 id=\"null\"><a href=\"#null\" class=\"headerlink\" title=\"null\"></a>null</h1><p>若需要再資料回來之前給予判斷，可以將變數設定為 null 來表示該變數還未拿到任何值，也非 Javascript 引擎指派的值。</p>\n<h1 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h1><p>true 或 false 的判斷型別，值得注意的是當值存在 localstorage 或者 cookie 時應避免儲存 true 或 false，轉換過程會強制變成 string 而造成錯誤的判斷。</p>\n<h1 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\"number\"></a>number</h1><p>唯一的數字型別（numeric），不同於其他語言可能具有細緻的數字型別，例如 interger 或是 demicals，Javascript 只有一個 number type，為<strong>浮點運算（floating point number）</strong>，這種運算法為一個有效數字加上冪數來表示，電腦本身的二進制無法實現十進制的數字精確性，會造成數字計算上浮點位數的不正確，只能計算出近似值而已。</p>\n<h1 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h1><p>字串型別，一串使用雙引號或單引號標記起來的文字。</p>\n<h1 id=\"symbol\"><a href=\"#symbol\" class=\"headerlink\" title=\"symbol\"></a>symbol</h1><p>ES6 引入的新原始型別，用來表示一個獨一無二的值。產生的原因來自於物件的屬性通常都是字串（property），這樣容易造就重複的屬性而衝突，新的符號型別（symbol）於是誕生，兩個 symbol 永遠不會相等，是絕對的獨一無二。ES6 允許使用表達式 (expression) 作為屬性的名稱，語法是將 expression 放在中括號 [ ] 裡面：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>symbol</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> s = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> obj = {</span><br><span class=\"line\">    [s]: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {}</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure></body></html>",
            "tags": [
                "javascript",
                "type"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/07/30/zh-tw/js-weird-parts-types/",
            "url": "http://maomaoxie.github.io/2022/07/30/zh-tw/js-weird-parts-types/",
            "title": "克服 Javascript 的奇怪部分 型別",
            "date_published": "2022-07-30T08:35:45.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-dynamic-typing/0.png\" class=\"\" title=\"dynamic-typing\">\n<h1 id=\"Dynamic-Typing\"><a href=\"#Dynamic-Typing\" class=\"headerlink\" title=\"Dynamic Typing\"></a>Dynamic Typing</h1><p>Javascript 的型別為動態型別（Dynamic Typing），不同於 C# 等強型別語言的靜態型別（Static Typing），無須指派型別而是在引擎執行的階段（at runtime）辨認變數記憶體內的型別為何：</p>\n<blockquote class=\"colorquote info\"><p>Dynamically-typed languages are those (like JavaScript) where the interpreter assigns variables a type at runtime based on the variable’s value at the time.</p>\n</blockquote>\n\n<p>這有可能導致一個變數在每次程式執行的結果都產生不同的型別（例如 == 型別隱式轉換），而造成不如預期的結果，所以使用三等號是比較良好的撰寫習慣。</p>\n</body></html>",
            "tags": [
                "javascript",
                "type"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/07/24/zh-tw/js-weird-parts-asynchronous/",
            "url": "http://maomaoxie.github.io/2022/07/24/zh-tw/js-weird-parts-asynchronous/",
            "title": "克服 Javascript 的奇怪部分 如何執行非同步",
            "date_published": "2022-07-24T08:56:25.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-asynchronous/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"asynchronous\">\n\n<p>瀏覽器在運作的時候有三大功能要執行：render engine 畫面渲染 -&gt; JavaScript 引擎 -&gt; Http Request。</p>\n<blockquote class=\"colorquote info\"><p>A browser engine (also known as a layout engine or rendering engine) is a core software component of every major web browser. The primary job of a browser engine is to <strong>transform HTML documents and other resources of a web page into an interactive visual representation on a user’s device</strong>.</p>\n</blockquote>\n\n<p>雖然名詞解釋上為非同步，但在 JavaScript 運作上實際仍是 line by line，而且具有先後順序的，對瀏覽器而言以下三項機制才是同時運作（asynchronous）：</p>\n<img src=\"/images/js-weird-parts-asynchronous/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"asynchronous\">\n\n<h1 id=\"Http-request-amp-response\"><a href=\"#Http-request-amp-response\" class=\"headerlink\" title=\"Http request &amp; response\"></a>Http request &amp; response</h1><p>客戶端發送了頁面請求後，<strong>Http 機制</strong>開始運行收發請求與回應網路資源的文本協定，建立瀏覽器與伺服器的溝通橋樑，作為 TCP/IP 的應用層，並且將資料回應提供給 JavaScript 來處理。</p>\n<h1 id=\"Javascript\"><a href=\"#Javascript\" class=\"headerlink\" title=\"Javascript\"></a>Javascript</h1><p>一旦提及非同步就不可埋沒一大功臣，JavaScript 引擎中的<strong>事件佇列（Event Queue）</strong>。</p>\n<h4 id=\"事件佇列（Event-Queue）\"><a href=\"#事件佇列（Event-Queue）\" class=\"headerlink\" title=\"事件佇列（Event Queue）\"></a>事件佇列（Event Queue）</h4><p>當 Javascript 引擎執行完執行佇列（Execution Stack）的內容後，也就是執行佇列已經清空後，會定期（periodic）來檢視事件佇列（Event Queue）的事件排序並且執行，例如 Click 事件的回呼函式，或者是 API 收發資料的任務，才會被放置到執行佇列（Execution Stack）然後執行。在 Javascript 中的運作仍是同步的，並沒有非同步在執行程式。</p>\n<h4 id=\"微任務與宏任務\"><a href=\"#微任務與宏任務\" class=\"headerlink\" title=\"微任務與宏任務\"></a>微任務與宏任務</h4><p>部分的執行任務會被放置在事件佇列中，待執行佇列（Execution Stack）所有任務完成後才會開始執行，例如 SetTimeout（宏任務） 或是 promise（微任務） 等。</p>\n<h1 id=\"Render-engine\"><a href=\"#Render-engine\" class=\"headerlink\" title=\"Render engine\"></a>Render engine</h1><p>JavaScript 的必須仰賴瀏覽器的引擎，當瀏覽器讀取一個頁面時， JavaScript 具有觸發畫面渲染的鉤子促使<strong>渲染引擎（Render Engine）</strong>來改變畫面。</p>\n<blockquote class=\"colorquote danger\"><p>Asynchronous means that the rendering engine, the javascript engine and the HTTP requests are running asynchrounously inside the browser, what’s happening just inside the javascript is synchrounous.</p>\n</blockquote></body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/07/24/zh-tw/js-weird-parts-ES6/",
            "url": "http://maomaoxie.github.io/2022/07/24/zh-tw/js-weird-parts-ES6/",
            "title": "克服 Javascript 的奇怪部分 ES6",
            "date_published": "2022-07-24T08:30:58.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-let/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"ES6-let\">\n<h1 id=\"ES6-let\"><a href=\"#ES6-let\" class=\"headerlink\" title=\"ES6 let\"></a>ES6 let</h1><p>不同於 var 的宣告方式，let 宣告的變數在宣告時會出現暫時性死區不可取用，沒有 hoisting 現象，且變數的作用域只存在於 block 區塊中，例如 if 陳述句，而 var 則是函式作用域，若撰寫在 if 陳述句內外部仍可取用。<br>最經典的應用就是 for 迴圈，可以在每一次的 console 正確印出數值：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>for loop</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">5</span>; i++) {</span><br><span class=\"line\">  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">()=&gt;</span>{</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i)</span><br><span class=\"line\">  },<span class=\"hljs-number\">1000</span>)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/07/10/zh-tw/js-weird-parts-scope-chain/",
            "url": "http://maomaoxie.github.io/2022/07/10/zh-tw/js-weird-parts-scope-chain/",
            "title": "克服 Javascript 的奇怪部分 範圍鍊",
            "date_published": "2022-07-10T07:57:42.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-scope-chain/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"scope-chain\">\n\n<p>以下探討的幾個議題都離不開函式（function）本身：</p>\n<h1 id=\"環境變數\"><a href=\"#環境變數\" class=\"headerlink\" title=\"環境變數\"></a>環境變數</h1><p>每個執行環境（execution context）都有屬於其中的變數，可以把執行環境想作是一個<strong>空間範圍</strong>，而環境變數都附著在其中，例如全域變數（global variable）會附著在全域物件下，瀏覽器的全域執行環境則是屬於 window 物件，宣告在其中的變數都會隸屬於全域執行環境。</p>\n<h1 id=\"函式變數\"><a href=\"#函式變數\" class=\"headerlink\" title=\"函式變數\"></a>函式變數</h1><p>函式變數在函式被呼叫並觸發後創造了一個獨特的函式執行環境，該函式內有自己的變數，此變數式在函式內<strong>宣告（declaration）</strong>並且創造的，只能在該函式執行環境中可以取得，稱為區域變數（scoped variable），而變數可取用的範圍稱之作用域（scope）。</p>\n<h1 id=\"範圍鍊\"><a href=\"#範圍鍊\" class=\"headerlink\" title=\"範圍鍊\"></a>範圍鍊</h1><p>根據函式的靜態作用域、詞法作用域，也就是坐落的物理位置來向外查找可用的變數（accessible variables），而非呼叫的位置；每個函式的執行環境（execution context）都是獨立的執行堆疊（execution stack），並且都指向外部的執行環境（outer environment），一層一層的鏈結稱為範圍鍊（scope chain）。</p>\n<img src=\"/images/js-weird-parts-scope-chain/4.png\" class=\"\" width=\"800\" height=\"200\" title=\"scope-chain\">\n<blockquote class=\"colorquote info\"><p>值得注意的一點：函式 b 是在函式 a 呼叫並且執行之後才建立了函式 b 的執行環境。</p>\n</blockquote></body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/06/05/zh-tw/js-weird-parts-III/",
            "url": "http://maomaoxie.github.io/2022/06/05/zh-tw/js-weird-parts-III/",
            "title": "克服 Javascript 的奇怪部分 單執行緒與同步執行",
            "date_published": "2022-06-05T08:31:07.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-single-threaded/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-single-threaded\">\n<p>這一個章節要來講解 JavaScript 的幾個觀念。</p>\n<h1 id=\"單執行緒（Single-Threaded）\"><a href=\"#單執行緒（Single-Threaded）\" class=\"headerlink\" title=\"單執行緒（Single Threaded）\"></a>單執行緒（Single Threaded）</h1><p><strong>一次一件事</strong>是重點。<br>這個特性不是瀏覽器的特性，瀏覽器一次可能同時處理多件事情，JavaScript 引擎則是單執行緒的，就像排隊買早餐，老闆娘一次只能處理一位客人，而 JavaScript 也是一次只處理一項指令。</p>\n<h1 id=\"同步執行（Synchronous）\"><a href=\"#同步執行（Synchronous）\" class=\"headerlink\" title=\"同步執行（Synchronous）\"></a>同步執行（Synchronous）</h1><p><strong>順序</strong>是重點。<br>事情有先後順序，按照順序執行，一次執行一行（或者說一個單元的程式碼，可能是一個陳述式或表達式）。</p>\n<h1 id=\"呼叫函式（Function-Invocation）\"><a href=\"#呼叫函式（Function-Invocation）\" class=\"headerlink\" title=\"呼叫函式（Function Invocation）\"></a>呼叫函式（Function Invocation）</h1><p>觸發或執行一個函式，使用的符號為大括號（parenthesis）。<br>JavaScript 引擎在執行函式呼叫時，會發生幾件事情延續前面的章節：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>呼叫函式</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">b</span> () {</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">a</span> () {</span><br><span class=\"line\">  <span class=\"title function_\">b</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">a</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"創造階段\"><a href=\"#創造階段\" class=\"headerlink\" title=\"創造階段\"></a>創造階段</h2><ol>\n<li>全域執行環境（Global Execution Context）首先被創造。</li>\n<li>全域物件（Global object）被創造。</li>\n<li>全域 this 被創造。</li>\n<li>開始編譯階段（Parsing），編譯器巡過一遍所有程式碼發現了函式 b 與 a，在記憶體創造兩個函式的空間並且存放整個函式內容。</li>\n</ol>\n<img src=\"/images/js-weird-parts-III/1.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-III\">\n\n<h2 id=\"執行階段\"><a href=\"#執行階段\" class=\"headerlink\" title=\"執行階段\"></a>執行階段</h2><ol>\n<li><p>整個程式碼的記憶體準備完畢後，開始執行程式。</p>\n</li>\n<li><p>編譯器解析到<strong>函式 a</strong>被呼叫，立即於全域執行環境上方，產生並堆疊一個函式 a 的執行環境（Execution Context），放進<strong>執行佇列堆（Execution Stack）</strong>中，每個執行環境都有自己得記憶體空間存放著變數或函式。</p>\n<img src=\"/images/js-weird-parts-III/2.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-III\">\n</li>\n<li><p>最上方的執行佇列會優先執行，進入函式 a 的執行環境（Execution Context）並且解析到函式 b，程序暫停，立即於函式 a 的執行環境上方，產生並堆疊一個函式 b 的執行環境（Execution Context），放進<strong>執行佇列堆（Execution Stack）</strong>中。</p>\n<img src=\"/images/js-weird-parts-III/3.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-III\"></li>\n</ol>\n<p>以上執行階段也可以拆分成好幾個創造（執行環境），與執行（執行佇列堆最上方的執行環境）階段，在當下的執行環境執行過程中，只要觸發另一個函式，執行暫停然後創造（執行環境）、與執行（執行佇列堆最上方的執行環境），而下方的程式碼不會被解析，除非該執行環境執行完畢並且離開執行佇列堆（Execution Stack）後才會繼續逐行執行。</p>\n<blockquote class=\"colorquote Info\"><p>Everytime a function is called, a new execution context is created for that function, the <code>this</code> variable is created for that function, the variables in it were set up in the creation phase, then the code is executed line by line.<br>whatever is on the top of the execution stack, is currently running synchronously.</p>\n</blockquote>\n\n<p>重點整理：<br>當一個函式被觸發或是呼叫，JS 引擎會創造一個屬於該函式的執行環境（execution context）並且放置在執行緒的最上方等待被執行，而該堆疊中具有該函式獨有的執行環境與 This，開始執行並且完成後離開堆疊中（pop out）繼續執行下一個堆疊，只要解析到新的函式被呼叫就會反覆以上行為，直到堆疊不斷（pop out）剩下全域執行環境本身為止。</p>\n</body></html>",
            "tags": [
                "Javascript"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/06/04/zh-tw/js-weird-parts-II/",
            "url": "http://maomaoxie.github.io/2022/06/04/zh-tw/js-weird-parts-II/",
            "title": "克服 Javascript 的奇怪部分 Hoisting",
            "date_published": "2022-06-04T08:28:20.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-II/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-II\">\n<p>課程作者提到，<strong>Hoisting</strong> 大約是 JavaScript 裡最奇怪的行為了，而且是其他語言無法做到的特性，來了解一下怎麼回事吧！</p>\n<h1 id=\"Hoisting\"><a href=\"#Hoisting\" class=\"headerlink\" title=\"Hoisting\"></a>Hoisting</h1><p>這一段程式碼若在其他語言執行可是會發生錯誤的！但是在 JavaScript 裡卻可以安然無恙：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">b</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-string\">'123'</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">b</span> () {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"hljs-string\">'b is called!'</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<img src=\"/images/js-weird-parts-II/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-II\">\n<p>a 竟然在還未被宣告以前使用，會回傳 undefined；b 函式正常運作。<br>這就是 JavaScript 的 Hoisting 在搞鬼，但不要被 Hoisting 的提升之意混淆了，該現象並非程式碼被靜態的（physically）提升到最上方，我們來解析一下編譯器是如何執行這一段程式碼：</p>\n<h1 id=\"執行環境執行的兩階段\"><a href=\"#執行環境執行的兩階段\" class=\"headerlink\" title=\"執行環境執行的兩階段\"></a>執行環境執行的兩階段</h1><blockquote><p>There are two phases when it came to the execution context within the Javacript engine:<br>The first phase was the creation phase, when it sets up the variables and functions in memory. And the second phase was the execution phase, all those things already being set up, so now it runs your code line by line.</p>\n</blockquote>\n\n<h2 id=\"創造階段\"><a href=\"#創造階段\" class=\"headerlink\" title=\"創造階段\"></a>創造階段</h2><p>在第一個章節有提到，Javascript 並非是完全直譯的語言，其中一個佐證就是 Hoisting 的行為，如果程式碼真的是逐行翻譯然後執行，它是怎麼知道變數 a 與函式 b 會被創建的呢？</p>\n<p>這裡就能理解編譯器在執行程式以前仍存在一段<strong>編譯完成才執行</strong>的過程：<br>Javascript 引擎先將整個程式碼審視一遍，找出所有具有名稱（variable name）、<strong>並非</strong>透過區塊作用域（Block scope）的關鍵字 const 與 let ，而是 var 所宣告的的值或函式找出來，然後歸納：誰是變數就給予一個記憶體空間，存放著未定義的值（undefined）；誰是函式就給予一個記憶體空間，存放著整個函式的內容。</p>\n<img src=\"/images/js-weird-parts-II/2.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-II\">\n\n<p>也就是說創造階段可以這樣理解：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">b</span> () {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"hljs-string\">'b is called!'</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>變數 a 與函式 b 都各自被建立一個記憶體空間，接著存放著對應的值，變數 a 的記憶體空間內存放了 <code>undefined</code>，函式 b 的記憶體空間則直接放置整個函式內容。<br>關鍵就在變數的創造階段，只是<strong>宣告（declared）</strong>而已，這個階段 JavaScript 引擎並不清楚變數 a 將來的值會是甚麼，直到執行階段才會被<strong>指派（assigned）</strong>。</p>\n<h2 id=\"undefined-不等於-not-defined\"><a href=\"#undefined-不等於-not-defined\" class=\"headerlink\" title=\"undefined 不等於 not defined\"></a>undefined 不等於 not defined</h2><p>當變數通過 var 關鍵字宣告，記憶體就被建立並且放入 <code>undefined</code> 的值，如果變數未宣告就使用，則瀏覽器會噴錯誤訊息：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\"><span class=\"hljs-comment\">// Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></tbody></table></figure>\n<p>這是瀏覽器表示：嘿！我在任何記憶體都找不到這個名稱的參照，甚至連 <code>undefined</code> 都不是。</p>\n<h3 id=\"小知識\"><a href=\"#小知識\" class=\"headerlink\" title=\"小知識\"></a>小知識</h3><blockquote class=\"colorquote info\"><p>Since undefined is a longer string than null, the JIT compiler has to save 4 bytes more to memory when using undefined instead of null while parsing. Consider that memory aswell.</p>\n</blockquote>\n<p><code>undefined</code> 並非不存在的值，它是 Javacript 中的原始型別，也是純值的一種，甚至占了記憶體 4 個 bytes ，比空值<code>null</code>還要多。</p>\n<h2 id=\"良好的-coding-習慣\"><a href=\"#良好的-coding-習慣\" class=\"headerlink\" title=\"良好的 coding 習慣\"></a>良好的 coding 習慣</h2><h4 id=\"X-在宣告以前使用變數\"><a href=\"#X-在宣告以前使用變數\" class=\"headerlink\" title=\"(X)在宣告以前使用變數\"></a>(X)在宣告以前使用變數</h4><p>為了避免在執行過程被 Hoisting 汙染，最好養成先宣告後調用或賦值的習慣，可以避免一些錯誤發生，這也是為什麼 Eslint 或 Airbnb 等大宗規範都建議的撰寫規則。</p>\n<h4 id=\"X-將變數賦值為-undefined\"><a href=\"#X-將變數賦值為-undefined\" class=\"headerlink\" title=\"(X)將變數賦值為 undefined\"></a>(X)將變數賦值為 undefined</h4><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"hljs-literal\">undefined</span>;</span><br></pre></td></tr></tbody></table></figure>\n<p>倘若你這麼做了，會在除錯的時候難以辨認是 Javacript 引擎設定的還是後來你撰寫的程式所賦值的。</p>\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><p>若要將 Hoisting 給予一個較好的解釋，我想就是「創建初始化」，給予一個初始的值以便後續利用：函式就直接賦值，變數的則填補上執行等號（=）以後的值，不過那已經是下一個<strong>執行階段</strong>的任務了。</p>\n</body></html>",
            "tags": [
                "javascript"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/06/04/zh-tw/js-weird-parts-parsing/",
            "url": "http://maomaoxie.github.io/2022/06/04/zh-tw/js-weird-parts-parsing/",
            "title": "克服 Javascript 的奇怪部分 名詞解釋篇",
            "date_published": "2022-06-04T03:07:31.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-I/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-I\">\n<p>先前滿常看到別人推薦的 Udemy 課程：克服JS的奇怪部分，原來自己已經購買且塵封在閱讀清單已久XD<br>馬上來匹乓一下吧！</p>\n<h1 id=\"執行篇\"><a href=\"#執行篇\" class=\"headerlink\" title=\"執行篇\"></a>執行篇</h1><h2 id=\"語法解析器（Syntax-Parser）\"><a href=\"#語法解析器（Syntax-Parser）\" class=\"headerlink\" title=\"語法解析器（Syntax Parser）\"></a>語法解析器（Syntax Parser）</h2><p>將你撰寫的 Javascript 編譯成電腦可以理解的一套程式語言（program），並且決定語法執行的方式以及是否合乎規範的角色，也與直譯（interprets）、轉譯（Compiler）概念雷同，其中直譯的編譯方式為逐字編譯後由電腦執行，大部分的 Javascript 程式都是直譯的，但並非全部情況。<br>編譯的過程會將 Javascript 拆解分類，依變數、函式等轉換成電腦硬體可以閱讀的語言，然後執行。</p>\n<img src=\"/images/js-weird-parts-I/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-I\">\n<p>可以想像成生產線上的作業員，持有原料工序可以生產產品。</p>\n<h2 id=\"靜態詞法作用域（Lexical-Environments）\"><a href=\"#靜態詞法作用域（Lexical-Environments）\" class=\"headerlink\" title=\"靜態詞法作用域（Lexical Environments）\"></a>靜態詞法作用域（Lexical Environments）</h2><blockquote class=\"colorquote info\"><p>Where something <strong>sits physically</strong> in the code you write,<br>determines how it interacts with other elements in the program.</p>\n</blockquote>\n<p><strong>撰寫</strong>的時候決定如何運作。<br>你撰寫語法的靜態物理位置，決定了該對象（變數、函式等）與其他對象的互動與執行關係，並且被直譯器透過這個物理關係，或者說詞彙或文法關係來統整歸坐落在硬體記憶體中的位置，但須注意的是並非所有語言皆如此（java、C# 等為動態作用域）。<br>這有助於上方的語法解析器來決定程式怎麼運作，你撰寫 code 的位置在哪？周圍有甚麼、被甚麼包圍都很重要！<br>可以想像成生產線上的主管，歸納好產品的原料工序與存放倉庫的規則。</p>\n<h2 id=\"執行環境（Execution-Context）\"><a href=\"#執行環境（Execution-Context）\" class=\"headerlink\" title=\"執行環境（Execution Context）\"></a>執行環境（Execution Context）</h2><blockquote class=\"colorquote info\"><p><strong>A wrapper</strong> to help manage the code that is running.<br>There are lots of lexical environments, which one is currently running is managed via execution context.</p>\n</blockquote>\n<p><strong>執行</strong>的時候決定如何運作。<br>靜態作用域很多，但是執行的當下順序則是由執行環境決定，也可以稱為上下文，最常見的就是每個函式建立之後產生的<code>this</code> keyword，通常為 block 作用域所包覆，在呼叫的時候決定 this 對象。<br>而執行環境不是只有與你撰寫的程式碼相關而已，也包含其他東西，例如上述的 this 就是執行函式當下的編譯過程動態產生的，編譯器在幫你翻譯給電腦讀懂以前，加油添醋了一些程序使程式碼更完整、具有前後順序給電腦執行。<br>可以想像成工廠的老闆，決定好哪批產品先出後出、出到哪裡。</p>\n<h1 id=\"變數篇\"><a href=\"#變數篇\" class=\"headerlink\" title=\"變數篇\"></a>變數篇</h1><h2 id=\"一個名稱對應一個值\"><a href=\"#一個名稱對應一個值\" class=\"headerlink\" title=\"一個名稱對應一個值\"></a>一個名稱對應一個值</h2><p>一個變數名可以更改很多次，但都只會包含一個值，而一個值裡面是更多的鍵值對。</p>\n<h2 id=\"物件\"><a href=\"#物件\" class=\"headerlink\" title=\"物件\"></a>物件</h2><p>更多鍵值對（key-value pairs）的集合。</p>\n<img src=\"/images/js-weird-parts-I/2.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-I\">\n\n<h1 id=\"全域物件與全域環境篇（Global）\"><a href=\"#全域物件與全域環境篇（Global）\" class=\"headerlink\" title=\"全域物件與全域環境篇（Global）\"></a>全域物件與全域環境篇（Global）</h1><figure class=\"highlight javascript hljs\"><figcaption><span>info</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">The</span> base execution context is your <span class=\"variable language_\">global</span> execution context.</span><br><span class=\"line\"><span class=\"title class_\">Things</span> that are accessible everywhere to everything to your code.</span><br><span class=\"line\"><span class=\"title class_\">And</span> it creates <span class=\"hljs-number\">2</span> things that you don<span class=\"hljs-string\">'t have to write about:</span></span><br><span class=\"line\"><span class=\"hljs-string\">1. Global object</span></span><br><span class=\"line\"><span class=\"hljs-string\">2. this</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"全域執行環境\"><a href=\"#全域執行環境\" class=\"headerlink\" title=\"全域執行環境\"></a>全域執行環境</h2><p>全域執行環境是所有 Javascript code 執行的基礎，所有的執行起點都存在於該環境內（being wrapped）。並且 Javascript 引擎會在執行初始建立兩個對象：全域物件與 this，即使你沒有撰寫任何程式碼，Javascript 引擎仍會自動產生。</p>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><p>其中全域執行環境中，瀏覽器底下的 this 就是指向 <strong>window</strong> (Global Object)。<br>weird-parts-I/3.png 600 200 js-weird-parts-I %}</p>\n<h2 id=\"全域物件\"><a href=\"#全域物件\" class=\"headerlink\" title=\"全域物件\"></a>全域物件</h2><p>若 Javascript 引擎是在後端執行，例如 node.js，則 全域物件就不會是 window。<br>當你在全域執行環境下靜態的撰寫變數或函式，並且詞法作用域上開放而沒有撰寫在其他函式內，就會自動附著（attached to）在全物域物件底下，全域物件意味著整個 Javascript 中的任何其他詞法作用域或者任何對象乃至整個檔案，都可以取用（accessible）這些資料。</p>\n<img src=\"/images/js-weird-parts-I/5.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-I\">\n<img src=\"/images/js-weird-parts-I/6.png\" class=\"\" width=\"500\" height=\"200\" title=\"js-weird-parts-I\">\n\n<p>以下都是指向同一個記憶體位置、同一個值：</p>\n<img src=\"/images/js-weird-parts-I/7.png\" class=\"\" width=\"500\" height=\"200\" title=\"js-weird-parts-I\">\n\n<p>在執行環境中，還有一個<strong>外部環境（Outer Environment）</strong>沒有提到，而在全域執行環境的層級中，外部環境是 null，因為全域本身就是最外層的 wrapper，沒有更外層的環境了。</p>\n<img src=\"/images/js-weird-parts-I/8.png\" class=\"\" width=\"700\" height=\"200\" title=\"js-weird-parts-I\">\n\n</body></html>",
            "tags": [
                "javascript"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/05/14/zh-tw/constructor-vs-instance/",
            "url": "http://maomaoxie.github.io/2022/05/14/zh-tw/constructor-vs-instance/",
            "title": "建構子方法與實例化方法",
            "date_published": "2022-05-14T13:37:03.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/constructor-vs-instance/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"constructor-vs-instance\">\n\n<p>在某天好奇想了解 Vue 3 的 defineProperty 原理搜尋了 <code>Object.defineProperty()</code> 這個方法時，看見以下說明：</p>\n<blockquote><p>靜態方法 <code>Object.defineProperty()</code> 會直接對一個物件定義、或是修改現有的屬性。執行後會回傳定義完的物件。<br>備註：這個方法會直接針對 Object 呼叫建構子（constructor），而不是 Object 型別的實例。</p>\n<footer><strong>MDN</strong><cite><a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\">Object.defineProperty()</a></cite></footer></blockquote>\n<p>其中的<strong>直接針對 Object 呼叫建構子（constructor），而不是 Object 型別的實例</strong>這句話突然讓我驚醒了，以前一直不能理解 javascript 中呼叫原生方法時，為何會有以下的區別：</p>\n<h2 id=\"透過建構器呼叫\"><a href=\"#透過建構器呼叫\" class=\"headerlink\" title=\"透過建構器呼叫\"></a>透過建構器呼叫</h2><p><code>Object.methods(objInstance)</code> -&gt; 例如 Object.keys(someObj)<br>這裡的 Object 是建構函式本身，未實例的藍圖（constructor）。</p>\n<h2 id=\"透過實例呼叫\"><a href=\"#透過實例呼叫\" class=\"headerlink\" title=\"透過實例呼叫\"></a>透過實例呼叫</h2><p><code>objInstance.methods(parameters)</code> -&gt; 例如 someObj.hasOwnProperty(‘prop’)<br>這裡的 Object 是實例化的物件（instance）。</p>\n<h2 id=\"Constructor-Static-Methods\"><a href=\"#Constructor-Static-Methods\" class=\"headerlink\" title=\"Constructor Static Methods\"></a>Constructor Static Methods</h2><h4 id=\"構造器-靜態方法\"><a href=\"#構造器-靜態方法\" class=\"headerlink\" title=\"構造器 靜態方法\"></a>構造器 靜態方法</h4><p>以下的例子是呼叫 Object 建構子中的原生 keys 方法，而不需要 new 一個物件實例就可以使用，靜態方法的特色是無需使用任何建構子中的 this 資料就可以直接使用。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>建構子方法</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> someone = {</span><br><span class=\"line\">  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Adam'</span>,</span><br><span class=\"line\">  <span class=\"hljs-attr\">carrer</span>: <span class=\"hljs-string\">'teacher'</span>,</span><br><span class=\"line\">  <span class=\"hljs-attr\">sex</span>: <span class=\"hljs-string\">'male'</span></span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> dataKeys = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(someone);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dataKeys);</span><br><span class=\"line\"><span class=\"hljs-comment\">// [\"name\",\"carrer\",\"sex\"]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Instance-methods\"><a href=\"#Instance-methods\" class=\"headerlink\" title=\"Instance methods\"></a>Instance methods</h3><h4 id=\"等號賦值-實例化方法\"><a href=\"#等號賦值-實例化方法\" class=\"headerlink\" title=\"等號賦值 實例化方法\"></a>等號賦值 實例化方法</h4><p>以下則是呼叫 Array 的實例化 push 方法，雖然也不是透過 new 來建立一個陣列，卻也是使用賦值一個陣列來建立陣列的實例，並且使用原生 push 方法。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>實例化方法 - 賦值</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> friends = [ <span class=\"hljs-string\">'Cally'</span>, <span class=\"hljs-string\">'Donna'</span>, <span class=\"hljs-string\">'Jell'</span> ];</span><br><span class=\"line\">friends.<span class=\"title function_\">push</span>(<span class=\"hljs-string\">'Liang'</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(friends);</span><br><span class=\"line\"><span class=\"hljs-comment\">// [\"Cally\",\"Donna\",\"Jell\",\"Liang\"]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"建構器-實例化方法\"><a href=\"#建構器-實例化方法\" class=\"headerlink\" title=\"建構器 實例化方法\"></a>建構器 實例化方法</h4><p>透過 new 來建立一個陣列。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>實例化方法 - 構造器</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> animals = <span class=\"hljs-keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"hljs-string\">'bunny'</span>, <span class=\"hljs-string\">'cat'</span>, <span class=\"hljs-string\">'puppy'</span>, <span class=\"hljs-string\">'hamster'</span>);</span><br><span class=\"line\">animals.<span class=\"title function_\">unshift</span>(<span class=\"hljs-string\">'bird'</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(animals);</span><br><span class=\"line\"><span class=\"hljs-comment\">// [\"bird\",\"bunny\",\"cat\",\"puppy\",\"hamster\"]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"構造器靜態方法補充\"><a href=\"#構造器靜態方法補充\" class=\"headerlink\" title=\"構造器靜態方法補充\"></a>構造器靜態方法補充</h2><h4 id=\"無法取得構造器的this資料\"><a href=\"#無法取得構造器的this資料\" class=\"headerlink\" title=\"無法取得構造器的this資料\"></a>無法取得構造器的this資料</h4><blockquote><ul>\n<li>The static method also cannot see the instance variable state so if we try to call the nonstatic method from the static method compiler will complain.</li>\n<li>The static method can be used to create utility functions.<br><a href=\"https://www.educba.com/javascript-static-method/\">https://www.educba.com/javascript-static-method/</a></li>\n</ul>\n</blockquote>\n\n<p>從上述可以得知靜態方法是不能取用構造器建構子（constructor）內的變數的（this binding），通常會撰寫純函式（pure function）以保持無狀態的特性，如同 Math 方法。<br>靜態方法適合用來當作全局複用的函式，適合較無副作用的邏輯。</p>\n<h2 id=\"兩種方法的原型鍊關係\"><a href=\"#兩種方法的原型鍊關係\" class=\"headerlink\" title=\"兩種方法的原型鍊關係\"></a>兩種方法的原型鍊關係</h2><p>若展開一個實例化的物件，會發現：</p>\n<ol>\n<li>建構器方法存在於建構子物件中（constructor），且只能透過建構器呼叫，例如 Object.assign()；</li>\n<li>實例化方法則存在於原型上（prototype），需要實例化之後才能呼叫，例如 objInstance.toLocaleString()</li>\n</ol>\n</body></html>",
            "tags": [
                "javascript",
                "constructor",
                "instance",
                "methods"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/04/24/zh-tw/laravel-migration/",
            "url": "http://maomaoxie.github.io/2022/04/24/zh-tw/laravel-migration/",
            "title": "Laravel 資料庫版控工具 Migration",
            "date_published": "2022-04-24T11:18:30.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/laravel-migration/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"laravel-migration\">\n<p>Migration 位於 Laravel 專案包中的 database 資料夾，會使用建立日期來歸檔資料表的結構，為紀錄資料庫版本的版控，方便團隊共同開發資料表。</p>\n<h1 id=\"建立資料表\"><a href=\"#建立資料表\" class=\"headerlink\" title=\"建立資料表\"></a>建立資料表</h1><figure class=\"highlight javascript hljs\"><figcaption><span>建立 migration</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php artisan <span class=\"hljs-attr\">make</span>:migration create_users_table</span><br></pre></td></tr></tbody></table></figure>\n<p>建立成功會顯示：</p>\n<img src=\"/images/laravel-migration/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"資料庫版控工具 Migration\">\n<p>重整之後會出現新的版控檔案，使用建立日期來命名：</p>\n<img src=\"/images/laravel-migration/2.png\" class=\"\" width=\"300\" height=\"200\" title=\"資料庫版控工具 Migration\">\n<p>檔案內容：</p>\n<img src=\"/images/laravel-migration/3.png\" class=\"\" width=\"800\" height=\"200\" title=\"輸入圖片資料夾名稱\">\n\n<h1 id=\"修改資料表\"><a href=\"#修改資料表\" class=\"headerlink\" title=\"修改資料表\"></a>修改資料表</h1><p>在 <code>\\\\wsl$</code> 路徑下執行 migrate 的坑需要以下步驟：</p>\n<h4 id=\"補上-php-8-0-的-sql-extension\"><a href=\"#補上-php-8-0-的-sql-extension\" class=\"headerlink\" title=\"補上 php 8.0 的 sql-extension\"></a>補上 php 8.0 的 sql-extension</h4><p>於 ubuntu 終端機輸入以下指令：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">輸入code</span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"將註解-extension-x3D-pdo-mysql-打開\"><a href=\"#將註解-extension-x3D-pdo-mysql-打開\" class=\"headerlink\" title=\"將註解 ;extension=pdo_mysql 打開\"></a>將註解 ;extension=pdo_mysql 打開</h4></body></html>",
            "tags": [
                "laravel",
                "migration",
                "sql"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/04/24/zh-tw/laravel-tailwind/",
            "url": "http://maomaoxie.github.io/2022/04/24/zh-tw/laravel-tailwind/",
            "title": "在 Laravel 專案導入 tailwind css",
            "date_published": "2022-04-24T08:47:56.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/laravel-tailwind/0.jpg\" class=\"\" width=\"800\" height=\"200\" title=\"在 Laravel 專案導入 tailwind css\">\n<p>導入 tailwind css 之前有幾個與 Laravel 執行環境有關的雷需要注意：</p>\n<h1 id=\"前情提要\"><a href=\"#前情提要\" class=\"headerlink\" title=\"前情提要\"></a>前情提要</h1><p>將 Laravel 專案放置在 <code>\\\\wsl$</code> 路徑內可以更有效率的執行 WSL2，跑起來的速度也快，不過要注意專案環境包相關聯的耦合性，例如 Docker 設定、php 版本對於某些指令的支援度。</p>\n<blockquote class=\"colorquote info\"><p>以下網址介紹了 WSL2 建置的專案具體位置究竟在哪：<br><a href=\"https://solidstudio.io/blog/windows-subsystem-for-linux-explained\">https://solidstudio.io/blog/windows-subsystem-for-linux-explained</a></p>\n</blockquote>\n<p>由於在 windows 系統中建置 Laravel 需要 Linux 子系統 WSL2 的支持，而使用 artisan 相關的指令都建是使用 Windows Terminal 下的 ubuntu 終端機會更友善些：</p>\n<blockquote class=\"colorquote info\"><p>There is however one great application that makes running the WSL console easier. It’s Windows Terminal and it can be installed from Windows Store. It automatically detects any WSL distributions installed and adds an option to run its console.</p>\n</blockquote>\n<p>至於為什麼要使用 Windows Terminal? 以上說明了<strong>自動偵測 WSL分佈</strong>的功能，當你打開終端機會發現他自動偵測到你使用 WSL 建置該專案包的路徑，甚至在終端機輸入 wsl 就能直接切換該系統環境。</p>\n<h3 id=\"系統包補丁\"><a href=\"#系統包補丁\" class=\"headerlink\" title=\"系統包補丁\"></a>系統包補丁</h3><p>由於每個終端機的環境檔案包是沒有共享的，你在 powershell 很開心的安裝了一包 php，之後當你切換到 ubuntu 會發現，php 指令居然找不到?? 因為你得重裝，導入 tailwind 至 WSL 專案需要補上：</p>\n<h4 id=\"node-js\"><a href=\"#node-js\" class=\"headerlink\" title=\"node.js\"></a>node.js</h4><p>安裝 node 在 ubuntu的步驟</p>\n<ol>\n<li><p>新增Node.js PPA</p>\n<blockquote class=\"colorquote info\"><p>PPA 有點像是系統軟體包的 package.json，記錄著軟體及其版本信息，當你運行 sudo apt update 命令時 apt 工具會根據 /etc/apt 目錄中的 sources.list 文件來決定版本是否升級。</p>\n</blockquote>\n<figure class=\"highlight javascript hljs\"><figcaption><span>安裝 node PPA</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install curl</span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight javascript hljs\"><figcaption><span>安裝 LTS 版本</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -sL <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//deb.nodesource.com/setup_12.x | sudo -E bash -</span></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>安裝Node.js</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>安裝 Node.js 至 Ubuntu</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install nodejs</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>查看一下版本號確保安裝成功</p>\n</li>\n</ol>\n<h1 id=\"安裝-tailwind-css\"><a href=\"#安裝-tailwind-css\" class=\"headerlink\" title=\"安裝 tailwind css\"></a>安裝 tailwind css</h1><p>至 vscode terminal 或者使用 windows terminal Ubuntu 都可以安裝 tailwind css：</p>\n<h3 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h3><figure class=\"highlight javascript hljs\"><figcaption><span>安裝 tailwind</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -D tailwindcss postcss autoprefixer</span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight javascript hljs\"><figcaption><span>安裝Node.js至Ubuntu</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx tailwindcss init</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"修改-config-加入-plugin\"><a href=\"#修改-config-加入-plugin\" class=\"headerlink\" title=\"修改 config 加入 plugin\"></a>修改 config 加入 plugin</h3><figure class=\"highlight javascript hljs\"><figcaption><span>webpack.mix.js</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mix.<span class=\"title function_\">js</span>(<span class=\"hljs-string\">\"resources/js/app.js\"</span>, <span class=\"hljs-string\">\"public/js\"</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">postCss</span>(<span class=\"hljs-string\">\"resources/css/app.css\"</span>, <span class=\"hljs-string\">\"public/css\"</span>, [\t</span><br><span class=\"line\">    <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"tailwindcss\"</span>), <span class=\"hljs-comment\">// &lt;-- 加入這行</span></span><br><span class=\"line\">  ]);</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"導入全域-css\"><a href=\"#導入全域-css\" class=\"headerlink\" title=\"導入全域 css\"></a>導入全域 css</h3><p>在 <code>resources/css/app.css</code> 檔案中加入以下：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>resources/css/app.css</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@tailwind base;</span><br><span class=\"line\">@tailwind components;</span><br><span class=\"line\">@tailwind utilities;</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"設定-tailwind-config-js\"><a href=\"#設定-tailwind-config-js\" class=\"headerlink\" title=\"設定 tailwind.config.js\"></a>設定 tailwind.config.js</h3><figure class=\"highlight javascript hljs\"><figcaption><span>resources/css/app.css</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = { </span><br><span class=\"line\">  <span class=\"hljs-attr\">content</span>: [\t</span><br><span class=\"line\">    <span class=\"hljs-string\">\"./resources/**/*.blade.php\"</span>,  </span><br><span class=\"line\">    <span class=\"hljs-string\">\"./resources/**/*.js\"</span>,\t</span><br><span class=\"line\">    <span class=\"hljs-string\">\"./resources/**/*.vue\"</span>,  ],</span><br><span class=\"line\">  <span class=\"hljs-attr\">theme</span>: {\t</span><br><span class=\"line\">    <span class=\"hljs-attr\">extend</span>: {},</span><br><span class=\"line\">  }, </span><br><span class=\"line\">  <span class=\"hljs-attr\">plugins</span>: [],</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"npm-install-將-mix-module-裝上\"><a href=\"#npm-install-將-mix-module-裝上\" class=\"headerlink\" title=\"npm install 將 mix module 裝上\"></a>npm install 將 mix module 裝上</h3><p>mix 指令可以打包 tailwind css 的預處理器編譯為 css，但不會自動安裝，需要 npm install：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"驗證是否成功\"><a href=\"#驗證是否成功\" class=\"headerlink\" title=\"驗證是否成功\"></a>驗證是否成功</h3><ol>\n<li><p>在 views/layout/layout.blade.php 檔案導入全域 css：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link href=<span class=\"hljs-string\">\"{{ asset('css/app.css') }}\"</span> rel=<span class=\"hljs-string\">\"stylesheet\"</span>&gt;</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>加上 tailwind css 的 class</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>resources/css/app.css</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@tailwind base;</span><br><span class=\"line\">@tailwind components;</span><br><span class=\"line\">@tailwind utilities;</span><br><span class=\"line\"></span><br><span class=\"line\">.<span class=\"hljs-property\">btn</span>-primary {</span><br><span class=\"line\">  @apply py-<span class=\"hljs-number\">2</span> px-<span class=\"hljs-number\">4</span> bg-blue-<span class=\"hljs-number\">500</span> text-white font-semibold rounded-lg shadow-md <span class=\"hljs-attr\">hover</span>:bg-blue-<span class=\"hljs-number\">700</span> <span class=\"hljs-attr\">focus</span>:outline-none <span class=\"hljs-attr\">focus</span>:ring-<span class=\"hljs-number\">2</span> <span class=\"hljs-attr\">focus</span>:ring-blue-<span class=\"hljs-number\">400</span> <span class=\"hljs-attr\">focus</span>:ring-opacity-<span class=\"hljs-number\">75</span> transition-all;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>套用在 blade 檔案中</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>welcome.blade.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"title function_\">section</span>(<span class=\"hljs-string\">'content'</span>)</span><br><span class=\"line\">  &lt;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"container mx-auto\"</span>&gt;</span><br><span class=\"line\">    <span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello you!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    <span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"flex flex-wrap\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"md:w-3/4.w-full\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"w-16 md:w-32 lg:w-48 transition-all bg-fuchsia-300 hover:bg-fuchsia-600 py-5 text-pink-800\"</span>&gt;</span>123<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn-primary\"</span>&gt;</span>My button<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"md:w-1/4.w-full\"</span>&gt;</span>aside<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">@endsection</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>mix 指令打包</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run mix</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>成功導入畫面</p>\n<img src=\"/images/laravel-tailwind/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"tailwind 打包成功畫面\">\n<img src=\"/images/laravel-tailwind/2.png\" class=\"\" width=\"800\" height=\"200\" title=\"tailwind 打包成功畫面\"></li>\n</ol>\n</body></html>",
            "tags": [
                "laravel",
                "tailwind"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/04/10/zh-tw/laravel-routes-namespace/",
            "url": "http://maomaoxie.github.io/2022/04/10/zh-tw/laravel-routes-namespace/",
            "title": "Laravel 命名路由",
            "date_published": "2022-04-10T10:42:15.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/laravel-routes-namespace/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"Laravel 命名路由\">\n<p>當路由越來越多，也越複雜甚至有巢狀結構的時候，相對路徑就會變得複雜不直覺，這時候可以借用 laravel 的命名路由工具，以及 blade 引擎的 <code>route 方法</code> 來輕鬆渲染路由：</p>\n<h1 id=\"命名路由\"><a href=\"#命名路由\" class=\"headerlink\" title=\"命名路由\"></a>命名路由</h1><p>在路由檔案 <code>routes/web.php</code> 中訪問 <code>name</code> 屬性方法並傳入制定好的路由專屬名稱：</p>\n<figure class=\"highlight php hljs\"><figcaption><span>web.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Route</span>::<span class=\"title function_ invoke__\">get</span>(<span class=\"hljs-string\">'/'</span>, [home<span class=\"title class_\">Controller</span>::<span class=\"variable language_\">class</span>, <span class=\"hljs-string\">'index'</span>])-&gt;<span class=\"title function_ invoke__\">name</span>(<span class=\"hljs-string\">'index.index'</span>);</span><br><span class=\"line\"><span class=\"title class_\">Route</span>::<span class=\"title function_ invoke__\">get</span>(<span class=\"hljs-string\">'/about/about'</span>, [home<span class=\"title class_\">Controller</span>::<span class=\"variable language_\">class</span>, <span class=\"hljs-string\">'about'</span>])-&gt;<span class=\"title function_ invoke__\">name</span>(<span class=\"hljs-string\">'index.about'</span>);</span><br></pre></td></tr></tbody></table></figure>\n\n<hr>\n<h1 id=\"blade-檔案渲染路由\"><a href=\"#blade-檔案渲染路由\" class=\"headerlink\" title=\"blade 檔案渲染路由\"></a>blade 檔案渲染路由</h1><p>將制定好的路由名稱由 name 方法傳入、blade 引擎透過 route 方法接收：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>layout/layout.blade.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">&lt;a href=<span class=\"hljs-string\">\"{{ route('index.index') }}\"</span> <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"underline\"</span>&gt;<span class=\"title class_\">Home</span>&lt;/a&gt;|</span><br><span class=\"line\"><span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"{{ route('index.about') }}\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"underline\"</span>&gt;</span>About<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></span></span><br><span class=\"line\">...</span><br></pre></td></tr></tbody></table></figure>\n<img src=\"/images/laravel-routes-namespace/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"Laravel 命名路由\">\n\n<p>修改路由結構測試抓取的正確性：</p>\n<figure class=\"highlight php hljs\"><figcaption><span>web.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Route</span>::<span class=\"title function_ invoke__\">get</span>(<span class=\"hljs-string\">'/'</span>, [home<span class=\"title class_\">Controller</span>::<span class=\"variable language_\">class</span>, <span class=\"hljs-string\">'index'</span>])-&gt;<span class=\"title function_ invoke__\">name</span>(<span class=\"hljs-string\">'index.index'</span>);</span><br><span class=\"line\"><span class=\"title class_\">Route</span>::<span class=\"title function_ invoke__\">get</span>(<span class=\"hljs-string\">'/about'</span>, [home<span class=\"title class_\">Controller</span>::<span class=\"variable language_\">class</span>, <span class=\"hljs-string\">'about'</span>])-&gt;<span class=\"title function_ invoke__\">name</span>(<span class=\"hljs-string\">'index.about'</span>);</span><br></pre></td></tr></tbody></table></figure>\n\n<p>可以看到渲染結果如預期更新了：</p>\n<img src=\"/images/laravel-routes-namespace/2.png\" class=\"\" width=\"800\" height=\"200\" title=\"Laravel 命名路由\">\n\n<p>透過 blade 引擎封裝的 <code>route 方法</code> 解決了在腦中思考相對路徑結構的煩惱，棒！</p>\n</body></html>",
            "tags": [
                "laravel",
                "php"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/04/10/zh-tw/php-basic-knowledge/",
            "url": "http://maomaoxie.github.io/2022/04/10/zh-tw/php-basic-knowledge/",
            "title": "Php 基礎知識",
            "date_published": "2022-04-10T10:10:18.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/php-basic-knowledge/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"php 基礎知識\">\n<p>在 javascript 裡面訪問屬性的方式很單純，都是使用 <code>.</code> 來進入傳參考的對象記憶體中存放的值、訪問類中的屬性還有創立物件內的 key 與 value，然而在 php 中則用三種不同的符號來達成不同目的：</p>\n<h3 id=\"範圍解析操作符\"><a href=\"#範圍解析操作符\" class=\"headerlink\" title=\":: 範圍解析操作符\"></a>:: 範圍解析操作符</h3><p>用來訪問類（class）底下的對象。</p>\n<figure class=\"highlight php hljs\"><figcaption><span>layout/layout.blade.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-variable\">$classname</span>::<span class=\"variable constant_\">CONST_VALUE</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"gt-指向符號（瘦箭頭）\"><a href=\"#gt-指向符號（瘦箭頭）\" class=\"headerlink\" title=\"-> 指向符號（瘦箭頭）\"></a>-&gt; 指向符號（瘦箭頭）</h3><p>用來訪問物件內某類別的值，類似 javascript 裡頭的 <code>.</code>。 </p>\n<figure class=\"highlight php hljs\"><figcaption><span>layout/layout.blade.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-variable\">$object</span>-&gt;property=<span class=\"hljs-string\">'value'</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"x3D-gt-指向符號（胖箭頭）\"><a href=\"#x3D-gt-指向符號（胖箭頭）\" class=\"headerlink\" title=\"=> 指向符號（胖箭頭）\"></a>=&gt; 指向符號（胖箭頭）</h3><p>用來創建物件內的鍵值對，一個 key 對上一個 value，類似 javascript 裡頭的 <code>:</code>。 </p>\n<figure class=\"highlight php hljs\"><figcaption><span>layout/layout.blade.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-variable\">$array</span> = <span class=\"hljs-keyword\">array</span>(<span class=\"hljs-string\">\"key\"</span> =&gt; <span class=\"hljs-string\">\"value\"</span>);</span><br></pre></td></tr></tbody></table></figure></body></html>",
            "tags": [
                "php"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/04/10/zh-tw/laravel-public/",
            "url": "http://maomaoxie.github.io/2022/04/10/zh-tw/laravel-public/",
            "title": "Laravel public 靜態檔案",
            "date_published": "2022-04-10T09:11:18.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/laravel-public/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"Laravel public 靜態檔案\">\n<p>雖然檔案打包是現今網頁開發的趨勢，但網站難免需要引用未經編譯的靜態檔案，以避免編譯後的亂數檔名都要經過打包程序才能使用，Laravel 專案包中的 <code>public</code> 資料夾就是靜態檔案的去處，與之相對應會被壓縮及打包的動態檔案則要放置在 <code>resources</code> 資料中：</p>\n<h1 id=\"靜態-css-檔案\"><a href=\"#靜態-css-檔案\" class=\"headerlink\" title=\"靜態 css 檔案\"></a>靜態 css 檔案</h1><p>在 public/css/style.css 存放網站的主要設計檔，並且在主模板 <code>resources/views/layout/layout.blade.php</code> 中引用該靜態檔案之路徑在 <code>&lt;link&gt;</code> 中：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>layout/layout.blade.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  <span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">\"stylesheet\"</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"css/style.css\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">  ...</span></span><br><span class=\"line\"><span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>\n<p>但問題來了！當路由來到巢狀或雙層的時候，絕對路徑的悲劇就會發生，若我們將路由改成：</p>\n<figure class=\"highlight php hljs\"><figcaption><span>web.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Route</span>::<span class=\"title function_ invoke__\">get</span>(<span class=\"hljs-string\">'/about/about'</span>, [home<span class=\"title class_\">Controller</span>::<span class=\"variable language_\">class</span>, <span class=\"hljs-string\">'about'</span>]);</span><br></pre></td></tr></tbody></table></figure>\n<img src=\"/images/laravel-public/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"Laravel public 靜態檔案\">\n<p>你會看到 css 檔案的路徑改變成 <code>http://localhost:3000/about/css/style.css</code>，因為找不到 about 底下的 css 檔案，所以整個 style 返回 404：</p>\n<img src=\"/images/laravel-public/2.png\" class=\"\" width=\"800\" height=\"200\" title=\"Laravel public 靜態檔案\">\n\n<hr>\n<h1 id=\"url-function\"><a href=\"#url-function\" class=\"headerlink\" title=\"url function\"></a>url function</h1><p>你想到的問題 Laravel 怎麼會漏掉？這時候可以使用 blade 模板引擎包裝好的 <code>url 方法</code>，傳入相對靜態檔案路徑當參數,，來抓取靜態檔案的正確路徑：</p>\n<figure class=\"highlight php hljs\"><figcaption><span>layout/layout.blade.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=<span class=\"hljs-string\">\"stylesheet\"</span> href=<span class=\"hljs-string\">\"{{ url('css/style.css') }}\"</span>&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>運作正常：</p>\n<img src=\"/images/laravel-public/3.png\" class=\"\" width=\"800\" height=\"200\" title=\"Laravel public 靜態檔案\">\n\n\n</body></html>",
            "tags": [
                "laravel",
                "public",
                "static"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/04/10/zh-tw/laravel-layout/",
            "url": "http://maomaoxie.github.io/2022/04/10/zh-tw/laravel-layout/",
            "title": "Laravel 善用 layout 避免重複的模板",
            "date_published": "2022-04-10T06:54:20.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/laravel-layout/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"laravel-layout\">\n\n<p>在設計 UI 模板時重複使用的內容屢見不鮮，例如 header、footer 或是 sidebar 等多是網站中分頁裡的標配，這時候重複貼上一樣的模板就顯得有點呆，Laravel MVC 架構中 views 可以創建一個 layout 模板資料夾，重複的 UI 配置可以放置在這裡提供其他分頁的 blade 檔案使用，這樣一來也能省去 layout 修改時相關的檔案都要更改的麻煩事，統一在 layout 裡調整即可：</p>\n<h1 id=\"建立-layout-資料夾\"><a href=\"#建立-layout-資料夾\" class=\"headerlink\" title=\"建立 layout 資料夾\"></a>建立 layout 資料夾</h1><p>此資料夾可以存放共用的模板，例如 header、footer 或是 sidebar 的模板 html。<br>在 project 裡的 <code>resources/views</code> 建立一個 layout 資料夾：</p>\n<img src=\"/images/laravel-layout/1.png\" class=\"\" width=\"300\" height=\"200\" title=\"laravel-layout\">\n<hr>\n<h1 id=\"撰寫模板\"><a href=\"#撰寫模板\" class=\"headerlink\" title=\"撰寫模板\"></a>撰寫模板</h1><p>確立好 controller 中與 views 與 routes 的連結後，就可以著手進行模板的拆分啦！</p>\n<h3 id=\"extends-‘layoutFolder-x2F-layout’\"><a href=\"#extends-‘layoutFolder-x2F-layout’\" class=\"headerlink\" title=\"@extends(‘layoutFolder/layout’)\"></a>@extends(‘layoutFolder/layout’)</h3><p>承接共用模板的其他 views 則使用此語法接收模板，撰寫資料夾路徑方式有兩種：</p>\n<ol>\n<li>斜線</li>\n<li>點</li>\n</ol>\n<figure class=\"highlight javascript hljs\"><figcaption><span>about.blade.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"title function_\">extends</span>(<span class=\"hljs-string\">'layout.layout'</span>)</span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight javascript hljs\"><figcaption><span>about.blade.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"title function_\">extends</span>(<span class=\"hljs-string\">'layout/layout'</span>)</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"yield-‘content’\"><a href=\"#yield-‘content’\" class=\"headerlink\" title=\"@yield(‘content’)\"></a>@yield(‘content’)</h3><p>yield 像是在告訴 php 說我這裡需要挖個洞，待會會丟 html 進來，請認名稱來辨識丟進來的檔案：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>layout/layout.blade.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">很多要共用的 html</span><br><span class=\"line\">...(通常是 header)</span><br><span class=\"line\">@<span class=\"title function_\">yield</span>(<span class=\"hljs-string\">'content'</span>)</span><br><span class=\"line\">很多要共用的 html</span><br><span class=\"line\">...(通常是 footer)</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"section-‘content’-…-endsection\"><a href=\"#section-‘content’-…-endsection\" class=\"headerlink\" title=\"@section(‘content’) … @endsection\"></a>@section(‘content’) … @endsection</h3><p>section 類似 vue 的 slot，把其他網頁要替換的內容插入這個插槽中，在通過剛才的 <code>@yield('content')</code> 將page愈替換的內容塞進去共用的模板中：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>page.blade.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"title function_\">extends</span>(<span class=\"hljs-string\">'layout/layout'</span>)</span><br><span class=\"line\">@<span class=\"title function_\">section</span>(<span class=\"hljs-string\">'content'</span>)</span><br><span class=\"line\">  這裡是 page content</span><br><span class=\"line\">  ...</span><br><span class=\"line\">@endsection</span><br></pre></td></tr></tbody></table></figure>\n<img src=\"/images/laravel-layout/3.png\" class=\"\" width=\"800\" height=\"200\" title=\"laravel-layout\">\n<img src=\"/images/laravel-layout/2.png\" class=\"\" width=\"800\" height=\"200\" title=\"laravel-layout\">\n<hr>\n<h1 id=\"獨立每個頁面的-script\"><a href=\"#獨立每個頁面的-script\" class=\"headerlink\" title=\"獨立每個頁面的 script\"></a>獨立每個頁面的 script</h1><p>插槽的概念同樣可以挖洞給每個獨立頁面放置專屬的 javascript，在 layout 的  之前放置 @yield(‘after_js’) 來承接 page 各自的 <code>&lt;script&gt;...&lt;/script&gt;</code>：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>layout/layout.blade.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  @<span class=\"title function_\">yield</span>(<span class=\"hljs-string\">'after_js'</span>)</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight javascript hljs\"><figcaption><span>page.blade.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"title function_\">section</span>(<span class=\"hljs-string\">'content'</span>)</span><br><span class=\"line\">  &lt;script&gt;</span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(<span class=\"hljs-string\">\"Hey!It's about page.\"</span>);</span><br><span class=\"line\">  &lt;/script&gt;</span><br><span class=\"line\">@endsection</span><br></pre></td></tr></tbody></table></figure>\n<img src=\"/images/laravel-layout/4.png\" class=\"\" width=\"800\" height=\"200\" title=\"laravel-layout\">\n<hr>\n<h1 id=\"簡化-section\"><a href=\"#簡化-section\" class=\"headerlink\" title=\"簡化 @section\"></a>簡化 @section</h1><p>每個頁面會有不同的 SEO 內容，例如 <code>title</code> 或是其他的 meta data，這時候 <code>@section</code> 又派上用場了，不同的是<strong>第二個參數</strong>可以傳入文字檔來渲染內容：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>layout/layout.blade.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  <span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>@yield('title')<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    ...</span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span></span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight javascript hljs\"><figcaption><span>page.blade.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"title function_\">section</span>(<span class=\"hljs-string\">'title'</span>, <span class=\"hljs-string\">'pageTitle'</span>)</span><br></pre></td></tr></tbody></table></figure>\n<img src=\"/images/laravel-layout/5.png\" class=\"\" width=\"300\" height=\"200\" title=\"laravel-layout\">\n<img src=\"/images/laravel-layout/6.png\" class=\"\" width=\"300\" height=\"200\" title=\"laravel-layout\">\n\n<hr>\n<blockquote><p>參考資料：<br><a href=\"https://www.youtube.com/watch?v=AGE3wRKljkw&amp;t=2402s\">https://www.youtube.com/watch?v=AGE3wRKljkw&amp;t=2402s</a></p>\n</blockquote></body></html>",
            "tags": [
                "laravel",
                "blade",
                "layout"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/04/06/zh-tw/laravel-routes-controller/",
            "url": "http://maomaoxie.github.io/2022/04/06/zh-tw/laravel-routes-controller/",
            "title": "Laravel 認識 controller",
            "date_published": "2022-04-06T13:49:05.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/laravel-routes-controller/0.png\" class=\"laravel-routes\" width=\"800\" height=\"200\" title=\"Laravel路由控制器\">\n<p>當路由越來越多越來越雜亂的時候，express 可以模組化路由以分類各大項目的小路由，Laravel 是基於 MVC 架構的應用程式框架，這個分類工作可以交給 <strong>Controller</strong> 來執行：</p>\n<h1 id=\"init-controller\"><a href=\"#init-controller\" class=\"headerlink\" title=\"init controller\"></a>init controller</h1><p>使用優雅的 <code>artisan cmd</code> 就可以創建一個 Controller class 模板，在 windows powerShell 輸入<code>wsl</code> 即可切換至 Linux WSL 子系統，終端機輸入以下指令可以查詢所有 artisan cmd 的說明，記得 cd 進入專案包內才可使用 artisan 指令：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>terminal</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php artisan</span><br></pre></td></tr></tbody></table></figure>\n<img src=\"/images/laravel-routes-controller/1.png\" class=\"laravel-routes\" width=\"800\" height=\"200\" title=\"Laravel路由控制器\">\n\n<p>建立 Controller 模板的 artisan cmd：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>terminal</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php artisan <span class=\"hljs-attr\">make</span>:controller homeController</span><br></pre></td></tr></tbody></table></figure>\n<img src=\"/images/laravel-routes-controller/2.png\" class=\"laravel-routes\" width=\"800\" height=\"200\" title=\"Laravel路由控制器\">\n\n<h1 id=\"撰寫-Controller\"><a href=\"#撰寫-Controller\" class=\"headerlink\" title=\"撰寫 Controller\"></a>撰寫 Controller</h1><p>使用<strong>路由名稱</strong>創建 function 並且制定渲染內容，連接 Views：</p>\n<figure class=\"highlight php hljs\"><figcaption><span>App/Https/Controllers/homeController.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-meta\">&lt;?php</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">namespace</span> <span class=\"title class_\">App</span>\\<span class=\"title class_\">Http</span>\\<span class=\"title class_\">Controllers</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">use</span> <span class=\"hljs-title\">Illuminate</span>\\<span class=\"hljs-title\">Http</span>\\<span class=\"hljs-title\">Request</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">homeController</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Controller</span></span></span><br><span class=\"line\"><span class=\"hljs-class\"></span>{</span><br><span class=\"line\">  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">index</span> (<span class=\"hljs-params\"></span>) </span>{</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> <span class=\"title function_ invoke__\">view</span>(<span class=\"hljs-string\">'welcome'</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"hljs-comment\">// 參數要記得帶</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dog</span> (<span class=\"hljs-params\"><span class=\"hljs-variable\">$dogName</span></span>) </span>{</span><br><span class=\"line\">    <span class=\"hljs-variable\">$datas</span> = [</span><br><span class=\"line\">      <span class=\"hljs-string\">\"name\"</span> =&gt; <span class=\"hljs-string\">\"Abby\"</span>,</span><br><span class=\"line\">      <span class=\"hljs-string\">\"dogName\"</span> =&gt; <span class=\"hljs-variable\">$dogName</span></span><br><span class=\"line\">    ];</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> <span class=\"title function_ invoke__\">view</span>(<span class=\"hljs-string\">'routesTest'</span>, <span class=\"hljs-variable\">$datas</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<blockquote class=\"colorquote info\"><p>記得將應用到的動態參數一並移植到 Controller 的 function arguments 中！</p>\n</blockquote>\n\n<h1 id=\"對應-Routes-字串\"><a href=\"#對應-Routes-字串\" class=\"headerlink\" title=\"對應 Routes 字串\"></a>對應 Routes 字串</h1><p>將路由路徑制定好並且傳入陣列參數：</p>\n<ol>\n<li><code>use</code> 剛才創建的 Controller 檔案</li>\n<li>索引<code>[0]</code>放置 <code>ControllerName::class</code></li>\n<li>索引<code>[1]</code>放置對應 <code>function</code>：<figure class=\"highlight php hljs\"><figcaption><span>routes/web.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-meta\">&lt;?php</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">use</span> <span class=\"hljs-title\">Illuminate</span>\\<span class=\"hljs-title\">Support</span>\\<span class=\"hljs-title\">Facades</span>\\<span class=\"hljs-title\">Route</span>;</span><br><span class=\"line\"><span class=\"hljs-keyword\">use</span> <span class=\"hljs-title\">App</span>\\<span class=\"hljs-title\">Http</span>\\<span class=\"hljs-title\">Controllers</span>\\<span class=\"hljs-title\">homeController</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Route</span>::<span class=\"title function_ invoke__\">get</span>(<span class=\"hljs-string\">'/'</span>, [home<span class=\"title class_\">Controller</span>::<span class=\"variable language_\">class</span>, <span class=\"hljs-string\">'index'</span>]);</span><br><span class=\"line\"><span class=\"title class_\">Route</span>::<span class=\"title function_ invoke__\">get</span>(<span class=\"hljs-string\">'/dog/{dogName}'</span>, [home<span class=\"title class_\">Controller</span>::<span class=\"variable language_\">class</span>, <span class=\"hljs-string\">'dog'</span>]);</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<p>渲染結果：</p>\n<img src=\"/images/laravel-routes-controller/3.png\" class=\"laravel-routes\" width=\"800\" height=\"200\" title=\"Laravel路由控制器\">\n<img src=\"/images/laravel-routes-controller/4.png\" class=\"laravel-routes\" width=\"500\" height=\"200\" title=\"Laravel路由控制器\">\n\n<p>以上就是 Controller 的常見功能。</p>\n</body></html>",
            "tags": [
                "laravel",
                "php"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/04/04/zh-tw/laravel-routes/",
            "url": "http://maomaoxie.github.io/2022/04/04/zh-tw/laravel-routes/",
            "title": "Laravel 認識路由",
            "date_published": "2022-04-04T07:41:43.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/laravel-routes/0.png\" class=\"laravel-routes\" width=\"800\" height=\"200\" title=\"Laravel路由介紹\">\n<p>應用程式介面的主要目的就是提供使用者與介面互動（Interaction），其中 URL 可以取得使用者的資訊並且渲染在畫面中，例如 query string，就是透過最基本的 GET request 來獲取信息：</p>\n<hr>\n<h1 id=\"routes\"><a href=\"#routes\" class=\"headerlink\" title=\"routes\"></a>routes</h1><p>在路由頁面設定想要回應到前端的資訊，有幾種方式：</p>\n<h3 id=\"simple-data\"><a href=\"#simple-data\" class=\"headerlink\" title=\"simple data\"></a>simple data</h3><p>回傳簡單的關聯式陣列：</p>\n<blockquote class=\"colorquote info\"><p>關聯式陣列可以想做類似 javascript 的物件一樣，鍵值對（key-value pair）的形式．</p>\n</blockquote>\n\n<figure class=\"highlight php hljs\"><figcaption><span>routes/web.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Route</span>::<span class=\"title function_ invoke__\">get</span>(<span class=\"hljs-string\">'/greetings'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{</span><br><span class=\"line\">  <span class=\"hljs-variable\">$datas</span> = [</span><br><span class=\"line\">    [ </span><br><span class=\"line\">      <span class=\"hljs-string\">\"name\"</span> =&gt; <span class=\"hljs-string\">\"Abby\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ];</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable\">$datas</span>;</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n<img src=\"/images/laravel-routes/1.png\" class=\"laravel-routes\" width=\"500\" height=\"200\" title=\"Laravel路由介紹\">\n<hr>\n<h3 id=\"Views\"><a href=\"#Views\" class=\"headerlink\" title=\"Views\"></a>Views</h3><p>回傳資料至 <code>blade</code> 模板，渲染 html</p>\n<figure class=\"highlight php hljs\"><figcaption><span>routes/web.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Route</span>::<span class=\"title function_ invoke__\">get</span>(<span class=\"hljs-string\">'/greetings'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{</span><br><span class=\"line\">  <span class=\"hljs-variable\">$datas</span> = [</span><br><span class=\"line\">    [ </span><br><span class=\"line\">      <span class=\"hljs-string\">\"name\"</span> =&gt; <span class=\"hljs-string\">\"Abby\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  ];</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> <span class=\"title function_ invoke__\">views</span>(<span class=\"hljs-string\">'greetings'</span>, <span class=\"hljs-variable\">$datas</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n<p>直接將傳遞過來的關聯式陣列 key 傳進來當變數名</p>\n<figure class=\"highlight php hljs\"><figcaption><span>resource/views/greetings.blade.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=<span class=\"hljs-string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">  &lt;meta http-equiv=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> content=<span class=\"hljs-string\">\"IE=edge\"</span>&gt;</span><br><span class=\"line\">  &lt;meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span><br><span class=\"line\">  &lt;title&gt;Greetings&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;h1&gt;Hello! {{ <span class=\"hljs-variable\">$name</span> }}&lt;/h1&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<hr>\n<h3 id=\"query-string-參數\"><a href=\"#query-string-參數\" class=\"headerlink\" title=\"query string　參數\"></a>query string　參數</h3><p>變數也可以使用既有的 <code>request()</code> 方法承接 URL <code>?</code> 後方的 <strong>key</strong> 來渲染到畫面中，讀取 GET 參數：</p>\n<h4 id=\"request\"><a href=\"#request\" class=\"headerlink\" title=\"request()\"></a>request()</h4><figure class=\"highlight php hljs\"><figcaption><span>routes/web.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Route</span>::<span class=\"title function_ invoke__\">get</span>(<span class=\"hljs-string\">'/cat'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 這裡輸入 params key</span></span><br><span class=\"line\">  <span class=\"hljs-variable\">$catNumbers</span> = <span class=\"title function_ invoke__\">request</span>(<span class=\"hljs-string\">'catNumbers'</span>);</span><br><span class=\"line\">  <span class=\"hljs-variable\">$datas</span> = [</span><br><span class=\"line\">    <span class=\"hljs-string\">\"catNumbers\"</span> =&gt; <span class=\"title function_ invoke__\">strip_tags</span>(<span class=\"hljs-variable\">$catNumbers</span>)</span><br><span class=\"line\">  ];</span><br><span class=\"line\">  <span class=\"hljs-comment\">// return \"這裡有${catNumbers}隻貓\";</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> <span class=\"title function_ invoke__\">view</span>(<span class=\"hljs-string\">'cat'</span>, <span class=\"hljs-variable\">$datas</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight php hljs\"><figcaption><span>resource/views/cat.blade.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=<span class=\"hljs-string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">  &lt;meta http-equiv=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> content=<span class=\"hljs-string\">\"IE=edge\"</span>&gt;</span><br><span class=\"line\">  &lt;meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span><br><span class=\"line\">  &lt;title&gt;Cat Route&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;h1&gt;這裡有{{ <span class=\"hljs-variable\">$catNumbers</span> }}隻貓&lt;/h1&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>\n<img src=\"/images/laravel-routes/3.png\" class=\"laravel-routes\" width=\"500\" height=\"200\" title=\"Laravel路由介紹\">\n\n<blockquote class=\"colorquote danger\"><p>為了避免 XSS 攻擊注入惡意程式到 app 中，可以為你的 request 包覆 <code>strip_tags()</code>，動態路由則不需要。</p>\n</blockquote>\n\n<h4 id=\"設置概覽資料\"><a href=\"#設置概覽資料\" class=\"headerlink\" title=\"設置概覽資料\"></a>設置概覽資料</h4><p>若使用者沒有查詢任何關鍵字（例如衣服），可以設立一個預設顯示的資料（例如展示全部商品）：</p>\n<figure class=\"highlight php hljs\"><figcaption><span>routes/web.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Route</span>::<span class=\"title function_ invoke__\">get</span>(<span class=\"hljs-string\">'/cat'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 這裡輸入 params key</span></span><br><span class=\"line\">  <span class=\"hljs-variable\">$catNumbers</span> = <span class=\"title function_ invoke__\">request</span>(<span class=\"hljs-string\">'catNumbers'</span>);</span><br><span class=\"line\">  <span class=\"hljs-comment\">// 有指定的話顯示</span></span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">isset</span>(<span class=\"hljs-variable\">$catNumbers</span>)) {</span><br><span class=\"line\">    <span class=\"hljs-variable\">$datas</span> = [</span><br><span class=\"line\">      <span class=\"hljs-string\">\"catNumbers\"</span> =&gt; <span class=\"title function_ invoke__\">strip_tags</span>(<span class=\"hljs-variable\">$catNumbers</span>)</span><br><span class=\"line\">    ];</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> <span class=\"title function_ invoke__\">view</span>(<span class=\"hljs-string\">'cat'</span>, <span class=\"hljs-variable\">$datas</span>);</span><br><span class=\"line\">  } <span class=\"hljs-keyword\">else</span> {</span><br><span class=\"line\">    <span class=\"hljs-comment\">// 沒指定的話顯示</span></span><br><span class=\"line\">    <span class=\"hljs-variable\">$datas</span> = [</span><br><span class=\"line\">      <span class=\"hljs-string\">\"catNumbers\"</span> =&gt; <span class=\"hljs-string\">'很多'</span></span><br><span class=\"line\">    ];</span><br><span class=\"line\">    <span class=\"hljs-keyword\">return</span> <span class=\"title function_ invoke__\">view</span>(<span class=\"hljs-string\">'cat'</span>, <span class=\"hljs-variable\">$datas</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n<img src=\"/images/laravel-routes/4.png\" class=\"\" width=\"500\" height=\"200\" title=\"laravel路由\">\n\n<blockquote class=\"colorquote info\"><p><code>isset()</code> 方法類似 javascript 的 <code>if (variable === undefined)</code>，判斷某變數是否存在。  </p>\n</blockquote>\n\n<hr>\n<h3 id=\"dynamic-routes\"><a href=\"#dynamic-routes\" class=\"headerlink\" title=\"dynamic routes\"></a>dynamic routes</h3><p>可以渲染使用者輸入的資料，動態路由使用 <code>{}</code> 將路由變數名稱包起，爾後經過 GET URL 的方式取得信息，路由設定需要傳入變數至回呼函式中接收：</p>\n<h4 id=\"範例1-對應的動態路由變數需要傳入回呼函式中\"><a href=\"#範例1-對應的動態路由變數需要傳入回呼函式中\" class=\"headerlink\" title=\"範例1. 對應的動態路由變數需要傳入回呼函式中\"></a>範例1. 對應的動態路由變數需要傳入回呼函式中</h4><figure class=\"highlight php hljs\"><figcaption><span>routes/web.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Route</span>::<span class=\"title function_ invoke__\">get</span>(<span class=\"hljs-string\">'/dog/{dogName}'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"><span class=\"hljs-variable\">$dogName</span></span>) </span>{</span><br><span class=\"line\">  <span class=\"hljs-variable\">$datas</span> = [</span><br><span class=\"line\">    <span class=\"hljs-string\">\"name\"</span> =&gt; <span class=\"hljs-string\">\"Abby\"</span>,</span><br><span class=\"line\">    <span class=\"hljs-string\">\"dogName\"</span> =&gt; <span class=\"hljs-variable\">$dogName</span></span><br><span class=\"line\">  ];</span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> <span class=\"title function_ invoke__\">view</span>(<span class=\"hljs-string\">'routesTest'</span>, <span class=\"hljs-variable\">$datas</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight php hljs\"><figcaption><span>resource/views/greetings.blade.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=<span class=\"hljs-string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=<span class=\"hljs-string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">  &lt;meta http-equiv=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> content=<span class=\"hljs-string\">\"IE=edge\"</span>&gt;</span><br><span class=\"line\">  &lt;meta name=<span class=\"hljs-string\">\"viewport\"</span> content=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span><br><span class=\"line\">  &lt;title&gt;Greetings&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;h1&gt;Hello! {{ <span class=\"hljs-variable\">$name</span> }}&lt;/h1&gt;</span><br><span class=\"line\">  &lt;h2&gt;A dog name {{ <span class=\"hljs-variable\">$dogName</span> }}&lt;/h2&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>\n<img src=\"/images/laravel-routes/2.png\" class=\"laravel-routes\" width=\"500\" height=\"200\" title=\"Laravel路由介紹\">\n\n<h4 id=\"範例2-傳入多個非必要的動態路由參數\"><a href=\"#範例2-傳入多個非必要的動態路由參數\" class=\"headerlink\" title=\"範例2. 傳入多個非必要的動態路由參數\"></a>範例2. 傳入多個非必要的動態路由參數</h4><figure class=\"highlight php hljs\"><figcaption><span>routes/web.php</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Route</span>::<span class=\"title function_ invoke__\">get</span>(<span class=\"hljs-string\">'/shop/{category?}/{item?}'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"><span class=\"hljs-variable\">$a</span> = <span class=\"hljs-literal\">null</span>, <span class=\"hljs-variable\">$b</span> = <span class=\"hljs-literal\">null</span></span>) </span>{</span><br><span class=\"line\">  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">isset</span>(<span class=\"hljs-variable\">$a</span>)) {</span><br><span class=\"line\">    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">isset</span>(<span class=\"hljs-variable\">$b</span>)) {</span><br><span class=\"line\">      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"你正在瀏覽商店${a}分類的${b}品項\"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">  } </span><br><span class=\"line\">  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'你正在瀏覽商店的所有商品'</span>;</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n<blockquote class=\"colorquote info\"><p>對應的回呼函式必須接收一樣數量的變數當參數，名稱隨意不過最好與路由同名比較直覺，且位置要按照順序！<br>非必要的路由參數需要設置：</p>\n<ol>\n<li><code>?</code>放置在<code>{}</code>內，表示為可選的。</li>\n<li>非必要路由參數需設置預設值為空<code>null</code>才不會噴錯。</li>\n</ol>\n</blockquote>\n\n<img src=\"/images/laravel-routes/5.png\" class=\"laravel-routes\" width=\"500\" height=\"200\" title=\"Laravel路由介紹\">\n<img src=\"/images/laravel-routes/6.png\" class=\"laravel-routes\" width=\"500\" height=\"200\" title=\"Laravel路由介紹\">\n</body></html>",
            "tags": [
                "laravel",
                "php"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/04/03/zh-tw/laravel-folder-intro/",
            "url": "http://maomaoxie.github.io/2022/04/03/zh-tw/laravel-folder-intro/",
            "title": "Laravel 專案包初探",
            "date_published": "2022-04-03T11:01:30.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/laravel-folder-intro/0.png\" class=\"Laravel-folder-intro\" width=\"800\" height=\"200\" title=\"Laravel 專案包初探\">\n<p>Laravel 專案包建立好之後，有以下幾個主要的資料夾，一一介紹其作用：</p>\n<blockquote class=\"colorquote info\"><p>先打預防針，其實整個 Larevel 專案包預設並沒有任何 UI 框架，此專案包內名為 bootstrap 的檔案都跟該框架無半點毛關係！不要被混淆了。</p>\n<p>知識小學堂：<br><strong>bootstrap</strong> 的意思為鞋帶，衍生的動詞涵義是<strong>啟動機制</strong>，符合 Laravel 框架中用來充當 <strong>glue</strong> 黏著任何相關檔案或 app 啟動機制的程序。</p>\n</blockquote>\n\n<h1 id=\"vendor\"><a href=\"#vendor\" class=\"headerlink\" title=\"vendor\"></a>vendor</h1><p>Composer 相依套件的目錄，類似 node modules。</p>\n<h1 id=\"app\"><a href=\"#app\" class=\"headerlink\" title=\"app\"></a>app</h1><p>核心的 code 會放在這裡，大部分的類別（class）程式放置處，重要的 MVC 架構中的 <code>Controller</code> 類別會放在 Http/Controllers 資料夾中，以處理 View 與 Model 中間的繫結處理器。</p>\n<h1 id=\"bootstrap\"><a href=\"#bootstrap\" class=\"headerlink\" title=\"bootstrap\"></a>bootstrap</h1><p>這裡的 bootstrap 並非 UI 框架，而是啟動整個 Laravel app 需要使用的元件放置處，增進性能優化的快取設定（cache）會放在這，不需要編寫這邊的檔案。</p>\n<h1 id=\"database\"><a href=\"#database\" class=\"headerlink\" title=\"database\"></a>database</h1><p>Model factories 會放在這裡，亦可處理 database 的遷移。</p>\n<h1 id=\"lang\"><a href=\"#lang\" class=\"headerlink\" title=\"lang\"></a>lang</h1><p>語言的切換檔案。</p>\n<h1 id=\"public\"><a href=\"#public\" class=\"headerlink\" title=\"public\"></a>public</h1><p>網站的靜態檔案如 js、css 及 images 放置處，以及網站的所有入口點（entry points）<code>index.php</code> 與設定自動加載（autoloading）的地方。</p>\n<h1 id=\"resource\"><a href=\"#resource\" class=\"headerlink\" title=\"resource\"></a>resource</h1><p>MVC 架構中的 <code>Views</code> 類別會放在這裡，通常是 <code>blade</code> 模板檔案，也存放一些初胚的、未經壓縮與處理的 js、css 檔案，在網站打包之後會被壓縮並且優化性能，需要 loader 去編譯的檔案可以放在這裡，例如 less 或 sass。</p>\n<h3 id=\"resource-x2F-bootstrap-js\"><a href=\"#resource-x2F-bootstrap-js\" class=\"headerlink\" title=\"resource/bootstrap.js\"></a>resource/bootstrap.js</h3><p>該文件夾底下的 <code>bootstrap.js</code> 檔案並非 UI 框架，而是放置 <code>CSRF Token</code> 自動夾帶在 header 的程序，並且使用 <code>$axios</code> 發送 request 出去，以<strong>避免 XSRF 跨站偽造攻擊</strong>之用！</p>\n<blockquote class=\"colorquote danger\"><p>警告：不想整個 app 掛掉的話請不要亂動我！</p>\n</blockquote>\n\n<h1 id=\"routes\"><a href=\"#routes\" class=\"headerlink\" title=\"routes\"></a>routes</h1><p>路由檔案，預設會有 <code>web.php</code>, <code>api.php</code>, <code>console.php</code>, and <code>channels.php</code> 幾支提供設定，也可以使用 app 裡面的 Controller Class 來渲染路由對應的 view 檔。</p>\n<h3 id=\"routes-x2F-web-php\"><a href=\"#routes-x2F-web-php\" class=\"headerlink\" title=\"routes/web.php\"></a>routes/web.php</h3><p>提供 session state、CSRF 保護與 cookie 加密，可以放置除了 server 提供的 RESTful API 以外的網頁路由設定。</p>\n<h3 id=\"routes-x2F-api-php\"><a href=\"#routes-x2F-api-php\" class=\"headerlink\" title=\"routes/api.php\"></a>routes/api.php</h3><p>API 中介軟體的設定處，是無狀態（stateless）的，所有進入該介面的路由都需要攜帶 Token 認證且無法隨意進入。</p>\n<h3 id=\"routes-x2F-console-php\"><a href=\"#routes-x2F-console-php\" class=\"headerlink\" title=\"routes/console.php\"></a>routes/console.php</h3><p>可以將自定義的指令碼撰寫在這，例如 Artisan 的相關指令。</p>\n<h3 id=\"routes-x2F-channels-php\"><a href=\"#routes-x2F-channels-php\" class=\"headerlink\" title=\"routes/channels.php\"></a>routes/channels.php</h3><p>定義授權請求監聽的邏輯，以註冊相應的回呼函式。</p>\n<h1 id=\"storage\"><a href=\"#storage\" class=\"headerlink\" title=\"storage\"></a>storage</h1><p>放置經過編譯的 blade php 模板，以及快取與其他框架處理過後的檔案，其中<code>storage/app/public</code>路徑放置使用者操作後產生的檔案，例如頭像圖片。</p>\n<h1 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\"config\"></a>config</h1><p>整個網站應用程式的設定檔案，建議熟讀並且活用其中的多樣選擇。可以把一些全域使用的環境變數放置其中。</p>\n<p>參考文章：</p>\n<blockquote><p><a href=\"https://laravel.com/docs/9.x/structure\">https://laravel.com/docs/9.x/structure</a></p>\n</blockquote>\n</body></html>",
            "tags": [
                "laravel",
                "php",
                "linux",
                "blade",
                "wsl2"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/03/12/zh-tw/short-circuit-and-optional-chaining/",
            "url": "http://maomaoxie.github.io/2022/03/12/zh-tw/short-circuit-and-optional-chaining/",
            "title": "短路解析 & 可選鍊修飾符",
            "date_published": "2022-03-12T05:55:02.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/short-circuit-and-optional-chaining/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"短路解析與可選練修飾符\">\n<p>在開發的情境上無論是串接 API 或者是資料判斷，都需要追求便捷而好懂的方式來維護程式碼，以利於當資料判斷變得複雜臃腫時仍可以邏輯清晰。而對於程式新手來說<code>undefined</code>（未定義）、<code>null</code>（空值）或者是<code>0</code>（零）在判斷上是很容易掉進去的陷阱，因為判定的方法了解的不深而陷入困境。</p>\n<h1 id=\"理解真假值\"><a href=\"#理解真假值\" class=\"headerlink\" title=\"理解真假值\"></a>理解真假值</h1><p>先介紹 truthy(真值) 與 falsy(假值)：</p>\n<ul>\n<li>truthy：非 falsy 的值，或者是表達式結果為 <code>true</code></li>\n<li>falsy：<code>undefined</code>、<code>null</code>、非數字 <code>NaN</code>、數字 <code>0</code>、數字 <code>-0</code>、BigInt <code>0n</code>、空字串<code>''</code>(字串長度為 0)，或者是表達式結果為 <code>false</code></li>\n</ul>\n<p>以下介紹幾種邏輯判斷的捷徑：</p>\n<h1 id=\"邏輯運算子-amp-amp\"><a href=\"#邏輯運算子-amp-amp\" class=\"headerlink\" title=\"邏輯運算子 &amp;&amp; ||\"></a>邏輯運算子 <code>&amp;&amp;</code> <code>||</code></h1><p>舉個栗子</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>邏輯運算子</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> numberAND = <span class=\"hljs-number\">6</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> numberOR = -<span class=\"hljs-number\">1</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">if</span>(numberAND &gt; <span class=\"hljs-number\">5</span> &amp;&amp; numberAND &lt; <span class=\"hljs-number\">7</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"hljs-string\">'哎呀'</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"hljs-keyword\">if</span>(numberOR &gt; <span class=\"hljs-number\">5</span> || numberOR &lt; <span class=\"hljs-number\">7</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"hljs-string\">'黑唷'</span>)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"人類的理解\"><a href=\"#人類的理解\" class=\"headerlink\" title=\"人類的理解\"></a>人類的理解</h3><p>當 numberAND 大於 5 且<strong>同時</strong>小於 7 值執行 <code>console.log('符合 &amp;&amp;')</code>；當 numberOR 大於 5 <strong>或者</strong>小於 7 值執行 <code>console.log('符合 ||')</code></p>\n<h3 id=\"電腦的理解\"><a href=\"#電腦的理解\" class=\"headerlink\" title=\"電腦的理解\"></a>電腦的理解</h3><p>當左邊的表達式 <code>numberAND &gt; 5</code> 結果為 <code>false</code> 則跳過右邊不執行 <code>numberAND &lt; 7</code>，直接<strong>跳出</strong>程式。<br>當左邊的表達式 <code>numberOR &gt; 5</code> 結果為 <code>true</code> 則跳過右邊不執行 <code>numberAND &lt; 7</code>，直接<strong>進入</strong>程式。</p>\n<p>結論為，當左邊的表達式符合條件，<code>&amp;&amp;</code> 的 if 直接跳出；<code>||</code> 的 if 直接進入。<br>來理一理箇中原由吧！</p>\n<h1 id=\"短路解析-Short-Circuit\"><a href=\"#短路解析-Short-Circuit\" class=\"headerlink\" title=\"短路解析(Short Circuit)\"></a>短路解析(Short Circuit)</h1><p>短路我個人覺得沒有捷徑來得好懂，短路比較讓人聯想為損毀或壞掉的電子產品，而捷徑則代表透過偷吃步或者抄捷徑的方式以取得一樣的結果。這裡的短路較接近後者，js 運行上的偷吃步：</p>\n<h3 id=\"amp-amp-的短路解析\"><a href=\"#amp-amp-的短路解析\" class=\"headerlink\" title=\"&amp;&amp; 的短路解析\"></a><code>&amp;&amp;</code> 的短路解析</h3><p>當左邊的表達式為 <code>false</code> 就返回左邊的表達式結果，並且<strong>直接忽視</strong>右邊的表達式結果，反之執行右邊的表達式。</p>\n<h3 id=\"的短路解析\"><a href=\"#的短路解析\" class=\"headerlink\" title=\"|| 的短路解析\"></a><code>||</code> 的短路解析</h3><p>當左邊的表達式為 <code>true</code> 就返回左邊的表達式結果，並且<strong>直接忽視</strong>右邊的表達式結果，反之執行右邊的表達式。</p>\n<p>以上可以知道 js 執行完左邊的表達式之後，若符合條件則直接跳過右邊的表達式(不解析亦不執行)，相對來講當開發人員在理解短路解析時就可以按照這樣的邏輯去快速判斷結果。</p>\n<p>速記法：AND<code>false</code>跳出、OR<code>true</code>進入(執行)。</p>\n<blockquote><p>if you use <code>||</code> to provide some default value to another variable foo, you may encounter unexpected behaviors if you consider some falsy values as usable (e.g., <code>''</code> or <code>0</code>). </p>\n</blockquote>\n\n<h1 id=\"可選鍊修飾符-Optional-chaining\"><a href=\"#可選鍊修飾符-Optional-chaining\" class=\"headerlink\" title=\"可選鍊修飾符(Optional chaining)\"></a>可選鍊修飾符(Optional chaining)</h1><p>舉個栗子</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>可選鍊修飾符</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> user = {};</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(user.<span class=\"hljs-property\">address</span>);</span><br><span class=\"line\"><span class=\"hljs-comment\">// undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(user.<span class=\"hljs-property\">address</span>.<span class=\"hljs-property\">street</span>);</span><br><span class=\"line\"><span class=\"hljs-comment\">// error</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(user.<span class=\"hljs-property\">address</span>?.<span class=\"hljs-property\">street</span>);</span><br><span class=\"line\"><span class=\"hljs-comment\">// undefined</span></span><br></pre></td></tr></tbody></table></figure>\n<p>在這個範例中，user 物件的清單中有部分的使用者缺少了 <code>address</code> 這個屬性，但是大部分的使用者都具有該屬性時，就可以使用可選鍊修飾符來避免程式噴錯而中斷，但是需注意避免<strong>過度使用</strong>可選鍊修飾符</p>\n<h1 id=\"空值合併運算子-Nullish-coalescing-operator\"><a href=\"#空值合併運算子-Nullish-coalescing-operator\" class=\"headerlink\" title=\"空值合併運算子(Nullish coalescing operator) ??\"></a>空值合併運算子(Nullish coalescing operator) <code>??</code></h1><p>舉個栗子</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>空值合併運算子</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">notNullish</span> (a, b) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a ?? b);</span><br><span class=\"line\">}</span><br><span class=\"line\">notNullish (<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">// null</span></span><br><span class=\"line\">notNullish (<span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">undefined</span>); <span class=\"hljs-comment\">// undefined</span></span><br><span class=\"line\">notNullish (<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 0</span></span><br><span class=\"line\">notNullish (<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">''</span>); <span class=\"hljs-comment\">// ''</span></span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>ES2020（ES11）提供的「空值合併運算子」，支援度需要搭配 babel 套件。</li>\n<li><code>??</code>常常與邏輯運算子 <code>||</code> 比較，前者返回非 <code>undefined</code> 與 <code>null</code> 的表達式，後者返回非 falsy 的表達式。過濾的條件上有區別，可以依照需求使用。</li>\n</ul>\n<h3 id=\"的短路解析-1\"><a href=\"#的短路解析-1\" class=\"headerlink\" title=\"?? 的短路解析\"></a><code>??</code> 的短路解析</h3><p>當左邊的表達式為 非 <code>undefined</code> 與 <code>null</code> 就返回左邊的表達式結果，並且<strong>直接忽視</strong>右邊的表達式結果，反之執行右邊的表達式。</p>\n</body></html>",
            "tags": [
                "javascript",
                "shortCircuit",
                "optionalChaining",
                "tricks"
            ]
        }
    ]
}