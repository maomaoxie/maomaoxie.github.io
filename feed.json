{
    "version": "https://jsonfeed.org/version/1",
    "title": "Mawchu 貓奴前端的天空",
    "description": "Mawchu 貓奴前端，為熱愛平面設計與貓咪的前端工程師 - 謝佳芳（毛球）的技術部落格，喜歡撰寫技術文章幫助自己在前端之路成長，涉及 Javascript、Vue、Laravel 與其他程式相關的討論與學習",
    "home_page_url": "http://maomaoxie.github.io",
    "items": [
        {
            "id": "http://maomaoxie.github.io/2022/09/23/js-weird-parts-coercion/",
            "url": "http://maomaoxie.github.io/2022/09/23/js-weird-parts-coercion/",
            "title": "克服 Javascript 的奇怪部分 動態型別",
            "date_published": "2022-09-23T07:31:26.000Z",
            "content_html": "<html><head></head><body><p>運算過程中由於 Javascript 是弱型別，沒有辦法強制規範型別，所以會在運算過程中發生隱式（動態）型別轉換，稱之為 Corecion。</p>\n<blockquote><p>Converting a value from one type to another.</p>\n</blockquote>\n\n<h1 id=\"算術運算子的隱式轉換\"><a href=\"#算術運算子的隱式轉換\" class=\"headerlink\" title=\"算術運算子的隱式轉換\"></a>算術運算子的隱式轉換</h1><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-number\">1</span> + <span class=\"hljs-string\">'2'</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// 12</span></span><br></pre></td></tr></tbody></table></figure>\n<p>上方範例可以印證 Javascript 引擎將數字 <code>1</code> 與字串 <code>2</code> 相加的過程中產生的動態型別的轉換，獲得了字串 <code>12</code>。<br>在某些強型別的語言中，這樣做是會噴 error 的，但 Javascript 不會，這也造成開發過程時常會發生不如預期的結果。</p>\n<h1 id=\"比較運算子的隱式轉換\"><a href=\"#比較運算子的隱式轉換\" class=\"headerlink\" title=\"比較運算子的隱式轉換\"></a>比較運算子的隱式轉換</h1><p>從以下的範例我們可以很自然地獲得 true 的結果：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-number\">3</span> &gt; <span class=\"hljs-number\">2</span> &gt; <span class=\"hljs-number\">1</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></tbody></table></figure>\n<p>然而以下的範例卻出乎意料之外也獲得了 true：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-number\">3</span> &lt; <span class=\"hljs-number\">2</span> &lt; <span class=\"hljs-number\">1</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></tbody></table></figure>\n<p>這也是動態型別的轉換在作怪，一一拆解一下過程是這樣的，比較運算子 <code>&lt;</code> 在前一篇的相依性有提到：</p>\n<img src=\"/images/js-weird-parts-coercion/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-coercion\">\n<p>當運算子相同時會採用相依性的方向來決定計算次序，比較運算子 <code>&lt;</code> 是左相依性（left-to-right associactivity），<br>所以背後的 Javascript 引擎會如是計算：<br><code>3 &lt; 2</code> 獲得 false，<code>false &lt; 1</code> 由於型別不同 Javascript 引擎強制將 false 使用數字包裹器轉換為數字型別：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Number</span>(<span class=\"hljs-literal\">false</span>)); <span class=\"hljs-comment\">// 0</span></span><br></pre></td></tr></tbody></table></figure>\n<p><code>0 &lt; 1</code> 獲得 true。</p>\n<h1 id=\"善用嚴格等式（triple-equal）\"><a href=\"#善用嚴格等式（triple-equal）\" class=\"headerlink\" title=\"善用嚴格等式（triple equal）\"></a>善用嚴格等式（triple equal）</h1><p>雙等號會造成嚴重的動態型別轉換，引發不可預期的後果，例如以下的範例：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-literal\">false</span> == <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// true</span></span><br><span class=\"line\"><span class=\"hljs-literal\">null</span> == <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// true</span></span><br><span class=\"line\"><span class=\"hljs-literal\">null</span> &lt; <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// true</span></span><br><span class=\"line\"><span class=\"hljs-string\">\"\"</span> == <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// true</span></span><br><span class=\"line\"><span class=\"hljs-string\">\"\"</span> &lt; <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></tbody></table></figure>\n<p>以下的範例是 JavaScript 最難以理解的一部分型別轉換：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] == <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>([]); <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></tbody></table></figure>\n<p>這實在是太詭異了!!不過理解一下背後的原理，當 Array 拿去比較 value 的時候，toString 包裹器會被呼叫：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">String</span>([]); <span class=\"hljs-comment\">// ''</span></span><br><span class=\"line\"><span class=\"hljs-string\">''</span> == <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></tbody></table></figure></body></html>",
            "tags": [
                "Javascript"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/09/21/js-weird-parts-operators-precendence-and-associactivity/",
            "url": "http://maomaoxie.github.io/2022/09/21/js-weird-parts-operators-precendence-and-associactivity/",
            "title": "克服 Javascript 的奇怪部分 運算子的相依性與優先性",
            "date_published": "2022-09-21T06:58:56.000Z",
            "content_html": "<html><head></head><body><p>在了解以下的特性以前需要知道，JavaScript 是 syncrounous 同步在執行一個表達式的，<br>所以一次只能執行一個片段的程式碼，也就是一個表達式，一個表達式只能包含一個運算子與兩個參數，所以需要決定執行的次序．</p>\n<h1 id=\"優先性（precendence）\"><a href=\"#優先性（precendence）\" class=\"headerlink\" title=\"優先性（precendence）\"></a>優先性（precendence）</h1><blockquote><p>When there is more than one operators in one executable code, which operator will be called in order of precedence.</p>\n</blockquote>\n<p>當某片段的執行碼具有多個運算子時，那個先執行取決於優先性（precendence）</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">4</span> * <span class=\"hljs-number\">5</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// 23</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>從以下圖表可以檢視優先性：</p>\n<img src=\"/images/js-weird-parts-operators-precendence-and-associactivity/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-operators-precendence-and-associactivity\">\n<p>由於 * 運算子的優先性大於 + 運算子，所以 Javacript 會優先執行 <code>4 * 5</code> 爾後執行 <code>20 + 3</code>；<br>等號的優先性只有 2，所以會最後執行 <code>a = 23</code>。</p>\n<h1 id=\"相依性（Associativity）\"><a href=\"#相依性（Associativity）\" class=\"headerlink\" title=\"相依性（Associativity）\"></a>相依性（Associativity）</h1><blockquote><p>The Associativity is the percedence that determines the operators being called from left to right,<br>or right to left when the percedence are all the same.</p>\n</blockquote>\n<p>當某片段程式碼中所有的運算子優先性相同時，由相依性來決定執行次序為左相依性還是右相依性：<br>左相依性（Left Associativity）表示由左到右執行；右相依性（Right Associativity）表示由右到左執行。</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>, b = <span class=\"hljs-number\">3</span>, c = <span class=\"hljs-number\">4</span>;</span><br><span class=\"line\">a = b = c;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// 4</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b); <span class=\"hljs-comment\">// 4</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c); <span class=\"hljs-comment\">// 4</span></span><br></pre></td></tr></tbody></table></figure>\n\n<img src=\"/images/js-weird-parts-operators-precendence-and-associactivity/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-operators-precendence-and-associactivity\">\n<p>從上圖可以了解到 = 運算子的相依性是右相依性（right to left, Right Associativity），<br>當運算子的優先性都相同時 Javacript 會優先執行右邊的運算子，然後向左一個一個執行。<br><code>a = b = c;</code> 表達式會先執行 <code>b = 4</code>，並且回傳 4 之後執行 <code>a = 4</code>。</p>\n<h1 id=\"大括號（parentheses）最優先\"><a href=\"#大括號（parentheses）最優先\" class=\"headerlink\" title=\"大括號（parentheses）最優先\"></a>大括號（parentheses）最優先</h1><img src=\"/images/js-weird-parts-operators-precendence-and-associactivity/2.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-operators-precendence-and-associactivity\">\n<p>當一個表達式中具有多個運算子，大括號（parentheses）裡的運算會最優先：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a = (<span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">4</span>) * <span class=\"hljs-number\">5</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// 35</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"amp-amp-優先性（precedence）比較\"><a href=\"#amp-amp-優先性（precedence）比較\" class=\"headerlink\" title=\"&amp;&amp; || 優先性（precedence）比較\"></a>&amp;&amp; || 優先性（precedence）比較</h1><img src=\"/images/js-weird-parts-operators-precendence-and-associactivity/3.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-operators-precendence-and-associactivity\">\n<p>在判斷式中經常同時使用 &amp;&amp;（and）與 ||（or），需要特別注意 &amp;&amp;（and）優先級是大於 ||（or）的，<br>不過若專案中有使用到 eslint 則會提示盡量補上大括號（parentheses），來協助辨認次序唷！</p>\n</body></html>",
            "tags": [
                "Javascript"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/09/21/zh-tw/js-weird-parts-operators/",
            "url": "http://maomaoxie.github.io/2022/09/21/zh-tw/js-weird-parts-operators/",
            "title": "克服 Javascript 的奇怪部分 運算子",
            "date_published": "2022-09-21T06:28:51.000Z",
            "content_html": "<html><head></head><body><p>在閱讀本篇文章以前，先給予一個結論方便後續理解：<br>運算子不過就是一種函式而已，而且會回傳一個運算結果的值．</p>\n<p>Javascript 的運算子（operators）有個奇妙的現象就是，運算過程會造成動態型別的轉換而獲得不如預期的結果．</p>\n<h1 id=\"運算子（operators）的定義\"><a href=\"#運算子（operators）的定義\" class=\"headerlink\" title=\"運算子（operators）的定義\"></a>運算子（operators）的定義</h1><h3 id=\"實際上為一種函式\"><a href=\"#實際上為一種函式\" class=\"headerlink\" title=\"實際上為一種函式\"></a>實際上為一種函式</h3><blockquote><p>A special function that is syntactically (written) differently.</p>\n</blockquote>\n\n<h3 id=\"需要兩個參數獲得結果\"><a href=\"#需要兩個參數獲得結果\" class=\"headerlink\" title=\"需要兩個參數獲得結果\"></a>需要兩個參數獲得結果</h3><blockquote><p>Generally, an operator take two parameters and return one result.</p>\n</blockquote>\n\n<h3 id=\"中綴寫法\"><a href=\"#中綴寫法\" class=\"headerlink\" title=\"中綴寫法\"></a>中綴寫法</h3><p>運算子其實就是一種表達式必備的元素，丟進去參數然後運算 return 結果，只是不同於一般的函式寫法，它是使用中綴（infix　notation）的寫法，將參數寫在函式符號的兩邊：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">4</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// 7</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>老式的計算機都是使用後綴的寫法：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span> +;</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"型別轉換\"><a href=\"#型別轉換\" class=\"headerlink\" title=\"型別轉換\"></a>型別轉換</h3><p>Javascript 的運算子造成的隱式型別轉換數不勝數，例如比較運算子（Relational operators），會將數字型別轉換成布林值（Boolean）。</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">3</span> &gt; <span class=\"hljs-number\">4</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// false</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h1><blockquote><p>Operators are actually spacial types of functions, these parameters are being pass into those functions,<br>and the value  is being returned.<br>There is pre written codes that javaScript engine provides to do or invoke those functions.</p>\n</blockquote>\n<p>運算子只是已經寫好的函式（function）提供使用而已，寫法稍有不同於一般函式，為中綴（infix　notation）的寫法。</p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/09/15/zh-tw/wordpress-ga-track/",
            "url": "http://maomaoxie.github.io/2022/09/15/zh-tw/wordpress-ga-track/",
            "title": "如何在 wordpress 埋入 GA code",
            "date_published": "2022-09-15T02:42:04.000Z",
            "content_html": "<html><head></head><body><p>目前 Google Analytics 已經升級至 GA4，從前綴的追蹤碼 UA- 開頭轉換為 G- 開頭，令許多前端框架的套件還趕不上變化。<br>以下介紹如何在 wordpress 介面插入追蹤碼：</p>\n<h1 id=\"在-GA-建立帳號與資源\"><a href=\"#在-GA-建立帳號與資源\" class=\"headerlink\" title=\"在 GA 建立帳號與資源\"></a>在 GA 建立帳號與資源</h1><p>這一步公司目前已經建置完成，建置的方法須先建立網站資源（網址 url），建立完畢後可在進階選項同時安裝新舊版的 GA code．</p>\n<h1 id=\"wordpress-安裝-GA-步驟\"><a href=\"#wordpress-安裝-GA-步驟\" class=\"headerlink\" title=\"wordpress 安裝 GA 步驟\"></a>wordpress 安裝 GA 步驟</h1><h3 id=\"安裝外掛-Insert-Headers-and-Footers\"><a href=\"#安裝外掛-Insert-Headers-and-Footers\" class=\"headerlink\" title=\"安裝外掛 Insert Headers and Footers\"></a>安裝外掛 Insert Headers and Footers</h3><p>安裝任何外掛程式前先 google wp 外掛黑名單，查看安全並安裝後記得跑跑看網站以免中毒．</p>\n<h3 id=\"埋入-GA-code\"><a href=\"#埋入-GA-code\" class=\"headerlink\" title=\"埋入 GA code\"></a>埋入 GA code</h3><p>舊版 UA- 開頭</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>GA3</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- <span class=\"title class_\">Global</span> site tag (gtag.<span class=\"hljs-property\">js</span>) - <span class=\"title class_\">Google</span> <span class=\"title class_\">Analytics</span> --&gt;</span><br><span class=\"line\"><span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">async</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXXXX-1\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"hljs-language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"><span class=\"variable language_\">window</span>.<span class=\"hljs-property\">dataLayer</span> = <span class=\"variable language_\">window</span>.<span class=\"hljs-property\">dataLayer</span> || [];</span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">gtag</span>(<span class=\"hljs-params\"></span>){dataLayer.<span class=\"title function_\">push</span>(<span class=\"variable language_\">arguments</span>);}</span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"><span class=\"title function_\">gtag</span>(<span class=\"hljs-string\">'js'</span>, <span class=\"hljs-keyword\">new</span> <span class=\"title class_\">Date</span>());</span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"></span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"><span class=\"title function_\">gtag</span>(<span class=\"hljs-string\">'config'</span>, <span class=\"hljs-string\">'UA-XXXXXXXXX-1'</span>);</span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>新版 G- 開頭</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>GA4</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- <span class=\"title class_\">Google</span> tag (gtag.<span class=\"hljs-property\">js</span>) --&gt;</span><br><span class=\"line\"><span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">async</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"hljs-language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"><span class=\"variable language_\">window</span>.<span class=\"hljs-property\">dataLayer</span> = <span class=\"variable language_\">window</span>.<span class=\"hljs-property\">dataLayer</span> || [];</span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">gtag</span>(<span class=\"hljs-params\"></span>){dataLayer.<span class=\"title function_\">push</span>(<span class=\"variable language_\">arguments</span>);}</span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"><span class=\"title function_\">gtag</span>(<span class=\"hljs-string\">'js'</span>, <span class=\"hljs-keyword\">new</span> <span class=\"title class_\">Date</span>());</span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"></span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"><span class=\"title function_\">gtag</span>(<span class=\"hljs-string\">'config'</span>, <span class=\"hljs-string\">'G-XXXXXXXXXX'</span>);</span></span></span><br><span class=\"line\"><span class=\"hljs-language-javascript\"><span class=\"hljs-language-xml\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure></body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/09/14/zh-tw/touch-and-click-event/",
            "url": "http://maomaoxie.github.io/2022/09/14/zh-tw/touch-and-click-event/",
            "title": "touch 與 click 事件",
            "date_published": "2022-09-14T01:38:48.000Z",
            "content_html": "<html><head></head><body><p>製作完一個 swipe 專案之後發覺 click 事件會同時觸發 touch 事件，造成綁定同一個 dom 時觸發兩次，解決方式有幾種：</p>\n<h1 id=\"針對-click-與-touch-綁定不同的-dom\"><a href=\"#針對-click-與-touch-綁定不同的-dom\" class=\"headerlink\" title=\"針對 click 與 touch 綁定不同的 dom\"></a>針對 click 與 touch 綁定不同的 dom</h1><p>例如輪播可以針對箭頭按鈕綁定 click，輪播對象綁定 touch。</p>\n<h1 id=\"改用-mousedown-amp-up-取代-click-事件\"><a href=\"#改用-mousedown-amp-up-取代-click-事件\" class=\"headerlink\" title=\"改用 mousedown &amp; up 取代 click 事件\"></a>改用 mousedown &amp; up 取代 click 事件</h1><p>可以區分滑鼠的點擊事件使用 mouse 系列，與手指的點擊使用 touch 事件。</p>\n<h1 id=\"改用-pointer-event\"><a href=\"#改用-pointer-event\" class=\"headerlink\" title=\"改用 pointer event\"></a>改用 pointer event</h1><p>該事件可以適用於所有觸控裝置，包括觸控筆與手指，可以更敏銳的偵測觸控的方式，有幾種形式可以使用：</p>\n<h3 id=\"pointerover\"><a href=\"#pointerover\" class=\"headerlink\" title=\"pointerover\"></a>pointerover</h3><p>Fired when a pointer is moved into an element’s hit test boundaries.<br>當觸控進入指定區域時觸發。</p>\n<h3 id=\"ponterenter\"><a href=\"#ponterenter\" class=\"headerlink\" title=\"ponterenter\"></a>ponterenter</h3><p>Fired when a pointer is moved into the hit test boundaries of an element or one of its descendants,<br>including as a result of a pointerdown event from a device that does not support hover<br>當觸控進入指定區域或是子元素區域，及不支援 hover 的裝置上按壓時觸發．</p>\n<h3 id=\"pointerdown\"><a href=\"#pointerdown\" class=\"headerlink\" title=\"pointerdown\"></a>pointerdown</h3><p>Fired when a pointer becomes active buttons state.<br>按壓時觸發．</p>\n<h3 id=\"pointermove\"><a href=\"#pointermove\" class=\"headerlink\" title=\"pointermove\"></a>pointermove</h3><p>Fired when a pointer changes coordinates.<br>This event is also used if the change in pointer state can not be reported by other events.<br>當手指按壓並移動時觸發，亦會使用在 pointer 狀態不為其他事件所察覺時．</p>\n<h3 id=\"pointerup\"><a href=\"#pointerup\" class=\"headerlink\" title=\"pointerup\"></a>pointerup</h3><p>Fired when a pointer is no longer active buttons state.<br>當手指接觸面積離開裝置時觸發．</p>\n<h3 id=\"pointercancel\"><a href=\"#pointercancel\" class=\"headerlink\" title=\"pointercancel\"></a>pointercancel</h3><p>A browser fires this event if it concludes the pointer will no longer be able to generate events<br>(for example the related device is deactivated).<br>當裝置因設置關閉觸控等原因無法觸發 pointer 事件時，瀏覽器會偵測並觸發．</p>\n<h3 id=\"pointerout\"><a href=\"#pointerout\" class=\"headerlink\" title=\"pointerout\"></a>pointerout</h3><p>Fired for several reasons including: pointer is moved out of the hit test boundaries of an element;<br>firing the pointerup event for a device that does not support hover (see pointerup);<br>after firing the pointercancel event (see pointercancel); when a pen stylus leaves the hover range detectable by the digitizer.<br>當手指從裝置面板移開時觸發，亦會同時觸發 pointerup 事件；在 pointercancel 事件完成後也會觸發；當觸控筆離開裝置可偵測的範圍內也會觸發．</p>\n<h3 id=\"pointerleave\"><a href=\"#pointerleave\" class=\"headerlink\" title=\"pointerleave\"></a>pointerleave</h3><p>Fired when a pointer is moved out of the hit test boundaries of an element.<br>For pen devices, this event is fired when the stylus leaves the hover range detectable by the digitizer.<br>跟上面很像，只是不會觸發 pointerup；在 pointercancel 事件完成後不會觸發．</p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/25/zh-tw/wowjs-in-vue2-typescript/",
            "url": "http://maomaoxie.github.io/2022/08/25/zh-tw/wowjs-in-vue2-typescript/",
            "title": "在 Vue2 + Typescript 專案中引入 WOW.js",
            "date_published": "2022-08-25T03:00:37.000Z",
            "content_html": "<html><head></head><body><h1 id=\"安裝模組\"><a href=\"#安裝模組\" class=\"headerlink\" title=\"安裝模組\"></a>安裝模組</h1><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install wowjs</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"引用-css\"><a href=\"#引用-css\" class=\"headerlink\" title=\"引用 css\"></a>引用 css</h1><p>這一步要注意的地方是 animate.css 的使用方式，使用 npm install 安裝的 animate.css 會在 wowjs 套件包下的 <code>css/lib/animate.css</code>，而不是透過 npm 安裝的 animate.css：</p>\n<h3 id=\"wowjs-套件包下的-animate-css\"><a href=\"#wowjs-套件包下的-animate-css\" class=\"headerlink\" title=\"wowjs 套件包下的 animate.css\"></a>wowjs 套件包下的 animate.css</h3><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'css/lib/animate.css'</span>;</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"npm-安裝的-animate-css\"><a href=\"#npm-安裝的-animate-css\" class=\"headerlink\" title=\"npm 安裝的 animate.css\"></a>npm 安裝的 animate.css</h3><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'animate.css'</span>;</span><br></pre></td></tr></tbody></table></figure>\n\n<blockquote class=\"colorquote danger\"><p>值得注意的點就是在於 css 名稱套用上的不同，wowjs 使用上不需要 animate 前綴，而 npm 安裝的需要，如果得搭配滾動視窗位置才套用動畫，需要注意 wowjs 套件包下的 <code>css/lib/animate.css</code> 引用模組方式。</p>\n</blockquote>\n\n<blockquote><p><a href=\"https://blog.csdn.net/qq_32963841/article/details/115690823\">关于wow.js在vue项目中的使用及遇到的坑（css3效果）</a></p>\n</blockquote></body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/18/zh-tw/safari-preventDefault-bug/",
            "url": "http://maomaoxie.github.io/2022/08/18/zh-tw/safari-preventDefault-bug/",
            "title": "Safari IOS 11.3 後 preventDefault 失效問題",
            "date_published": "2022-08-18T01:12:34.000Z",
            "content_html": "<html><head></head><body><img src=\"https://i.gifer.com/2BC.gif\" class=\"\" width=\"300\" height=\"200\" title=\"safari-preventDefault-bug\">\n<p>沒錯的，我們可愛的 Safari 又又又出現了 bug，來看看這個高級 IE 的除錯日常（Safari 愛好者不要鞭我）</p>\n<h1 id=\"click-事件綁定\"><a href=\"#click-事件綁定\" class=\"headerlink\" title=\"click 事件綁定\"></a>click 事件綁定</h1><p>網站開發過程的需求是，當元件沒有 props 連結路徑時就預防 a 連結的預設跳轉行為，以下是元件的 code：</p>\n<figure class=\"highlight plaintext hljs\"><figcaption><span>component</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// HTML</span><br><span class=\"line\">&lt;a class=\"w-100 h-100\" :class=\"[ url === '' ? 'pointer-events-none' : 'url-active' ]\" @click=\"changeTab()\"&gt;</span><br><span class=\"line\">&lt;/a&gt;</span><br><span class=\"line\">// Script</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">@Component</span><br><span class=\"line\">export default class ItemCard extends Vue {</span><br><span class=\"line\">    @Prop({ default: '' }) url?: string;</span><br><span class=\"line\">    private changeTab (event: any) {</span><br><span class=\"line\">        if (this.url === '') {</span><br><span class=\"line\">        event.preventDefault();</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"contextmenu-事件綁定\"><a href=\"#contextmenu-事件綁定\" class=\"headerlink\" title=\"contextmenu 事件綁定\"></a>contextmenu 事件綁定</h1><p>後來發現 Safari 的瀏覽器，手機與電腦綁定 a 標籤 click 事件都無法達到避免預設行為的效果，於是求救谷歌大神：</p>\n<blockquote><p>To target right click events, use contextmenu rather than mousedown.</p>\n<p><code>document.querySelector(\"#GL-Surface\").addEventListener(\"contextmenu\",     function(e) {         e.preventDefault();     }); </code><br>Note that the options that appear on right click do appear only when the right click button is released, so I don’t think mousedown is at all suitable here.</p>\n<p><a href=\"https://stackoverflow.com/questions/62245019/javascript-preventdefault-not-working-in-safari\">Javascript preventDefault() not working in Safari</a></p>\n</blockquote>\n\n<p>這裡面提及的<strong>contextmenu</strong>事件是右鍵出現的選單，抱持著嘗試看看的心情監聽contextmenu事件，並綁定了一樣的函式．竟然成功了？？？</p>\n<p>第一次看到這個<strong>contextmenu</strong>事件，來瞧瞧 MDN 怎麼說：</p>\n<blockquote><p>被触发的 contextmenu 事件的默认行为被 preventDefault() 取消了，因此，在第一段右击鼠标时什么也不会发生<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/contextmenu\">contextmenu</a></p>\n</blockquote>\n\n<h1 id=\"ios11-3-版本後\"><a href=\"#ios11-3-版本後\" class=\"headerlink\" title=\"ios11.3 版本後\"></a>ios11.3 版本後</h1><p>有人提及<strong>ios11.3 and later</strong>預設行為就失效了</p>\n<blockquote><p>This is not an issue by React and is caused by the recent movement of browser vendors to improve performance on mobile devices.<br>Some events (usually those that would fire when you scroll) are <strong>getting passive by default</strong>.<br><a href=\"https://github.com/facebook/react/issues/13369\">e.preventDefault() does not work with safari in ios11.3 and later #13369</a></p>\n</blockquote>\n\n<h1 id=\"改動是為了優化體驗\"><a href=\"#改動是為了優化體驗\" class=\"headerlink\" title=\"改動是為了優化體驗\"></a>改動是為了優化體驗</h1><p>以上的說明原由來自於性能優化的考量，由於手機裝置在滾動時觸發太多主動事件會嚴重影響體驗，因故某些事件都被調整預設為<strong>被動的（passive）</strong>，來看看以下說明：<br>（附上不負責任翻譯）</p>\n<blockquote><p>We know that scrolling responsiveness is critical to the user’s engagement with a website on mobile, yet touch event listeners often cause serious scrolling performance problems.<br>在手機裝置中滾動事件的敏感度放大了使用者的體驗，可能造成延遲或性能不好。</p>\n<p>Chrome has been addressing this by allowing touch event listeners to be passive (passing the {passive: true} option to addEventListener()) and shipping the pointer events API. These are great features to drive new content into models that don’t block scrolling, but developers sometimes find them hard to understand and adopt.<br>Chrome 在事件監聽上預設了被動參數為 true，避免滾動事件被阻擋。</p>\n<p>Developer-defined “passive event listeners” solve this. When you add a touch event with a {passive: true} object as the third parameter in your event handler then you are telling the browser that the touchstart listener will not call preventDefault() and the browser can safely perform the scroll without blocking on the listener.<br>當你設定事件監聽被動參數為 true，該事件就不會觸發**preventDefault()**避免滾動事件卡卡的</p>\n<p><a href=\"https://developer.chrome.com/blog/scrolling-intervention/\">Making touch scrolling fast by default</a></p>\n</blockquote>\n\n<p>設定的方式與參數例如這樣：<br><code>window.addEventListener(\"touchstart\", func, {passive: true} );</code></p>\n<h1 id=\"弔詭的地方\"><a href=\"#弔詭的地方\" class=\"headerlink\" title=\"弔詭的地方\"></a>弔詭的地方</h1><ol>\n<li>以上說明是針對 Chrome 瀏覽器的性能優化改動，不是 safari 啊？</li>\n<li>MDN 提及 contextmenu 事件已經不為瀏覽器所支援，但 safari 卻必須使用 contextmenu 事件綁定並且搭配 preventDefault 才能生效？而且註明 safari ios 是唯一不支援此事件的瀏覽器？</li>\n</ol>\n<img src=\"/images/safari-preventDefault-bug/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"safari-preventDefault-bug\">\n<img src=\"https://c.tenor.com/sAMt7DszgXMAAAAC/%E9%BB%91%E4%BA%BA%E5%95%8F%E8%99%9F.gif\" class=\"\" width=\"350\" height=\"200\" title=\"safari-preventDefault-bug\">\n\n<p>也許下次可以試試看直接把監聽器的 passive 設為 false 試試看 XD</p>\n</body></html>",
            "tags": [
                "safari",
                "javaScript",
                "preventDefault",
                "ios",
                "mobile"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/17/zh-tw/js-object-fromEntries/",
            "url": "http://maomaoxie.github.io/2022/08/17/zh-tw/js-object-fromEntries/",
            "title": "Js 物件陣列轉換的方法，真香！",
            "date_published": "2022-08-17T02:22:19.000Z",
            "content_html": "<html><head></head><body><img src=\"https://exp-picture.cdn.bcebos.com/3201a8f39187031c063126496a86242fa972ec4a.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_auto/quality,q_80\" class=\"\" width=\"300\" height=\"200\" title=\"真香\">\n<p><a href=\"https://exp-picture.cdn.bcebos.com/3201a8f39187031c063126496a86242fa972ec4a.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_auto/quality,q_80\">圖片來源</a></p>\n<p>今天來介紹一下資料處理的好兄弟，<code>Object.entries</code> 以及 <code>Object.fromEntries</code>。</p>\n<p>工作上的需求情境是這樣：<br>一個物件裡有多個 key，但我只需要複製部份的 key 資料，不用全部時可以使用以下作法。</p>\n<h1 id=\"Object-entries\"><a href=\"#Object-entries\" class=\"headerlink\" title=\"Object.entries\"></a>Object.entries</h1><p>工作上的老朋友，常用在物件轉換成陣列時使用，方法特色是將物件內的 key 與 value 轉變成一個<strong>成對的陣列</strong>。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>Object.entries</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> obj = {</span><br><span class=\"line\"><span class=\"hljs-attr\">fruits</span>: <span class=\"hljs-string\">'apple'</span>,</span><br><span class=\"line\"><span class=\"hljs-attr\">beverage</span>: <span class=\"hljs-string\">'choco milk'</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> outcome = <span class=\"title class_\">Object</span>.<span class=\"title function_\">entries</span>(obj);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(outcome);</span><br><span class=\"line\"><span class=\"hljs-comment\">// [</span></span><br><span class=\"line\">    [ <span class=\"hljs-string\">'fruits'</span>, <span class=\"hljs-string\">'apple'</span> ],</span><br><span class=\"line\">    [ <span class=\"hljs-string\">'beverage'</span>, <span class=\"hljs-string\">'choco milk'</span> ],</span><br><span class=\"line\">]</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"Object-fromEntries\"><a href=\"#Object-fromEntries\" class=\"headerlink\" title=\"Object.fromEntries\"></a>Object.fromEntries</h1><p>跟上面的相反，常用在陣列轉換成物件時使用，方法特色是將成對的 key 與 value 轉變成一個<strong>物件</strong>。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>Object.fromEntries</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> obj = {</span><br><span class=\"line\"><span class=\"hljs-attr\">fruits</span>: <span class=\"hljs-string\">'apple'</span>,</span><br><span class=\"line\"><span class=\"hljs-attr\">beverage</span>: <span class=\"hljs-string\">'choco milk'</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> entries = <span class=\"title class_\">Object</span>.<span class=\"title function_\">entries</span>(obj);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"hljs-string\">'entries'</span>, entries);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> fromEntries = <span class=\"title class_\">Object</span>.<span class=\"title function_\">fromEntries</span>(entries);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"hljs-string\">'fromEntries'</span>, fromEntries);</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"綜合應用\"><a href=\"#綜合應用\" class=\"headerlink\" title=\"綜合應用\"></a>綜合應用</h1><p>回到主題，若只需要複製部份的 key 資料可以結合 filter 過濾需要的 key 值：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> obj = {</span><br><span class=\"line\"><span class=\"hljs-attr\">fruits</span>: <span class=\"hljs-string\">'apple'</span>,</span><br><span class=\"line\"><span class=\"hljs-attr\">beverage</span>: <span class=\"hljs-string\">'choco milk'</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> onlyBeverage = <span class=\"title class_\">Object</span>.<span class=\"title function_\">entries</span>(obj).<span class=\"title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">[key, value]</span>) =&gt;</span> key === <span class=\"hljs-string\">'beverage'</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(onlyBeverage);</span><br><span class=\"line\"><span class=\"hljs-comment\">// ['beverage', 'choco milk']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> transferArrayToObject = <span class=\"title class_\">Object</span>.<span class=\"title function_\">fromEntries</span>(onlyBeverage);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(transferArrayToObject);</span><br><span class=\"line\"><span class=\"hljs-comment\">// { 'beverage': 'choco milk' }</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>參考資料<a href=\"https://masteringjs.io/tutorials/fundamentals/filter-key\">在這</a></p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/09/zh-tw/http-methods-idempotent/",
            "url": "http://maomaoxie.github.io/2022/08/09/zh-tw/http-methods-idempotent/",
            "title": "RESTful API 方法觀念介紹 - idempotent",
            "date_published": "2022-08-09T07:14:24.000Z",
            "content_html": "<html><head></head><body><p>RESTful API 呼叫的方法中，離不開四個主軸 CRUD，CREATE、READ/RETREIVE、UPDATE 還有 DELETE。<br>而其中就有分是否為 <strong>Idempotent 的方法</strong>，甚麼意思呢？</p>\n<h1 id=\"甚麼是Idempotent（冪等）\"><a href=\"#甚麼是Idempotent（冪等）\" class=\"headerlink\" title=\"甚麼是Idempotent（冪等）\"></a>甚麼是Idempotent（冪等）</h1><blockquote><p>A request method is considered “idempotent” if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request. </p>\n</blockquote>\n\n<p>看為只覺得在母鯊大，沒關係我們繼續看下去：</p>\n<blockquote><p>Of the request methods defined by this specification, PUT, DELETE, and safe request methods are idempotent.</p>\n<footer><strong>Lauviah0622</strong><cite><a href=\"https://lance.coderbridge.io/2021/06/06/what-is-safe-method-and-indempotent-methods/\">[極短篇] HTTP 的 Safe method 還有 Idempotent method</a></cite></footer></blockquote>\n\n<p>dempotent（冪等）的方法不管你做一次、兩次乃至一百次，對於伺服器端資料的結果都一樣，是安全而沒有副作用的，可以安心服用；<br>相反的非 Idempotent 的方法則是需要謹慎考慮的、會改動伺服器資料庫的、有副作用的，也就是非安全請求。</p>\n<p>我們來看看更精簡好懂的解釋：</p>\n<blockquote><p>Idempotent operations produce the same result even when the operation is repeated many times. The result of the 2nd, 3rd, and 1,000th repeat of the operation will return exactly the same result as the 1st time.<br>冪等運算是指無論操作多少次結果都會與第一次相同。</p>\n<p>For example, simple mathematical examples of idempotency include:</p>\n<p>x + 0;<br>x = 5;</p>\n<p>In the first example, adding zero will never change the result, regardless of how many times you do it. In the second, x is always 5. Again, this is the case, regardless of how many times you perform the operation. Both of these examples describe an operation that is idempotent.</p>\n<p>以上兩個例子都說明了這兩個表達是無論執行幾次都會是相同結果，這就是 Idempotent（冪等）。</p>\n<footer><strong>James E.</strong><cite><a href=\"https://blog.dreamfactory.com/what-is-idempotency/\">what-is-idempotency</a></cite></footer></blockquote>\n\n<h1 id=\"冪等不等於安全請求\"><a href=\"#冪等不等於安全請求\" class=\"headerlink\" title=\"冪等不等於安全請求\"></a>冪等不等於安全請求</h1><blockquote><p>The concepts of ‘idempotent methods’ and ‘safe methods’ are often confused. A safe method does not change the value that is returned, it reads – but it never writes.<br>Therefore, all safe methods are idempotent, but not all idempotent methods are safe.</p>\n<p>HTTP methods include:<br>POST – Creates a new resource. POST is not idempotent and it is not safe.<br>GET – Retrieves a resource. GET is idempotent and it is safe.<br>HEAD – Retrieves a resource (without response body). HEAD is idempotent and it is safe<br>PUT – Updates/replaces a resource. PUT is idempotent but it is not safe<br>PATCH – Partially updates a resource. PATCH is not idempotent and it is not safe.<br>DELETE – Deletes a resource. DELETE is idempotent but it is not safe.<br>TRACE – Performs a loop-back test. TRACE is idempotent but it is not safe.</p>\n<footer><strong>James E.</strong><cite><a href=\"https://blog.dreamfactory.com/what-is-idempotency/\">what-is-idempotency</a></cite></footer></blockquote>\n\n<p>安全請求只會讀取，所以都是冪等的，但冪等方法不一定都是安全請求。</p>\n<p>學術的部份我們就此打住，了解一下冪等之於 RESTful API 的意義。</p>\n<h1 id=\"idempotent-methods-冪等的方法\"><a href=\"#idempotent-methods-冪等的方法\" class=\"headerlink\" title=\"idempotent methods 冪等的方法\"></a>idempotent methods 冪等的方法</h1><ol>\n<li>GET</li>\n<li>HEAD（只讀取資料頭而忽略身體）</li>\n<li>PUT</li>\n<li>DELETE</li>\n<li>OPTIONS</li>\n</ol>\n<p>以上方式無論發幾次 request，結果都等同於一次。</p>\n<blockquote><p>通常 DELETE 會帶上 id，所以刪除 1 次和刪除 100 次是一樣的，server 那邊找不到 id 操作就會被忽略。<br>而 PUT 也一樣，PUT 代表替代的 http 操作，你發了 1 次 request 已經取代了內容後，那即使再發 100 次也只是替代一樣的內容。</p>\n<footer><strong>Lauviah0622</strong><cite><a href=\"https://lance.coderbridge.io/2021/06/06/what-is-safe-method-and-indempotent-methods/\">[極短篇] HTTP 的 Safe method 還有 Idempotent method</a></cite></footer></blockquote>\n\n<h1 id=\"Not-idempotent-methods-非冪等的方法\"><a href=\"#Not-idempotent-methods-非冪等的方法\" class=\"headerlink\" title=\"Not idempotent methods 非冪等的方法\"></a>Not idempotent methods 非冪等的方法</h1><ol>\n<li>POST</li>\n<li>DISPATCH</li>\n</ol>\n<p>以上方法每執行一次就會造成資料變動，但並非每種使用方式都是非冪等，端看 request 的目的是在「修改」還是「增加」，修改可能並不會更改內存量（memory），但是增加就不同了，它也是修改但是擴大了內存量（變多了）：</p>\n<blockquote><p>PATCH 在語意上代表著修改資料，換句話說可能這樣：</p>\n<p><code>PATCH http://blog.com/post?id=1 body {     title: 'new title' } </code><br>發了 100 次和 1 次標題都是同樣的 new title。</p>\n<p><code>PATCH http:shop.com/item/add?id=1 body {     number: 10 }</code><br>requst 代表的是增加 10 個 item 的數量。這種情況下也符合語意（修改資料），但就不符合 Idempotent 了，100 次會新增 1000 個。那 POST 就不用提，一次和 100 次肯定是不一樣的。</p>\n<footer><strong>Lauviah0622</strong><cite><a href=\"https://lance.coderbridge.io/2021/06/06/what-is-safe-method-and-indempotent-methods/\">[極短篇] HTTP 的 Safe method 還有 Idempotent method</a></cite></footer></blockquote>\n\n<h1 id=\"結語\"><a href=\"#結語\" class=\"headerlink\" title=\"結語\"></a>結語</h1><p>讓我最意外的是 DELETE 居然是冪等方法，原因在於無論 request 幾次都只刪同一筆資料（認 id）這個觀念，與以前認為 DELETE 應該會每次刪除不同資料的想法大相逕庭。</p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/09/zh-tw/vuetify-slot-vhtml/",
            "url": "http://maomaoxie.github.io/2022/08/09/zh-tw/vuetify-slot-vhtml/",
            "title": "如何在 vuetify 元件中渲染 v-html",
            "date_published": "2022-08-09T04:09:43.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/vuetify-slot-vhtml/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"vuetify-slot-vhtml\">\n<p>使用 vuetify 元件時常有的狀況劇就是 - 標題的 UI 設計需要客製化，例如放上 fontawesome 的 icon，但你的元件是 vuetify 父元件（v-select），客製的對象是迴圈後的子元件（選單下的選項 v-selection），這時候要如何成功渲染 fontawesome 的 icon ?</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>vuetify</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;v-select</span><br><span class=\"line\">    :items=<span class=\"hljs-string\">\"items\"</span></span><br><span class=\"line\">    label=<span class=\"hljs-string\">\"Standard\"</span></span><br><span class=\"line\">&gt;&lt;/v-select&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"使用-lt-i-gt-lt-i-gt-標籤\"><a href=\"#使用-lt-i-gt-lt-i-gt-標籤\" class=\"headerlink\" title=\"使用 <i></i> 標籤\"></a>使用 <code>&lt;i&gt;&lt;/i&gt;</code> 標籤</h1><p>目前可以知道的小撇步就是 fontawesome 的 icon 要使用 vue v-html 渲染，必須使用 <code>&lt;i&gt;&lt;/i&gt;</code> 標籤才能成功，不能放入 vuetify  <code>&lt;v-icon&gt;&lt;/v-icon&gt;</code>，無法正確編譯成 html。</p>\n<h1 id=\"在父元件內使用-v-slot\"><a href=\"#在父元件內使用-v-slot\" class=\"headerlink\" title=\"在父元件內使用 v-slot\"></a>在父元件內使用 v-slot</h1><p>可以知道目前的元件結構會是這樣的：<br>v-select（父）<br>        ｜<br>    v-selection（子）</p>\n<p>選項是這樣：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    { <span class=\"hljs-attr\">value</span>:<span class=\"hljs-string\">\"0\"</span>,<span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">\"&lt;i class=\"</span>fab fa-apple<span class=\"hljs-string\">\"&gt;&lt;/i&gt; apple\"</span> },</span><br><span class=\"line\">    { <span class=\"hljs-attr\">value</span>:<span class=\"hljs-string\">\"1\"</span>,<span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">\"&lt;i class=\"</span>fab fa-google-drive<span class=\"hljs-string\">\"&gt;&lt;/i&gt; google\"</span> },</span><br><span class=\"line\">]</span><br></pre></td></tr></tbody></table></figure>\n\n<p>vuetify 父元件（v-select）透過 props items 選項的陣列可以使用 v-slot 轉換成 html 模板傳入：</p>\n<blockquote><p>Override the item and selection slots, and use v-html.<br>參考網址：<a href=\"https://stackoverflow.com/questions/56665185/show-raw-html-in-vuetify-v-select\">https://stackoverflow.com/questions/56665185/show-raw-html-in-vuetify-v-select</a></p>\n</blockquote>\n\n<h3 id=\"vue-2-版本\"><a href=\"#vue-2-版本\" class=\"headerlink\" title=\"vue 2 版本\"></a>vue 2 版本</h3><p>由於子元件會有 default 選項，要使用插槽針對 <strong>selection</strong> 修改；<br>而下拉選項要使用插槽針對 <strong>item</strong> 修改。</p>\n<h5 id=\"寫法-1\"><a href=\"#寫法-1\" class=\"headerlink\" title=\"寫法 1\"></a>寫法 1</h5><figure class=\"highlight javascript hljs\"><figcaption><span>slot 範例 1</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;v-select :items=<span class=\"hljs-string\">'item'</span>&gt;</span><br><span class=\"line\">    <span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:item</span>=<span class=\"hljs-string\">'{item}'</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">'item.text'</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></span></span><br><span class=\"line\">    <span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:selection</span>=<span class=\"hljs-string\">'{item}'</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">'item.text'</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></span></span><br><span class=\"line\">&lt;/v-select&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"寫法-2\"><a href=\"#寫法-2\" class=\"headerlink\" title=\"寫法 2\"></a>寫法 2</h5><figure class=\"highlight javascript hljs\"><figcaption><span>slot 範例 1</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;v-select :items=<span class=\"hljs-string\">'item'</span>&gt;</span><br><span class=\"line\">    <span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:item</span>=<span class=\"hljs-string\">'{item}'</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">'item.text'</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></span></span><br><span class=\"line\">    <span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:selection</span>=<span class=\"hljs-string\">'{item}'</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">'item.text'</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></span></span><br><span class=\"line\">&lt;/v-select&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n\n<h3 id=\"簡潔版本\"><a href=\"#簡潔版本\" class=\"headerlink\" title=\"簡潔版本\"></a>簡潔版本</h3><figure class=\"highlight javascript hljs\"><figcaption><span>slot 範例 2</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;v-select :items=<span class=\"hljs-string\">'item'</span>&gt;</span><br><span class=\"line\">    <span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">'item'</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">'{item}'</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">'item.text'</span>/&gt;</span></span></span><br><span class=\"line\">&lt;/v-select&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"vue-3-版本\"><a href=\"#vue-3-版本\" class=\"headerlink\" title=\"vue 3 版本\"></a>vue 3 版本</h3><figure class=\"highlight javascript hljs\"><figcaption><span>slot 範例 3</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template #item=<span class=\"hljs-string\">'{item}'</span>&gt;</span><br><span class=\"line\">    <span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">'item.text'</span> /&gt;</span></span></span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"vuetify-api-說明\"><a href=\"#vuetify-api-說明\" class=\"headerlink\" title=\"vuetify api 說明\"></a>vuetify api 說明</h1><p>在每個元件的 api 文件下方都有提供現成的插槽可以使用：</p>\n<img src=\"/images/vuetify-slot-vhtml/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"vuetify-slot-vhtml\"></body></html>",
            "tags": [
                "vue",
                "vuetify",
                "html"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/09/zh-tw/hello-world/",
            "url": "http://maomaoxie.github.io/2022/08/09/zh-tw/hello-world/",
            "title": "感謝您的閱讀",
            "date_published": "2022-08-09T03:46:24.948Z",
            "content_html": "<html><head></head><body><p>這裡撰寫的都是一些自己在前端之路上每天一小步的學習，希望透過記錄與陳述來加強學習成效以及融會貫通的能力，文章內有任何問題歡迎一起討論呦!</p>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/07/zh-tw/git-remove-submodule/",
            "url": "http://maomaoxie.github.io/2022/08/07/zh-tw/git-remove-submodule/",
            "title": "git 移除 submodule",
            "date_published": "2022-08-07T08:07:24.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/git-remove-submodule/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"git-remove-submodule\">\n<h1 id=\"git-submodule\"><a href=\"#git-submodule\" class=\"headerlink\" title=\"git submodule\"></a>git submodule</h1><p>在部屬 hexo 部落格到雲端 github 時，發現主題下的 minos git status 呈現 untracked 的狀態，搜尋後才知道該主題是 clone 遠端下來的，自動會變成一個子模塊（submodule），對於習慣專案開發的我來說在客製化後不能同步實在很不方便，還是喜歡一整包放在同一個 repository 方便管理。</p>\n<img src=\"/images/git-remove-submodule/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"git-remove-submodule\">\n\n<p>以下記錄自己如何將修改後的 minos 資料夾：</p>\n<h3 id=\"移除-git-子模塊快取\"><a href=\"#移除-git-子模塊快取\" class=\"headerlink\" title=\"移除 git 子模塊快取\"></a>移除 git 子模塊快取</h3><p>以下的指令可以清除子模塊的 git 紀錄：</p>\n<figure class=\"highlight plaintext hljs\"><figcaption><span>git cmd</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm --cached -f ./themes/minos</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"重新加入索引\"><a href=\"#重新加入索引\" class=\"headerlink\" title=\"重新加入索引\"></a>重新加入索引</h3><p>將剛才取消子模塊的 git 重新排隊至專案包中，我比較懶惰直接整包加：</p>\n<figure class=\"highlight plaintext hljs\"><figcaption><span>git cmd</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></tbody></table></figure>\n\n<p>再檢視一遍 vs code 之後就會看到檔案被追蹤到了！</p>\n</body></html>",
            "tags": [
                "git",
                "hexo",
                "submodule"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/07/zh-tw/wordpress-get-started/",
            "url": "http://maomaoxie.github.io/2022/08/07/zh-tw/wordpress-get-started/",
            "title": "開始我的第一個 wordpress 網站",
            "date_published": "2022-08-07T02:02:29.000Z",
            "content_html": "<html><head></head><body><h1 id=\"第一步-產生-ip-位址\"><a href=\"#第一步-產生-ip-位址\" class=\"headerlink\" title=\"第一步 - 產生 ip 位址\"></a>第一步 - 產生 ip 位址</h1><p>首先要租賃一台伺服器提供 ip，可以考慮較優惠的主機廠商：遠振或 bluehost。<br>要注意的是，一個 domain 可以放置很多網站資料夾，並且設定sub-domian。</p>\n<h1 id=\"第二步-DNS-註冊\"><a href=\"#第二步-DNS-註冊\" class=\"headerlink\" title=\"第二步 - DNS 註冊\"></a>第二步 - DNS 註冊</h1><p>ip 設定好之後就可以將網域指過來指定的 DNS 網域商：<br>中華電信提供的 .tw　較便宜，而 godaddy 則是 .com 較便宜。</p>\n<h1 id=\"第三步-cdn-分散流量\"><a href=\"#第三步-cdn-分散流量\" class=\"headerlink\" title=\"第三步 - cdn 分散流量\"></a>第三步 - cdn 分散流量</h1><p>常用的 cdn 廠商像是 cloudflare，可以註冊一個離主機近的（例如東京）cdn 位址，其他供應商例如 sugarhost 很便宜但連線較慢。</p>\n<h3 id=\"CDN-原理\"><a href=\"#CDN-原理\" class=\"headerlink\" title=\"CDN 原理\"></a>CDN 原理</h3><p>cdn 是把 DNS 轉向給 DNS 廠商（cloudflare），透過 DNS 指向將流量倒過去 cloudflare，在第一次 cache 過網站靜態資源後，第二次就可以直接提取cdn 伺服器上 cache　的資源以減少流量費用。</p>\n<h3 id=\"設定細節\"><a href=\"#設定細節\" class=\"headerlink\" title=\"設定細節\"></a>設定細節</h3><h5 id=\"資源類型\"><a href=\"#資源類型\" class=\"headerlink\" title=\"資源類型\"></a>資源類型</h5><p>通常都會設定 <strong>A 類型</strong>以設定網址（url）指向，例如 mailgun 的寄信功能。</p>\n<h5 id=\"防堵資安問題\"><a href=\"#防堵資安問題\" class=\"headerlink\" title=\"防堵資安問題\"></a>防堵資安問題</h5><p>cloudflare 設定其中一樣可以開啟 ddos -&gt; under Attack 來保護網站資源。<br>也可以手動清除特定檔案，例如圖片的 cache 來重新抓取檔案。</p>\n<h1 id=\"第四步-掛載-wordpress\"><a href=\"#第四步-掛載-wordpress\" class=\"headerlink\" title=\"第四步 - 掛載 wordpress\"></a>第四步 - 掛載 wordpress</h1><p>wordpress 可以當作是一個 php 建構而成的後端框架應用，串接方式有兩種：</p>\n<ol>\n<li>直接使用 wordpress hook 來渲染資料（前後端合併）。</li>\n<li>撰寫自己的前端框架（例如 vue），撰寫自己的 API（前後端分離）。</li>\n</ol>\n<h3 id=\"建立步驟\"><a href=\"#建立步驟\" class=\"headerlink\" title=\"建立步驟\"></a>建立步驟</h3><p>到  <a href=\"https://tw.wordpress.org/download/\">wordpress</a> 官方網站下載檔案，上傳到自己的網域 server。</p>\n<img src=\"/images/wordpress-get-started/14.png\" class=\"\" width=\"800\" height=\"200\" title=\"wordpress-download\">\n<p>上傳後打開網站，會有一個 UI 介面可以直接設定 wordpress 與網站資料，config 需要設定資料庫帳號密碼：</p>\n<p>要注意的是 wordpress 權限身分須從 root 改成 www-data，才能變成網站系統管理員使用 wordpress 後台。</p>\n<!-- 行情 $ 25000 (使用佈景主題)\n客製化算一頁\n定時備份以免網站被駭客\n租 GCP 靜態硬碟 \ngoogle 硬碟版本管理 資源回收桶保留30 天\nflicker\n\n設定 config 檔案 \n比較好的後台c panel 要錢\ndns 代管要 https 要使用 flexible SSL for cloudflare\n\n一類有分類的文章 slug 需要代稱(英文的)\n獨立頁面 客製化\nsiteliner 檢查有沒有壞掉的連結與重複的內容\nduplicate page\n報價高一點\n附加的css\n減少做重複的事情\n在 wordpress 上做前後端分離 -->\n</body></html>",
            "tags": [
                "wordpress",
                "dns",
                "cdn"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/08/05/zh-tw/hexo-rss/",
            "url": "http://maomaoxie.github.io/2022/08/05/zh-tw/hexo-rss/",
            "title": "Hexo RSS 自動產生器",
            "date_published": "2022-08-05T07:39:34.000Z",
            "content_html": "<html><head></head><body><p>RSS 訂閱功能越來越夯，可以即時通知訂閱戶更新的文章內容，增加回流的流量與網站的熱度，chrome 也有提供 RSS reader 的外掛功能直接讀取 RSS 檔案。<br>既然建立好了自己的部落格怎麼可以沒有 RSS XD?</p>\n<p>先前在專案包嘗試使用 hexo-generator-feed 套件，但是建立出來的 atom.xml 檔案會出現亂碼，後來找到一個套件甚至支援 json 與 rss 格式：</p>\n<h1 id=\"安裝-Hexo-seed-套件\"><a href=\"#安裝-Hexo-seed-套件\" class=\"headerlink\" title=\"安裝 Hexo seed 套件\"></a>安裝 Hexo seed 套件</h1><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-feed</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"檔案格式\"><a href=\"#檔案格式\" class=\"headerlink\" title=\"檔案格式\"></a>檔案格式</h3><p>hexo-feed 可以設定三種文件格式：atom、json 還有 rss，建立的模板可以透過專案包根目錄的 _config.yml 去設定模板的 path（template）：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>_config.yml</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-attr\">feed</span>:</span><br><span class=\"line\">    <span class=\"hljs-attr\">limit</span>: <span class=\"hljs-number\">20</span></span><br><span class=\"line\">    <span class=\"hljs-attr\">order_by</span>: <span class=\"hljs-string\">\"-date\"</span></span><br><span class=\"line\">    <span class=\"hljs-attr\">tag_dir</span>: <span class=\"hljs-string\">\"tag\"</span></span><br><span class=\"line\">    <span class=\"hljs-attr\">category_dir</span>: <span class=\"hljs-string\">\"category\"</span></span><br><span class=\"line\">    <span class=\"hljs-attr\">rss</span>:</span><br><span class=\"line\">        <span class=\"hljs-attr\">enable</span>: <span class=\"hljs-literal\">true</span></span><br><span class=\"line\">        <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">\"themes/layout/template/rss.ejs\"</span> </span><br><span class=\"line\">        <span class=\"hljs-attr\">output</span>: <span class=\"hljs-string\">\"rss.xml\"</span></span><br><span class=\"line\">    <span class=\"hljs-attr\">atom</span>:</span><br><span class=\"line\">        <span class=\"hljs-attr\">enable</span>: <span class=\"hljs-literal\">true</span></span><br><span class=\"line\">        <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">\"themes/layout/template/atom.ejs\"</span></span><br><span class=\"line\">        <span class=\"hljs-attr\">output</span>: <span class=\"hljs-string\">\"atom.xml\"</span></span><br><span class=\"line\">    <span class=\"hljs-attr\">jsonFeed</span>:</span><br><span class=\"line\">        <span class=\"hljs-attr\">enable</span>: <span class=\"hljs-literal\">true</span></span><br><span class=\"line\">        <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">\"themes/layout/template/json.ejs\"</span></span><br><span class=\"line\">        <span class=\"hljs-attr\">output</span>: <span class=\"hljs-string\">\"feed.json\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"模板內容\"><a href=\"#模板內容\" class=\"headerlink\" title=\"模板內容\"></a>模板內容</h3><figure class=\"highlight javascript hljs\"><figcaption><span>atom</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"hljs-string\">\"1.0\"</span>?&gt;</span><br><span class=\"line\"><span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">feed</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.w3.org/2005/Atom\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>&lt;%= config.url %&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>&lt;%= config.title %&gt;&lt;%= tag ? ` • Posts by \"${tag}\" tag` : '' %&gt;&lt;%= category ? ` • Posts by \"${category}\" category` : '' %&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"&lt;%= config.url %&gt;\"</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">updated</span>&gt;</span>&lt;%= moment(lastBuildDate).toISOString() %&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">updated</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    &lt;%_ for (const { name } of (tags || [])) { _%&gt;</span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">category</span> <span class=\"hljs-attr\">term</span>=<span class=\"hljs-string\">\"&lt;%= name %&gt;\"</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    &lt;%_ } _%&gt;</span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    &lt;%_ for (const post of posts) { _%&gt;</span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">entry</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>&lt;%= post.permalink %&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>&lt;%= post.title %&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">\"alternate\"</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"&lt;%= post.permalink %&gt;\"</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">content</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"html\"</span>&gt;</span>&lt;%= post.content %&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">content</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        &lt;%_ for (const { name } of (post.tags ? post.tags.toArray() : [])) { _%&gt;</span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">category</span> <span class=\"hljs-attr\">term</span>=<span class=\"hljs-string\">\"&lt;%= name %&gt;\"</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        &lt;%_ } _%&gt;</span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">updated</span>&gt;</span>&lt;%= moment(post.date).toISOString() %&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">updated</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">entry</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"hljs-language-xml\">    &lt;%_ } _%&gt;</span></span><br><span class=\"line\"><span class=\"hljs-language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">feed</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure></body></html>",
            "tags": [
                "hexo",
                "rss"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/07/30/zh-tw/js-weird-parts-value/",
            "url": "http://maomaoxie.github.io/2022/07/30/zh-tw/js-weird-parts-value/",
            "title": "克服 Javascript 的奇怪部分 原始型別",
            "date_published": "2022-07-30T09:08:20.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-value/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-primitive-type\">\n<p>只要不是物件型別的值都可以看做是原始型別，例如：</p>\n<h1 id=\"undefined\"><a href=\"#undefined\" class=\"headerlink\" title=\"undefined\"></a>undefined</h1><p>當一個變數還未指派任何值之前，記憶體位置會被賦予一個 undefied 的值，通常是 Javascript 引擎指派的，應該避免將任何值的預設值設定為 undefined，避免與 Hoisting 行為混淆了。</p>\n<h1 id=\"null\"><a href=\"#null\" class=\"headerlink\" title=\"null\"></a>null</h1><p>若需要再資料回來之前給予判斷，可以將變數設定為 null 來表示該變數還未拿到任何值，也非 Javascript 引擎指派的值。</p>\n<h1 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h1><p>true 或 false 的判斷型別，值得注意的是當值存在 localstorage 或者 cookie 時應避免儲存 true 或 false，轉換過程會強制變成 string 而造成錯誤的判斷。</p>\n<h1 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\"number\"></a>number</h1><p>唯一的數字型別（numeric），不同於其他語言可能具有細緻的數字型別，例如 interger 或是 demicals，Javascript 只有一個 number type，為<strong>浮點運算（floating point number）</strong>，這種運算法為一個有效數字加上冪數來表示，電腦本身的二進制無法實現十進制的數字精確性，會造成數字計算上浮點位數的不正確，只能計算出近似值而已。</p>\n<h1 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h1><p>字串型別，一串使用雙引號或單引號標記起來的文字。</p>\n<h1 id=\"symbol\"><a href=\"#symbol\" class=\"headerlink\" title=\"symbol\"></a>symbol</h1><p>ES6 引入的新原始型別，用來表示一個獨一無二的值。產生的原因來自於物件的屬性通常都是字串（property），這樣容易造就重複的屬性而衝突，新的符號型別（symbol）於是誕生，兩個 symbol 永遠不會相等，是絕對的獨一無二。ES6 允許使用表達式 (expression) 作為屬性的名稱，語法是將 expression 放在中括號 [ ] 裡面：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>symbol</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> s = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"hljs-keyword\">let</span> obj = {</span><br><span class=\"line\">    [s]: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {}</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure></body></html>",
            "tags": [
                "javascript",
                "type"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/07/30/zh-tw/js-weird-parts-types/",
            "url": "http://maomaoxie.github.io/2022/07/30/zh-tw/js-weird-parts-types/",
            "title": "克服 Javascript 的奇怪部分 型別",
            "date_published": "2022-07-30T08:35:45.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-dynamic-typing/0.png\" class=\"\" title=\"dynamic-typing\">\n<h1 id=\"Dynamic-Typing\"><a href=\"#Dynamic-Typing\" class=\"headerlink\" title=\"Dynamic Typing\"></a>Dynamic Typing</h1><p>Javascript 的型別為動態型別（Dynamic Typing），不同於 C# 等強型別語言的靜態型別（Static Typing），無須指派型別而是在引擎執行的階段（at runtime）辨認變數記憶體內的型別為何：</p>\n<blockquote class=\"colorquote info\"><p>Dynamically-typed languages are those (like JavaScript) where the interpreter assigns variables a type at runtime based on the variable’s value at the time.</p>\n</blockquote>\n\n<p>這有可能導致一個變數在每次程式執行的結果都產生不同的型別（例如 == 型別隱式轉換），而造成不如預期的結果，所以使用三等號是比較良好的撰寫習慣。</p>\n</body></html>",
            "tags": [
                "javascript",
                "type"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/07/24/zh-tw/js-weird-parts-asynchronous/",
            "url": "http://maomaoxie.github.io/2022/07/24/zh-tw/js-weird-parts-asynchronous/",
            "title": "克服 Javascript 的奇怪部分 如何執行非同步",
            "date_published": "2022-07-24T08:56:25.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-asynchronous/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"asynchronous\">\n\n<p>瀏覽器在運作的時候有三大功能要執行：render engine 畫面渲染 -&gt; JavaScript 引擎 -&gt; Http Request。</p>\n<blockquote class=\"colorquote info\"><p>A browser engine (also known as a layout engine or rendering engine) is a core software component of every major web browser. The primary job of a browser engine is to <strong>transform HTML documents and other resources of a web page into an interactive visual representation on a user’s device</strong>.</p>\n</blockquote>\n\n<p>雖然名詞解釋上為非同步，但在 JavaScript 運作上實際仍是 line by line，而且具有先後順序的，對瀏覽器而言以下三項機制才是同時運作（asynchronous）：</p>\n<img src=\"/images/js-weird-parts-asynchronous/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"asynchronous\">\n\n<h1 id=\"Http-request-amp-response\"><a href=\"#Http-request-amp-response\" class=\"headerlink\" title=\"Http request &amp; response\"></a>Http request &amp; response</h1><p>客戶端發送了頁面請求後，<strong>Http 機制</strong>開始運行收發請求與回應網路資源的文本協定，建立瀏覽器與伺服器的溝通橋樑，作為 TCP/IP 的應用層，並且將資料回應提供給 JavaScript 來處理。</p>\n<h1 id=\"Javascript\"><a href=\"#Javascript\" class=\"headerlink\" title=\"Javascript\"></a>Javascript</h1><p>一旦提及非同步就不可埋沒一大功臣，JavaScript 引擎中的<strong>事件佇列（Event Queue）</strong>。</p>\n<h4 id=\"事件佇列（Event-Queue）\"><a href=\"#事件佇列（Event-Queue）\" class=\"headerlink\" title=\"事件佇列（Event Queue）\"></a>事件佇列（Event Queue）</h4><p>當 Javascript 引擎執行完執行佇列（Execution Stack）的內容後，也就是執行佇列已經清空後，會定期（periodic）來檢視事件佇列（Event Queue）的事件排序並且執行，例如 Click 事件的回呼函式，或者是 API 收發資料的任務，才會被放置到執行佇列（Execution Stack）然後執行。在 Javascript 中的運作仍是同步的，並沒有非同步在執行程式。</p>\n<h4 id=\"微任務與宏任務\"><a href=\"#微任務與宏任務\" class=\"headerlink\" title=\"微任務與宏任務\"></a>微任務與宏任務</h4><p>部分的執行任務會被放置在事件佇列中，待執行佇列（Execution Stack）所有任務完成後才會開始執行，例如 SetTimeout（宏任務） 或是 promise（微任務） 等。</p>\n<h1 id=\"Render-engine\"><a href=\"#Render-engine\" class=\"headerlink\" title=\"Render engine\"></a>Render engine</h1><p>JavaScript 的必須仰賴瀏覽器的引擎，當瀏覽器讀取一個頁面時， JavaScript 具有觸發畫面渲染的鉤子促使<strong>渲染引擎（Render Engine）</strong>來改變畫面。</p>\n<blockquote class=\"colorquote danger\"><p>Asynchronous means that the rendering engine, the javascript engine and the HTTP requests are running asynchrounously inside the browser, what’s happening just inside the javascript is synchrounous.</p>\n</blockquote></body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/07/24/zh-tw/js-weird-parts-ES6/",
            "url": "http://maomaoxie.github.io/2022/07/24/zh-tw/js-weird-parts-ES6/",
            "title": "克服 Javascript 的奇怪部分 ES6",
            "date_published": "2022-07-24T08:30:58.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-let/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"ES6-let\">\n<h1 id=\"ES6-let\"><a href=\"#ES6-let\" class=\"headerlink\" title=\"ES6 let\"></a>ES6 let</h1><p>不同於 var 的宣告方式，let 宣告的變數在宣告時會出現暫時性死區不可取用，沒有 hoisting 現象，且變數的作用域只存在於 block 區塊中，例如 if 陳述句，而 var 則是函式作用域，若撰寫在 if 陳述句內外部仍可取用。<br>最經典的應用就是 for 迴圈，可以在每一次的 console 正確印出數值：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>for loop</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">5</span>; i++) {</span><br><span class=\"line\">  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">()=&gt;</span>{</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i)</span><br><span class=\"line\">  },<span class=\"hljs-number\">1000</span>)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n</body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/07/10/zh-tw/js-weird-parts-scope-chain/",
            "url": "http://maomaoxie.github.io/2022/07/10/zh-tw/js-weird-parts-scope-chain/",
            "title": "克服 Javascript 的奇怪部分 範圍鍊",
            "date_published": "2022-07-10T07:57:42.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-scope-chain/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"scope-chain\">\n\n<p>以下探討的幾個議題都離不開函式（function）本身：</p>\n<h1 id=\"環境變數\"><a href=\"#環境變數\" class=\"headerlink\" title=\"環境變數\"></a>環境變數</h1><p>每個執行環境（execution context）都有屬於其中的變數，可以把執行環境想作是一個<strong>空間範圍</strong>，而環境變數都附著在其中，例如全域變數（global variable）會附著在全域物件下，瀏覽器的全域執行環境則是屬於 window 物件，宣告在其中的變數都會隸屬於全域執行環境。</p>\n<h1 id=\"函式變數\"><a href=\"#函式變數\" class=\"headerlink\" title=\"函式變數\"></a>函式變數</h1><p>函式變數在函式被呼叫並觸發後創造了一個獨特的函式執行環境，該函式內有自己的變數，此變數式在函式內<strong>宣告（declaration）</strong>並且創造的，只能在該函式執行環境中可以取得，稱為區域變數（scoped variable），而變數可取用的範圍稱之作用域（scope）。</p>\n<h1 id=\"範圍鍊\"><a href=\"#範圍鍊\" class=\"headerlink\" title=\"範圍鍊\"></a>範圍鍊</h1><p>根據函式的靜態作用域、詞法作用域，也就是坐落的物理位置來向外查找可用的變數（accessible variables），而非呼叫的位置；每個函式的執行環境（execution context）都是獨立的執行堆疊（execution stack），並且都指向外部的執行環境（outer environment），一層一層的鏈結稱為範圍鍊（scope chain）。</p>\n<img src=\"/images/js-weird-parts-scope-chain/4.png\" class=\"\" width=\"800\" height=\"200\" title=\"scope-chain\">\n<blockquote class=\"colorquote info\"><p>值得注意的一點：函式 b 是在函式 a 呼叫並且執行之後才建立了函式 b 的執行環境。</p>\n</blockquote></body></html>",
            "tags": []
        },
        {
            "id": "http://maomaoxie.github.io/2022/06/05/zh-tw/js-weird-parts-III/",
            "url": "http://maomaoxie.github.io/2022/06/05/zh-tw/js-weird-parts-III/",
            "title": "克服 Javascript 的奇怪部分 單執行緒與同步執行",
            "date_published": "2022-06-05T08:31:07.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-single-threaded/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-single-threaded\">\n<p>這一個章節要來講解 JavaScript 的幾個觀念。</p>\n<h1 id=\"單執行緒（Single-Threaded）\"><a href=\"#單執行緒（Single-Threaded）\" class=\"headerlink\" title=\"單執行緒（Single Threaded）\"></a>單執行緒（Single Threaded）</h1><p><strong>一次一件事</strong>是重點。<br>這個特性不是瀏覽器的特性，瀏覽器一次可能同時處理多件事情，JavaScript 引擎則是單執行緒的，就像排隊買早餐，老闆娘一次只能處理一位客人，而 JavaScript 也是一次只處理一項指令。</p>\n<h1 id=\"同步執行（Synchronous）\"><a href=\"#同步執行（Synchronous）\" class=\"headerlink\" title=\"同步執行（Synchronous）\"></a>同步執行（Synchronous）</h1><p><strong>順序</strong>是重點。<br>事情有先後順序，按照順序執行，一次執行一行（或者說一個單元的程式碼，可能是一個陳述式或表達式）。</p>\n<h1 id=\"呼叫函式（Function-Invocation）\"><a href=\"#呼叫函式（Function-Invocation）\" class=\"headerlink\" title=\"呼叫函式（Function Invocation）\"></a>呼叫函式（Function Invocation）</h1><p>觸發或執行一個函式，使用的符號為大括號（parenthesis）。<br>JavaScript 引擎在執行函式呼叫時，會發生幾件事情延續前面的章節：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>呼叫函式</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">b</span> () {</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">a</span> () {</span><br><span class=\"line\">  <span class=\"title function_\">b</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">a</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"創造階段\"><a href=\"#創造階段\" class=\"headerlink\" title=\"創造階段\"></a>創造階段</h2><ol>\n<li>全域執行環境（Global Execution Context）首先被創造。</li>\n<li>全域物件（Global object）被創造。</li>\n<li>全域 this 被創造。</li>\n<li>開始編譯階段（Parsing），編譯器巡過一遍所有程式碼發現了函式 b 與 a，在記憶體創造兩個函式的空間並且存放整個函式內容。</li>\n</ol>\n<img src=\"/images/js-weird-parts-III/1.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-III\">\n\n<h2 id=\"執行階段\"><a href=\"#執行階段\" class=\"headerlink\" title=\"執行階段\"></a>執行階段</h2><ol>\n<li><p>整個程式碼的記憶體準備完畢後，開始執行程式。</p>\n</li>\n<li><p>編譯器解析到<strong>函式 a</strong>被呼叫，立即於全域執行環境上方，產生並堆疊一個函式 a 的執行環境（Execution Context），放進<strong>執行佇列堆（Execution Stack）</strong>中，每個執行環境都有自己得記憶體空間存放著變數或函式。</p>\n<img src=\"/images/js-weird-parts-III/2.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-III\">\n</li>\n<li><p>最上方的執行佇列會優先執行，進入函式 a 的執行環境（Execution Context）並且解析到函式 b，程序暫停，立即於函式 a 的執行環境上方，產生並堆疊一個函式 b 的執行環境（Execution Context），放進<strong>執行佇列堆（Execution Stack）</strong>中。</p>\n<img src=\"/images/js-weird-parts-III/3.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-III\"></li>\n</ol>\n<p>以上執行階段也可以拆分成好幾個創造（執行環境），與執行（執行佇列堆最上方的執行環境）階段，在當下的執行環境執行過程中，只要觸發另一個函式，執行暫停然後創造（執行環境）、與執行（執行佇列堆最上方的執行環境），而下方的程式碼不會被解析，除非該執行環境執行完畢並且離開執行佇列堆（Execution Stack）後才會繼續逐行執行。</p>\n<blockquote class=\"colorquote Info\"><p>Everytime a function is called, a new execution context is created for that function, the <code>this</code> variable is created for that function, the variables in it were set up in the creation phase, then the code is executed line by line.<br>whatever is on the top of the execution stack, is currently running synchronously.</p>\n</blockquote>\n\n<p>重點整理：<br>當一個函式被觸發或是呼叫，JS 引擎會創造一個屬於該函式的執行環境（execution context）並且放置在執行緒的最上方等待被執行，而該堆疊中具有該函式獨有的執行環境與 This，開始執行並且完成後離開堆疊中（pop out）繼續執行下一個堆疊，只要解析到新的函式被呼叫就會反覆以上行為，直到堆疊不斷（pop out）剩下全域執行環境本身為止。</p>\n</body></html>",
            "tags": [
                "Javascript"
            ]
        }
    ]
}