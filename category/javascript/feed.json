{
    "version": "https://jsonfeed.org/version/1",
    "title": "Mawchu 貓奴前端的天空 • All posts by \"javascript\" category",
    "description": "Mawchu 貓奴前端，為熱愛平面設計與貓咪的前端工程師 - 謝佳芳（毛球）的技術部落格，喜歡撰寫技術文章幫助自己在前端之路成長，涉及 Javascript、Vue、Laravel 與其他程式相關的討論與學習",
    "home_page_url": "http://maomaoxie.github.io",
    "items": [
        {
            "id": "http://maomaoxie.github.io/2022/09/23/zh-tw/js-weird-parts-coercion/",
            "url": "http://maomaoxie.github.io/2022/09/23/zh-tw/js-weird-parts-coercion/",
            "title": "克服 Javascript 的奇怪部分 動態型別",
            "date_published": "2022-09-23T07:31:26.000Z",
            "content_html": "<html><head></head><body><p>運算過程中由於 Javascript 是弱型別，沒有辦法強制規範型別，所以會在運算過程中發生隱式（動態）型別轉換，稱之為 Corecion。</p>\n<blockquote><p>Converting a value from one type to another.</p>\n</blockquote>\n\n<h1 id=\"算術運算子的隱式轉換\"><a href=\"#算術運算子的隱式轉換\" class=\"headerlink\" title=\"算術運算子的隱式轉換\"></a>算術運算子的隱式轉換</h1><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-number\">1</span> + <span class=\"hljs-string\">'2'</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// 12</span></span><br></pre></td></tr></tbody></table></figure>\n<p>上方範例可以印證 Javascript 引擎將數字 <code>1</code> 與字串 <code>2</code> 相加的過程中產生的動態型別的轉換，獲得了字串 <code>12</code>。<br>在某些強型別的語言中，這樣做是會噴 error 的，但 Javascript 不會，這也造成開發過程時常會發生不如預期的結果。</p>\n<h1 id=\"比較運算子的隱式轉換\"><a href=\"#比較運算子的隱式轉換\" class=\"headerlink\" title=\"比較運算子的隱式轉換\"></a>比較運算子的隱式轉換</h1><p>從以下的範例我們可以很自然地獲得 true 的結果：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-number\">3</span> &gt; <span class=\"hljs-number\">2</span> &gt; <span class=\"hljs-number\">1</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></tbody></table></figure>\n<p>然而以下的範例卻出乎意料之外也獲得了 true：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-number\">3</span> &lt; <span class=\"hljs-number\">2</span> &lt; <span class=\"hljs-number\">1</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></tbody></table></figure>\n<p>這也是動態型別的轉換在作怪，一一拆解一下過程是這樣的，比較運算子 <code>&lt;</code> 在前一篇的相依性有提到：</p>\n<img src=\"/images/js-weird-parts-coercion/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-coercion\">\n<p>當運算子相同時會採用相依性的方向來決定計算次序，比較運算子 <code>&lt;</code> 是左相依性（left-to-right associactivity），<br>所以背後的 Javascript 引擎會如是計算：<br><code>3 &lt; 2</code> 獲得 false，<code>false &lt; 1</code> 由於型別不同 Javascript 引擎強制將 false 使用數字包裹器轉換為數字型別：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Number</span>(<span class=\"hljs-literal\">false</span>)); <span class=\"hljs-comment\">// 0</span></span><br></pre></td></tr></tbody></table></figure>\n<p><code>0 &lt; 1</code> 獲得 true。</p>\n<h1 id=\"強制型轉\"><a href=\"#強制型轉\" class=\"headerlink\" title=\"強制型轉\"></a>強制型轉</h1><p>型轉分為主動式強制型轉（Explicit Coercion）與被動式隱式型轉（Implicit Coercion），強制型轉有幾個基本型：</p>\n<ol>\n<li>toString</li>\n<li>toNumber</li>\n<li>toBoolean</li>\n<li>toPrimitive</li>\n</ol>\n<h3 id=\"toNumber-數字型轉範例\"><a href=\"#toNumber-數字型轉範例\" class=\"headerlink\" title=\"toNumber 數字型轉範例\"></a>toNumber 數字型轉範例</h3><p>以下是幾個特殊的案例：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Number</span>(<span class=\"title class_\">Undefined</span>); <span class=\"hljs-comment\">// NaN</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>(<span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">// 0</span></span><br></pre></td></tr></tbody></table></figure>\n\n\n<h3 id=\"雙等號型轉的悲劇\"><a href=\"#雙等號型轉的悲劇\" class=\"headerlink\" title=\"雙等號型轉的悲劇\"></a>雙等號型轉的悲劇</h3><p>雙等號（double Equality）會造成嚴重的動態型別轉換，引發不可預期的後果，例如以下的範例：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-literal\">false</span> == <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// true</span></span><br><span class=\"line\"><span class=\"hljs-literal\">null</span> == <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// true</span></span><br><span class=\"line\"><span class=\"hljs-literal\">null</span> &lt; <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// true</span></span><br><span class=\"line\"><span class=\"hljs-string\">\"\"</span> == <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// true</span></span><br><span class=\"line\"><span class=\"hljs-string\">\"\"</span> &lt; <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"動態型別呼叫的包裹器？\"><a href=\"#動態型別呼叫的包裹器？\" class=\"headerlink\" title=\"動態型別呼叫的包裹器？\"></a>動態型別呼叫的包裹器？</h4><p>Javascript 引擎在型別轉換背後做了許多事情，但也非沒有規則可循，<br>以下的範例是 JavaScript 最難以理解的一部分型別轉換：</p>\n<h5 id=\"比較運算子呼叫-toString\"><a href=\"#比較運算子呼叫-toString\" class=\"headerlink\" title=\"比較運算子呼叫 toString\"></a>比較運算子呼叫 toString</h5><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] == <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>([]); <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>這實在是太詭異了!!不過理解一下背後的原理，「當 Array 拿去比較 value 的時候，toString 包裹器會被呼叫，而不是透過　Boolean 轉換」：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">String</span>([]); <span class=\"hljs-comment\">// ''</span></span><br><span class=\"line\"><span class=\"hljs-string\">''</span> == <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// true</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"有趣的-object-object\"><a href=\"#有趣的-object-object\" class=\"headerlink\" title=\"有趣的 [object object]\"></a>有趣的 [object object]</h3><p>在開發過程查詢 error 或其他型轉情境經常會看見或 alert 噴出 <code>[object object]</code> 這類特殊的值，剖析一下出現的原理：</p>\n<h4 id=\"型轉造成的-object-object\"><a href=\"#型轉造成的-object-object\" class=\"headerlink\" title=\"型轉造成的 [object object]\"></a>型轉造成的 [object object]</h4><figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] + {}; <span class=\"hljs-comment\">// '[object object]'</span></span><br><span class=\"line\">{} + []; <span class=\"hljs-comment\">// 0</span></span><br></pre></td></tr></tbody></table></figure>\n<p>第一個例子 <code>[] + {};</code>，這是由於 <code>[]</code> + 號型轉為空字串 <code>''</code>，而 <code>{}</code> + 號型轉為 ‘[object object]’ 了；String() 直接調用 <code>.toString</code> 方法來轉換 <code>[]</code>。</p>\n<p>第二個例子 <code>{} + []</code> 中， <code>{}</code>被當作空區塊無作用，只會運算後方的 <code> + []</code> 調用 <code>Number([])</code>，<br>依據型轉規則，陣列屬於物件型別所以型轉數字時會調用 toString 方法來型轉成空字串 <code>String([])</code> 獲得 <code>''</code>，也就是 Number(‘’)，<br>而獲得 0 的結果。</p>\n<blockquote class=\"colorquote danger\"><p>值得注意的是 block <code>{}</code> 放置在最前方會被為 Javascript 引擎視作作用域而非空物件!</p>\n</blockquote>\n\n<h3 id=\"善用嚴格等式（Tripple-Equality）\"><a href=\"#善用嚴格等式（Tripple-Equality）\" class=\"headerlink\" title=\"善用嚴格等式（Tripple Equality）\"></a>善用嚴格等式（Tripple Equality）</h3><p>不同於雙等號造成的型轉悲劇，三等號可以確保最後獲得的比較結果不會被型轉，也能達到預期的值做開發判斷，是比較良好的開發習慣。</p>\n</body></html>",
            "tags": [
                "Javascript"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/09/21/zh-tw/js-weird-parts-operators-precendence-and-associactivity/",
            "url": "http://maomaoxie.github.io/2022/09/21/zh-tw/js-weird-parts-operators-precendence-and-associactivity/",
            "title": "克服 Javascript 的奇怪部分 運算子的相依性與優先性",
            "date_published": "2022-09-21T06:58:56.000Z",
            "content_html": "<html><head></head><body><p>在了解以下的特性以前需要知道，JavaScript 是 syncrounous 同步在執行一個表達式的，<br>所以一次只能執行一個片段的程式碼，也就是一個表達式，一個表達式只能包含一個運算子與兩個參數，所以需要決定執行的次序．</p>\n<h1 id=\"優先性（precendence）\"><a href=\"#優先性（precendence）\" class=\"headerlink\" title=\"優先性（precendence）\"></a>優先性（precendence）</h1><blockquote><p>When there is more than one operators in one executable code, which operator will be called in order of precedence.</p>\n</blockquote>\n<p>當某片段的執行碼具有多個運算子時，那個先執行取決於優先性（precendence）</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">4</span> * <span class=\"hljs-number\">5</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// 23</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>從以下圖表可以檢視優先性：</p>\n<img src=\"/images/js-weird-parts-operators-precendence-and-associactivity/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-operators-precendence-and-associactivity\">\n<p>由於 * 運算子的優先性大於 + 運算子，所以 Javacript 會優先執行 <code>4 * 5</code> 爾後執行 <code>20 + 3</code>；<br>等號的優先性只有 2，所以會最後執行 <code>a = 23</code>。</p>\n<h1 id=\"相依性（Associativity）\"><a href=\"#相依性（Associativity）\" class=\"headerlink\" title=\"相依性（Associativity）\"></a>相依性（Associativity）</h1><blockquote><p>The Associativity is the percedence that determines the operators being called from left to right,<br>or right to left when the percedence are all the same.</p>\n</blockquote>\n<p>當某片段程式碼中所有的運算子優先性相同時，由相依性來決定執行次序為左相依性還是右相依性：<br>左相依性（Left Associativity）表示由左到右執行；右相依性（Right Associativity）表示由右到左執行。</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>, b = <span class=\"hljs-number\">3</span>, c = <span class=\"hljs-number\">4</span>;</span><br><span class=\"line\">a = b = c;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// 4</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b); <span class=\"hljs-comment\">// 4</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c); <span class=\"hljs-comment\">// 4</span></span><br></pre></td></tr></tbody></table></figure>\n\n<img src=\"/images/js-weird-parts-operators-precendence-and-associactivity/1.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-operators-precendence-and-associactivity\">\n<p>從上圖可以了解到 = 運算子的相依性是右相依性（right to left, Right Associativity），<br>當運算子的優先性都相同時 Javacript 會優先執行右邊的運算子，然後向左一個一個執行。<br><code>a = b = c;</code> 表達式會先執行 <code>b = 4</code>，並且回傳 4 之後執行 <code>a = 4</code>。</p>\n<h1 id=\"大括號（parentheses）最優先\"><a href=\"#大括號（parentheses）最優先\" class=\"headerlink\" title=\"大括號（parentheses）最優先\"></a>大括號（parentheses）最優先</h1><img src=\"/images/js-weird-parts-operators-precendence-and-associactivity/2.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-operators-precendence-and-associactivity\">\n<p>當一個表達式中具有多個運算子，大括號（parentheses）裡的運算會最優先：</p>\n<figure class=\"highlight javascript hljs\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">var</span> a = (<span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">4</span>) * <span class=\"hljs-number\">5</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"hljs-comment\">// 35</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h1 id=\"amp-amp-優先性（precedence）比較\"><a href=\"#amp-amp-優先性（precedence）比較\" class=\"headerlink\" title=\"&amp;&amp; || 優先性（precedence）比較\"></a>&amp;&amp; || 優先性（precedence）比較</h1><img src=\"/images/js-weird-parts-operators-precendence-and-associactivity/3.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-operators-precendence-and-associactivity\">\n<p>在判斷式中經常同時使用 &amp;&amp;（and）與 ||（or），需要特別注意 &amp;&amp;（and）優先級是大於 ||（or）的，<br>不過若專案中有使用到 eslint 則會提示盡量補上大括號（parentheses），來協助辨認次序唷！</p>\n</body></html>",
            "tags": [
                "Javascript"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/06/05/zh-tw/js-weird-parts-III/",
            "url": "http://maomaoxie.github.io/2022/06/05/zh-tw/js-weird-parts-III/",
            "title": "克服 Javascript 的奇怪部分 單執行緒與同步執行",
            "date_published": "2022-06-05T08:31:07.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-single-threaded/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-single-threaded\">\n<p>這一個章節要來講解 JavaScript 的幾個觀念。</p>\n<h1 id=\"單執行緒（Single-Threaded）\"><a href=\"#單執行緒（Single-Threaded）\" class=\"headerlink\" title=\"單執行緒（Single Threaded）\"></a>單執行緒（Single Threaded）</h1><p><strong>一次一件事</strong>是重點。<br>這個特性不是瀏覽器的特性，瀏覽器一次可能同時處理多件事情，JavaScript 引擎則是單執行緒的，就像排隊買早餐，老闆娘一次只能處理一位客人，而 JavaScript 也是一次只處理一項指令。</p>\n<h1 id=\"同步執行（Synchronous）\"><a href=\"#同步執行（Synchronous）\" class=\"headerlink\" title=\"同步執行（Synchronous）\"></a>同步執行（Synchronous）</h1><p><strong>順序</strong>是重點。<br>事情有先後順序，按照順序執行，一次執行一行（或者說一個單元的程式碼，可能是一個陳述式或表達式）。</p>\n<h1 id=\"呼叫函式（Function-Invocation）\"><a href=\"#呼叫函式（Function-Invocation）\" class=\"headerlink\" title=\"呼叫函式（Function Invocation）\"></a>呼叫函式（Function Invocation）</h1><p>觸發或執行一個函式，使用的符號為大括號（parenthesis）。<br>JavaScript 引擎在執行函式呼叫時，會發生幾件事情延續前面的章節：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>呼叫函式</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">b</span> () {</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">a</span> () {</span><br><span class=\"line\">  <span class=\"title function_\">b</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">a</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"創造階段\"><a href=\"#創造階段\" class=\"headerlink\" title=\"創造階段\"></a>創造階段</h2><ol>\n<li>全域執行環境（Global Execution Context）首先被創造。</li>\n<li>全域物件（Global object）被創造。</li>\n<li>全域 this 被創造。</li>\n<li>開始編譯階段（Parsing），編譯器巡過一遍所有程式碼發現了函式 b 與 a，在記憶體創造兩個函式的空間並且存放整個函式內容。</li>\n</ol>\n<img src=\"/images/js-weird-parts-III/1.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-III\">\n\n<h2 id=\"執行階段\"><a href=\"#執行階段\" class=\"headerlink\" title=\"執行階段\"></a>執行階段</h2><ol>\n<li><p>整個程式碼的記憶體準備完畢後，開始執行程式。</p>\n</li>\n<li><p>編譯器解析到<strong>函式 a</strong>被呼叫，立即於全域執行環境上方，產生並堆疊一個函式 a 的執行環境（Execution Context），放進<strong>執行佇列堆（Execution Stack）</strong>中，每個執行環境都有自己得記憶體空間存放著變數或函式。</p>\n<img src=\"/images/js-weird-parts-III/2.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-III\">\n</li>\n<li><p>最上方的執行佇列會優先執行，進入函式 a 的執行環境（Execution Context）並且解析到函式 b，程序暫停，立即於函式 a 的執行環境上方，產生並堆疊一個函式 b 的執行環境（Execution Context），放進<strong>執行佇列堆（Execution Stack）</strong>中。</p>\n<img src=\"/images/js-weird-parts-III/3.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-III\"></li>\n</ol>\n<p>以上執行階段也可以拆分成好幾個創造（執行環境），與執行（執行佇列堆最上方的執行環境）階段，在當下的執行環境執行過程中，只要觸發另一個函式，執行暫停然後創造（執行環境）、與執行（執行佇列堆最上方的執行環境），而下方的程式碼不會被解析，除非該執行環境執行完畢並且離開執行佇列堆（Execution Stack）後才會繼續逐行執行。</p>\n<blockquote class=\"colorquote Info\"><p>Everytime a function is called, a new execution context is created for that function, the <code>this</code> variable is created for that function, the variables in it were set up in the creation phase, then the code is executed line by line.<br>whatever is on the top of the execution stack, is currently running synchronously.</p>\n</blockquote>\n\n<p>重點整理：<br>當一個函式被觸發或是呼叫，JS 引擎會創造一個屬於該函式的執行環境（execution context）並且放置在執行緒的最上方等待被執行，而該堆疊中具有該函式獨有的執行環境與 This，開始執行並且完成後離開堆疊中（pop out）繼續執行下一個堆疊，只要解析到新的函式被呼叫就會反覆以上行為，直到堆疊不斷（pop out）剩下全域執行環境本身為止。</p>\n</body></html>",
            "tags": [
                "Javascript"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/05/14/zh-tw/constructor-vs-instance/",
            "url": "http://maomaoxie.github.io/2022/05/14/zh-tw/constructor-vs-instance/",
            "title": "建構子方法與實例化方法",
            "date_published": "2022-05-14T13:37:03.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/constructor-vs-instance/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"constructor-vs-instance\">\n\n<p>在某天好奇想了解 Vue 3 的 defineProperty 原理搜尋了 <code>Object.defineProperty()</code> 這個方法時，看見以下說明：</p>\n<blockquote><p>靜態方法 <code>Object.defineProperty()</code> 會直接對一個物件定義、或是修改現有的屬性。執行後會回傳定義完的物件。<br>備註：這個方法會直接針對 Object 呼叫建構子（constructor），而不是 Object 型別的實例。</p>\n<footer><strong>MDN</strong><cite><a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\">Object.defineProperty()</a></cite></footer></blockquote>\n<p>其中的<strong>直接針對 Object 呼叫建構子（constructor），而不是 Object 型別的實例</strong>這句話突然讓我驚醒了，以前一直不能理解 javascript 中呼叫原生方法時，為何會有以下的區別：</p>\n<h2 id=\"透過建構器呼叫\"><a href=\"#透過建構器呼叫\" class=\"headerlink\" title=\"透過建構器呼叫\"></a>透過建構器呼叫</h2><p><code>Object.methods(objInstance)</code> -&gt; 例如 Object.keys(someObj)<br>這裡的 Object 是建構函式本身，未實例的藍圖（constructor）。</p>\n<h2 id=\"透過實例呼叫\"><a href=\"#透過實例呼叫\" class=\"headerlink\" title=\"透過實例呼叫\"></a>透過實例呼叫</h2><p><code>objInstance.methods(parameters)</code> -&gt; 例如 someObj.hasOwnProperty(‘prop’)<br>這裡的 Object 是實例化的物件（instance）。</p>\n<h2 id=\"Constructor-Static-Methods\"><a href=\"#Constructor-Static-Methods\" class=\"headerlink\" title=\"Constructor Static Methods\"></a>Constructor Static Methods</h2><h4 id=\"構造器-靜態方法\"><a href=\"#構造器-靜態方法\" class=\"headerlink\" title=\"構造器 靜態方法\"></a>構造器 靜態方法</h4><p>以下的例子是呼叫 Object 建構子中的原生 keys 方法，而不需要 new 一個物件實例就可以使用，靜態方法的特色是無需使用任何建構子中的 this 資料就可以直接使用。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>建構子方法</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> someone = {</span><br><span class=\"line\">  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Adam'</span>,</span><br><span class=\"line\">  <span class=\"hljs-attr\">carrer</span>: <span class=\"hljs-string\">'teacher'</span>,</span><br><span class=\"line\">  <span class=\"hljs-attr\">sex</span>: <span class=\"hljs-string\">'male'</span></span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> dataKeys = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(someone);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dataKeys);</span><br><span class=\"line\"><span class=\"hljs-comment\">// [\"name\",\"carrer\",\"sex\"]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Instance-methods\"><a href=\"#Instance-methods\" class=\"headerlink\" title=\"Instance methods\"></a>Instance methods</h3><h4 id=\"等號賦值-實例化方法\"><a href=\"#等號賦值-實例化方法\" class=\"headerlink\" title=\"等號賦值 實例化方法\"></a>等號賦值 實例化方法</h4><p>以下則是呼叫 Array 的實例化 push 方法，雖然也不是透過 new 來建立一個陣列，卻也是使用賦值一個陣列來建立陣列的實例，並且使用原生 push 方法。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>實例化方法 - 賦值</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> friends = [ <span class=\"hljs-string\">'Cally'</span>, <span class=\"hljs-string\">'Donna'</span>, <span class=\"hljs-string\">'Jell'</span> ];</span><br><span class=\"line\">friends.<span class=\"title function_\">push</span>(<span class=\"hljs-string\">'Liang'</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(friends);</span><br><span class=\"line\"><span class=\"hljs-comment\">// [\"Cally\",\"Donna\",\"Jell\",\"Liang\"]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"建構器-實例化方法\"><a href=\"#建構器-實例化方法\" class=\"headerlink\" title=\"建構器 實例化方法\"></a>建構器 實例化方法</h4><p>透過 new 來建立一個陣列。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>實例化方法 - 構造器</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> animals = <span class=\"hljs-keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"hljs-string\">'bunny'</span>, <span class=\"hljs-string\">'cat'</span>, <span class=\"hljs-string\">'puppy'</span>, <span class=\"hljs-string\">'hamster'</span>);</span><br><span class=\"line\">animals.<span class=\"title function_\">unshift</span>(<span class=\"hljs-string\">'bird'</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(animals);</span><br><span class=\"line\"><span class=\"hljs-comment\">// [\"bird\",\"bunny\",\"cat\",\"puppy\",\"hamster\"]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"構造器靜態方法補充\"><a href=\"#構造器靜態方法補充\" class=\"headerlink\" title=\"構造器靜態方法補充\"></a>構造器靜態方法補充</h2><h4 id=\"無法取得構造器的this資料\"><a href=\"#無法取得構造器的this資料\" class=\"headerlink\" title=\"無法取得構造器的this資料\"></a>無法取得構造器的this資料</h4><blockquote><ul>\n<li>The static method also cannot see the instance variable state so if we try to call the nonstatic method from the static method compiler will complain.</li>\n<li>The static method can be used to create utility functions.<br><a href=\"https://www.educba.com/javascript-static-method/\">https://www.educba.com/javascript-static-method/</a></li>\n</ul>\n</blockquote>\n\n<p>從上述可以得知靜態方法是不能取用構造器建構子（constructor）內的變數的（this binding），通常會撰寫純函式（pure function）以保持無狀態的特性，如同 Math 方法。<br>靜態方法適合用來當作全局複用的函式，適合較無副作用的邏輯。</p>\n<h2 id=\"兩種方法的原型鍊關係\"><a href=\"#兩種方法的原型鍊關係\" class=\"headerlink\" title=\"兩種方法的原型鍊關係\"></a>兩種方法的原型鍊關係</h2><p>若展開一個實例化的物件，會發現：</p>\n<ol>\n<li>建構器方法存在於建構子物件中（constructor），且只能透過建構器呼叫，例如 Object.assign()；</li>\n<li>實例化方法則存在於原型上（prototype），需要實例化之後才能呼叫，例如 objInstance.toLocaleString()</li>\n</ol>\n</body></html>",
            "tags": [
                "javascript",
                "constructor",
                "instance",
                "methods"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/03/12/zh-tw/short-circuit-and-optional-chaining/",
            "url": "http://maomaoxie.github.io/2022/03/12/zh-tw/short-circuit-and-optional-chaining/",
            "title": "短路解析 & 可選鍊修飾符",
            "date_published": "2022-03-12T05:55:02.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/short-circuit-and-optional-chaining/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"短路解析與可選練修飾符\">\n<p>在開發的情境上無論是串接 API 或者是資料判斷，都需要追求便捷而好懂的方式來維護程式碼，以利於當資料判斷變得複雜臃腫時仍可以邏輯清晰。而對於程式新手來說<code>undefined</code>（未定義）、<code>null</code>（空值）或者是<code>0</code>（零）在判斷上是很容易掉進去的陷阱，因為判定的方法了解的不深而陷入困境。</p>\n<h1 id=\"理解真假值\"><a href=\"#理解真假值\" class=\"headerlink\" title=\"理解真假值\"></a>理解真假值</h1><p>先介紹 truthy(真值) 與 falsy(假值)：</p>\n<ul>\n<li>truthy：非 falsy 的值，或者是表達式結果為 <code>true</code></li>\n<li>falsy：<code>undefined</code>、<code>null</code>、非數字 <code>NaN</code>、數字 <code>0</code>、數字 <code>-0</code>、BigInt <code>0n</code>、空字串<code>''</code>(字串長度為 0)，或者是表達式結果為 <code>false</code></li>\n</ul>\n<p>以下介紹幾種邏輯判斷的捷徑：</p>\n<h1 id=\"邏輯運算子-amp-amp\"><a href=\"#邏輯運算子-amp-amp\" class=\"headerlink\" title=\"邏輯運算子 &amp;&amp; ||\"></a>邏輯運算子 <code>&amp;&amp;</code> <code>||</code></h1><p>舉個栗子</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>邏輯運算子</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> numberAND = <span class=\"hljs-number\">6</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> numberOR = -<span class=\"hljs-number\">1</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">if</span>(numberAND &gt; <span class=\"hljs-number\">5</span> &amp;&amp; numberAND &lt; <span class=\"hljs-number\">7</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"hljs-string\">'哎呀'</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"hljs-keyword\">if</span>(numberOR &gt; <span class=\"hljs-number\">5</span> || numberOR &lt; <span class=\"hljs-number\">7</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"hljs-string\">'黑唷'</span>)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"人類的理解\"><a href=\"#人類的理解\" class=\"headerlink\" title=\"人類的理解\"></a>人類的理解</h3><p>當 numberAND 大於 5 且<strong>同時</strong>小於 7 值執行 <code>console.log('符合 &amp;&amp;')</code>；當 numberOR 大於 5 <strong>或者</strong>小於 7 值執行 <code>console.log('符合 ||')</code></p>\n<h3 id=\"電腦的理解\"><a href=\"#電腦的理解\" class=\"headerlink\" title=\"電腦的理解\"></a>電腦的理解</h3><p>當左邊的表達式 <code>numberAND &gt; 5</code> 結果為 <code>false</code> 則跳過右邊不執行 <code>numberAND &lt; 7</code>，直接<strong>跳出</strong>程式。<br>當左邊的表達式 <code>numberOR &gt; 5</code> 結果為 <code>true</code> 則跳過右邊不執行 <code>numberAND &lt; 7</code>，直接<strong>進入</strong>程式。</p>\n<p>結論為，當左邊的表達式符合條件，<code>&amp;&amp;</code> 的 if 直接跳出；<code>||</code> 的 if 直接進入。<br>來理一理箇中原由吧！</p>\n<h1 id=\"短路解析-Short-Circuit\"><a href=\"#短路解析-Short-Circuit\" class=\"headerlink\" title=\"短路解析(Short Circuit)\"></a>短路解析(Short Circuit)</h1><p>短路我個人覺得沒有捷徑來得好懂，短路比較讓人聯想為損毀或壞掉的電子產品，而捷徑則代表透過偷吃步或者抄捷徑的方式以取得一樣的結果。這裡的短路較接近後者，js 運行上的偷吃步：</p>\n<h3 id=\"amp-amp-的短路解析\"><a href=\"#amp-amp-的短路解析\" class=\"headerlink\" title=\"&amp;&amp; 的短路解析\"></a><code>&amp;&amp;</code> 的短路解析</h3><p>當左邊的表達式為 <code>false</code> 就返回左邊的表達式結果，並且<strong>直接忽視</strong>右邊的表達式結果，反之執行右邊的表達式。</p>\n<h3 id=\"的短路解析\"><a href=\"#的短路解析\" class=\"headerlink\" title=\"|| 的短路解析\"></a><code>||</code> 的短路解析</h3><p>當左邊的表達式為 <code>true</code> 就返回左邊的表達式結果，並且<strong>直接忽視</strong>右邊的表達式結果，反之執行右邊的表達式。</p>\n<p>以上可以知道 js 執行完左邊的表達式之後，若符合條件則直接跳過右邊的表達式(不解析亦不執行)，相對來講當開發人員在理解短路解析時就可以按照這樣的邏輯去快速判斷結果。</p>\n<p>速記法：AND<code>false</code>跳出、OR<code>true</code>進入(執行)。</p>\n<blockquote><p>if you use <code>||</code> to provide some default value to another variable foo, you may encounter unexpected behaviors if you consider some falsy values as usable (e.g., <code>''</code> or <code>0</code>). </p>\n</blockquote>\n\n<h1 id=\"可選鍊修飾符-Optional-chaining\"><a href=\"#可選鍊修飾符-Optional-chaining\" class=\"headerlink\" title=\"可選鍊修飾符(Optional chaining)\"></a>可選鍊修飾符(Optional chaining)</h1><p>舉個栗子</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>可選鍊修飾符</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> user = {};</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(user.<span class=\"hljs-property\">address</span>);</span><br><span class=\"line\"><span class=\"hljs-comment\">// undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(user.<span class=\"hljs-property\">address</span>.<span class=\"hljs-property\">street</span>);</span><br><span class=\"line\"><span class=\"hljs-comment\">// error</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(user.<span class=\"hljs-property\">address</span>?.<span class=\"hljs-property\">street</span>);</span><br><span class=\"line\"><span class=\"hljs-comment\">// undefined</span></span><br></pre></td></tr></tbody></table></figure>\n<p>在這個範例中，user 物件的清單中有部分的使用者缺少了 <code>address</code> 這個屬性，但是大部分的使用者都具有該屬性時，就可以使用可選鍊修飾符來避免程式噴錯而中斷，但是需注意避免<strong>過度使用</strong>可選鍊修飾符</p>\n<h1 id=\"空值合併運算子-Nullish-coalescing-operator\"><a href=\"#空值合併運算子-Nullish-coalescing-operator\" class=\"headerlink\" title=\"空值合併運算子(Nullish coalescing operator) ??\"></a>空值合併運算子(Nullish coalescing operator) <code>??</code></h1><p>舉個栗子</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>空值合併運算子</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">notNullish</span> (a, b) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a ?? b);</span><br><span class=\"line\">}</span><br><span class=\"line\">notNullish (<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">// null</span></span><br><span class=\"line\">notNullish (<span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">undefined</span>); <span class=\"hljs-comment\">// undefined</span></span><br><span class=\"line\">notNullish (<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 0</span></span><br><span class=\"line\">notNullish (<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">''</span>); <span class=\"hljs-comment\">// ''</span></span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>ES2020（ES11）提供的「空值合併運算子」，支援度需要搭配 babel 套件。</li>\n<li><code>??</code>常常與邏輯運算子 <code>||</code> 比較，前者返回非 <code>undefined</code> 與 <code>null</code> 的表達式，後者返回非 falsy 的表達式。過濾的條件上有區別，可以依照需求使用。</li>\n</ul>\n<h3 id=\"的短路解析-1\"><a href=\"#的短路解析-1\" class=\"headerlink\" title=\"?? 的短路解析\"></a><code>??</code> 的短路解析</h3><p>當左邊的表達式為 非 <code>undefined</code> 與 <code>null</code> 就返回左邊的表達式結果，並且<strong>直接忽視</strong>右邊的表達式結果，反之執行右邊的表達式。</p>\n</body></html>",
            "tags": [
                "javascript",
                "shortCircuit",
                "optionalChaining",
                "tricks"
            ]
        }
    ]
}