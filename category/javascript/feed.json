{
    "version": "https://jsonfeed.org/version/1",
    "title": "Mawchu 貓奴前端的天空 • All posts by \"javascript\" category",
    "description": "Mawchu 貓奴前端，為熱愛平面設計與貓咪的前端工程師 - 謝佳芳（毛球）的技術部落格，喜歡撰寫技術文章幫助自己在前端之路成長，涉及 Javascript、Vue、Laravel 與其他程式相關的討論與學習",
    "home_page_url": "http://maomaoxie.github.io",
    "items": [
        {
            "id": "http://maomaoxie.github.io/2022/06/05/zh-tw/js-weird-parts-III/",
            "url": "http://maomaoxie.github.io/2022/06/05/zh-tw/js-weird-parts-III/",
            "title": "克服 Javascript 的奇怪部分 單執行緒與同步執行",
            "date_published": "2022-06-05T08:31:07.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/js-weird-parts-single-threaded/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"js-weird-parts-single-threaded\">\n<p>這一個章節要來講解 JavaScript 的幾個觀念。</p>\n<h1 id=\"單執行緒（Single-Threaded）\"><a href=\"#單執行緒（Single-Threaded）\" class=\"headerlink\" title=\"單執行緒（Single Threaded）\"></a>單執行緒（Single Threaded）</h1><p><strong>一次一件事</strong>是重點。<br>這個特性不是瀏覽器的特性，瀏覽器一次可能同時處理多件事情，JavaScript 引擎則是單執行緒的，就像排隊買早餐，老闆娘一次只能處理一位客人，而 JavaScript 也是一次只處理一項指令。</p>\n<h1 id=\"同步執行（Synchronous）\"><a href=\"#同步執行（Synchronous）\" class=\"headerlink\" title=\"同步執行（Synchronous）\"></a>同步執行（Synchronous）</h1><p><strong>順序</strong>是重點。<br>事情有先後順序，按照順序執行，一次執行一行（或者說一個單元的程式碼，可能是一個陳述式或表達式）。</p>\n<h1 id=\"呼叫函式（Function-Invocation）\"><a href=\"#呼叫函式（Function-Invocation）\" class=\"headerlink\" title=\"呼叫函式（Function Invocation）\"></a>呼叫函式（Function Invocation）</h1><p>觸發或執行一個函式，使用的符號為大括號（parenthesis）。<br>JavaScript 引擎在執行函式呼叫時，會發生幾件事情延續前面的章節：</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>呼叫函式</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">b</span> () {</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">a</span> () {</span><br><span class=\"line\">  <span class=\"title function_\">b</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">a</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"創造階段\"><a href=\"#創造階段\" class=\"headerlink\" title=\"創造階段\"></a>創造階段</h2><ol>\n<li>全域執行環境（Global Execution Context）首先被創造。</li>\n<li>全域物件（Global object）被創造。</li>\n<li>全域 this 被創造。</li>\n<li>開始編譯階段（Parsing），編譯器巡過一遍所有程式碼發現了函式 b 與 a，在記憶體創造兩個函式的空間並且存放整個函式內容。</li>\n</ol>\n<img src=\"/images/js-weird-parts-III/1.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-III\">\n\n<h2 id=\"執行階段\"><a href=\"#執行階段\" class=\"headerlink\" title=\"執行階段\"></a>執行階段</h2><ol>\n<li><p>整個程式碼的記憶體準備完畢後，開始執行程式。</p>\n</li>\n<li><p>編譯器解析到<strong>函式 a</strong>被呼叫，立即於全域執行環境上方，產生並堆疊一個函式 a 的執行環境（Execution Context），放進<strong>執行佇列堆（Execution Stack）</strong>中，每個執行環境都有自己得記憶體空間存放著變數或函式。</p>\n<img src=\"/images/js-weird-parts-III/2.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-III\">\n</li>\n<li><p>最上方的執行佇列會優先執行，進入函式 a 的執行環境（Execution Context）並且解析到函式 b，程序暫停，立即於函式 a 的執行環境上方，產生並堆疊一個函式 b 的執行環境（Execution Context），放進<strong>執行佇列堆（Execution Stack）</strong>中。</p>\n<img src=\"/images/js-weird-parts-III/3.png\" class=\"\" width=\"400\" height=\"200\" title=\"js-weird-parts-III\"></li>\n</ol>\n<p>以上執行階段也可以拆分成好幾個創造（執行環境），與執行（執行佇列堆最上方的執行環境）階段，在當下的執行環境執行過程中，只要觸發另一個函式，執行暫停然後創造（執行環境）、與執行（執行佇列堆最上方的執行環境），而下方的程式碼不會被解析，除非該執行環境執行完畢並且離開執行佇列堆（Execution Stack）後才會繼續逐行執行。</p>\n<blockquote class=\"colorquote Info\"><p>Everytime a function is called, a new execution context is created for that function, the <code>this</code> variable is created for that function, the variables in it were set up in the creation phase, then the code is executed line by line.<br>whatever is on the top of the execution stack, is currently running synchronously.</p>\n</blockquote>\n\n<p>重點整理：<br>當一個函式被觸發或是呼叫，JS 引擎會創造一個屬於該函式的執行環境（execution context）並且放置在執行緒的最上方等待被執行，而該堆疊中具有該函式獨有的執行環境與 This，開始執行並且完成後離開堆疊中（pop out）繼續執行下一個堆疊，只要解析到新的函式被呼叫就會反覆以上行為，直到堆疊不斷（pop out）剩下全域執行環境本身為止。</p>\n</body></html>",
            "tags": [
                "Javascript"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/05/14/zh-tw/constructor-vs-instance/",
            "url": "http://maomaoxie.github.io/2022/05/14/zh-tw/constructor-vs-instance/",
            "title": "建構子方法與實例化方法",
            "date_published": "2022-05-14T13:37:03.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/constructor-vs-instance/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"constructor-vs-instance\">\n\n<p>在某天好奇想了解 Vue 3 的 defineProperty 原理搜尋了 <code>Object.defineProperty()</code> 這個方法時，看見以下說明：</p>\n<blockquote><p>靜態方法 <code>Object.defineProperty()</code> 會直接對一個物件定義、或是修改現有的屬性。執行後會回傳定義完的物件。<br>備註：這個方法會直接針對 Object 呼叫建構子（constructor），而不是 Object 型別的實例。</p>\n<footer><strong>MDN</strong><cite><a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\">Object.defineProperty()</a></cite></footer></blockquote>\n<p>其中的<strong>直接針對 Object 呼叫建構子（constructor），而不是 Object 型別的實例</strong>這句話突然讓我驚醒了，以前一直不能理解 javascript 中呼叫原生方法時，為何會有以下的區別：</p>\n<h2 id=\"透過建構器呼叫\"><a href=\"#透過建構器呼叫\" class=\"headerlink\" title=\"透過建構器呼叫\"></a>透過建構器呼叫</h2><p><code>Object.methods(objInstance)</code> -&gt; 例如 Object.keys(someObj)<br>這裡的 Object 是建構函式本身，未實例的藍圖（constructor）。</p>\n<h2 id=\"透過實例呼叫\"><a href=\"#透過實例呼叫\" class=\"headerlink\" title=\"透過實例呼叫\"></a>透過實例呼叫</h2><p><code>objInstance.methods(parameters)</code> -&gt; 例如 someObj.hasOwnProperty(‘prop’)<br>這裡的 Object 是實例化的物件（instance）。</p>\n<h2 id=\"Constructor-Static-Methods\"><a href=\"#Constructor-Static-Methods\" class=\"headerlink\" title=\"Constructor Static Methods\"></a>Constructor Static Methods</h2><h4 id=\"構造器-靜態方法\"><a href=\"#構造器-靜態方法\" class=\"headerlink\" title=\"構造器 靜態方法\"></a>構造器 靜態方法</h4><p>以下的例子是呼叫 Object 建構子中的原生 keys 方法，而不需要 new 一個物件實例就可以使用，靜態方法的特色是無需使用任何建構子中的 this 資料就可以直接使用。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>建構子方法</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> someone = {</span><br><span class=\"line\">  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Adam'</span>,</span><br><span class=\"line\">  <span class=\"hljs-attr\">carrer</span>: <span class=\"hljs-string\">'teacher'</span>,</span><br><span class=\"line\">  <span class=\"hljs-attr\">sex</span>: <span class=\"hljs-string\">'male'</span></span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> dataKeys = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(someone);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dataKeys);</span><br><span class=\"line\"><span class=\"hljs-comment\">// [\"name\",\"carrer\",\"sex\"]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Instance-methods\"><a href=\"#Instance-methods\" class=\"headerlink\" title=\"Instance methods\"></a>Instance methods</h3><h4 id=\"等號賦值-實例化方法\"><a href=\"#等號賦值-實例化方法\" class=\"headerlink\" title=\"等號賦值 實例化方法\"></a>等號賦值 實例化方法</h4><p>以下則是呼叫 Array 的實例化 push 方法，雖然也不是透過 new 來建立一個陣列，卻也是使用賦值一個陣列來建立陣列的實例，並且使用原生 push 方法。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>實例化方法 - 賦值</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> friends = [ <span class=\"hljs-string\">'Cally'</span>, <span class=\"hljs-string\">'Donna'</span>, <span class=\"hljs-string\">'Jell'</span> ];</span><br><span class=\"line\">friends.<span class=\"title function_\">push</span>(<span class=\"hljs-string\">'Liang'</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(friends);</span><br><span class=\"line\"><span class=\"hljs-comment\">// [\"Cally\",\"Donna\",\"Jell\",\"Liang\"]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"建構器-實例化方法\"><a href=\"#建構器-實例化方法\" class=\"headerlink\" title=\"建構器 實例化方法\"></a>建構器 實例化方法</h4><p>透過 new 來建立一個陣列。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>實例化方法 - 構造器</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> animals = <span class=\"hljs-keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"hljs-string\">'bunny'</span>, <span class=\"hljs-string\">'cat'</span>, <span class=\"hljs-string\">'puppy'</span>, <span class=\"hljs-string\">'hamster'</span>);</span><br><span class=\"line\">animals.<span class=\"title function_\">unshift</span>(<span class=\"hljs-string\">'bird'</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(animals);</span><br><span class=\"line\"><span class=\"hljs-comment\">// [\"bird\",\"bunny\",\"cat\",\"puppy\",\"hamster\"]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"構造器靜態方法補充\"><a href=\"#構造器靜態方法補充\" class=\"headerlink\" title=\"構造器靜態方法補充\"></a>構造器靜態方法補充</h2><h4 id=\"無法取得構造器的this資料\"><a href=\"#無法取得構造器的this資料\" class=\"headerlink\" title=\"無法取得構造器的this資料\"></a>無法取得構造器的this資料</h4><blockquote><ul>\n<li>The static method also cannot see the instance variable state so if we try to call the nonstatic method from the static method compiler will complain.</li>\n<li>The static method can be used to create utility functions.<br><a href=\"https://www.educba.com/javascript-static-method/\">https://www.educba.com/javascript-static-method/</a></li>\n</ul>\n</blockquote>\n\n<p>從上述可以得知靜態方法是不能取用構造器建構子（constructor）內的變數的（this binding），通常會撰寫純函式（pure function）以保持無狀態的特性，如同 Math 方法。<br>靜態方法適合用來當作全局複用的函式，適合較無副作用的邏輯。</p>\n<h2 id=\"兩種方法的原型鍊關係\"><a href=\"#兩種方法的原型鍊關係\" class=\"headerlink\" title=\"兩種方法的原型鍊關係\"></a>兩種方法的原型鍊關係</h2><p>若展開一個實例化的物件，會發現：</p>\n<ol>\n<li>建構器方法存在於建構子物件中（constructor），且只能透過建構器呼叫，例如 Object.assign()；</li>\n<li>實例化方法則存在於原型上（prototype），需要實例化之後才能呼叫，例如 objInstance.toLocaleString()</li>\n</ol>\n</body></html>",
            "tags": [
                "javascript",
                "constructor",
                "instance",
                "methods"
            ]
        },
        {
            "id": "http://maomaoxie.github.io/2022/03/12/zh-tw/short-circuit-and-optional-chaining/",
            "url": "http://maomaoxie.github.io/2022/03/12/zh-tw/short-circuit-and-optional-chaining/",
            "title": "短路解析 & 可選鍊修飾符",
            "date_published": "2022-03-12T05:55:02.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/short-circuit-and-optional-chaining/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"短路解析與可選練修飾符\">\n<p>在開發的情境上無論是串接 API 或者是資料判斷，都需要追求便捷而好懂的方式來維護程式碼，以利於當資料判斷變得複雜臃腫時仍可以邏輯清晰。而對於程式新手來說<code>undefined</code>（未定義）、<code>null</code>（空值）或者是<code>0</code>（零）在判斷上是很容易掉進去的陷阱，因為判定的方法了解的不深而陷入困境。</p>\n<h1 id=\"理解真假值\"><a href=\"#理解真假值\" class=\"headerlink\" title=\"理解真假值\"></a>理解真假值</h1><p>先介紹 truthy(真值) 與 falsy(假值)：</p>\n<ul>\n<li>truthy：非 falsy 的值，或者是表達式結果為 <code>true</code></li>\n<li>falsy：<code>undefined</code>、<code>null</code>、非數字 <code>NaN</code>、數字 <code>0</code>、數字 <code>-0</code>、BigInt <code>0n</code>、空字串<code>''</code>(字串長度為 0)，或者是表達式結果為 <code>false</code></li>\n</ul>\n<p>以下介紹幾種邏輯判斷的捷徑：</p>\n<h1 id=\"邏輯運算子-amp-amp\"><a href=\"#邏輯運算子-amp-amp\" class=\"headerlink\" title=\"邏輯運算子 &amp;&amp; ||\"></a>邏輯運算子 <code>&amp;&amp;</code> <code>||</code></h1><p>舉個栗子</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>邏輯運算子</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> numberAND = <span class=\"hljs-number\">6</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> numberOR = -<span class=\"hljs-number\">1</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">if</span>(numberAND &gt; <span class=\"hljs-number\">5</span> &amp;&amp; numberAND &lt; <span class=\"hljs-number\">7</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"hljs-string\">'哎呀'</span>)</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"hljs-keyword\">if</span>(numberOR &gt; <span class=\"hljs-number\">5</span> || numberOR &lt; <span class=\"hljs-number\">7</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"hljs-string\">'黑唷'</span>)</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"人類的理解\"><a href=\"#人類的理解\" class=\"headerlink\" title=\"人類的理解\"></a>人類的理解</h3><p>當 numberAND 大於 5 且<strong>同時</strong>小於 7 值執行 <code>console.log('符合 &amp;&amp;')</code>；當 numberOR 大於 5 <strong>或者</strong>小於 7 值執行 <code>console.log('符合 ||')</code></p>\n<h3 id=\"電腦的理解\"><a href=\"#電腦的理解\" class=\"headerlink\" title=\"電腦的理解\"></a>電腦的理解</h3><p>當左邊的表達式 <code>numberAND &gt; 5</code> 結果為 <code>false</code> 則跳過右邊不執行 <code>numberAND &lt; 7</code>，直接<strong>跳出</strong>程式。<br>當左邊的表達式 <code>numberOR &gt; 5</code> 結果為 <code>true</code> 則跳過右邊不執行 <code>numberAND &lt; 7</code>，直接<strong>進入</strong>程式。</p>\n<p>結論為，當左邊的表達式符合條件，<code>&amp;&amp;</code> 的 if 直接跳出；<code>||</code> 的 if 直接進入。<br>來理一理箇中原由吧！</p>\n<h1 id=\"短路解析-Short-Circuit\"><a href=\"#短路解析-Short-Circuit\" class=\"headerlink\" title=\"短路解析(Short Circuit)\"></a>短路解析(Short Circuit)</h1><p>短路我個人覺得沒有捷徑來得好懂，短路比較讓人聯想為損毀或壞掉的電子產品，而捷徑則代表透過偷吃步或者抄捷徑的方式以取得一樣的結果。這裡的短路較接近後者，js 運行上的偷吃步：</p>\n<h3 id=\"amp-amp-的短路解析\"><a href=\"#amp-amp-的短路解析\" class=\"headerlink\" title=\"&amp;&amp; 的短路解析\"></a><code>&amp;&amp;</code> 的短路解析</h3><p>當左邊的表達式為 <code>false</code> 就返回左邊的表達式結果，並且<strong>直接忽視</strong>右邊的表達式結果，反之執行右邊的表達式。</p>\n<h3 id=\"的短路解析\"><a href=\"#的短路解析\" class=\"headerlink\" title=\"|| 的短路解析\"></a><code>||</code> 的短路解析</h3><p>當左邊的表達式為 <code>true</code> 就返回左邊的表達式結果，並且<strong>直接忽視</strong>右邊的表達式結果，反之執行右邊的表達式。</p>\n<p>以上可以知道 js 執行完左邊的表達式之後，若符合條件則直接跳過右邊的表達式(不解析亦不執行)，相對來講當開發人員在理解短路解析時就可以按照這樣的邏輯去快速判斷結果。</p>\n<p>速記法：AND<code>false</code>跳出、OR<code>true</code>進入(執行)。</p>\n<blockquote><p>if you use <code>||</code> to provide some default value to another variable foo, you may encounter unexpected behaviors if you consider some falsy values as usable (e.g., <code>''</code> or <code>0</code>). </p>\n</blockquote>\n\n<h1 id=\"可選鍊修飾符-Optional-chaining\"><a href=\"#可選鍊修飾符-Optional-chaining\" class=\"headerlink\" title=\"可選鍊修飾符(Optional chaining)\"></a>可選鍊修飾符(Optional chaining)</h1><p>舉個栗子</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>可選鍊修飾符</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">let</span> user = {};</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(user.<span class=\"hljs-property\">address</span>);</span><br><span class=\"line\"><span class=\"hljs-comment\">// undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(user.<span class=\"hljs-property\">address</span>.<span class=\"hljs-property\">street</span>);</span><br><span class=\"line\"><span class=\"hljs-comment\">// error</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(user.<span class=\"hljs-property\">address</span>?.<span class=\"hljs-property\">street</span>);</span><br><span class=\"line\"><span class=\"hljs-comment\">// undefined</span></span><br></pre></td></tr></tbody></table></figure>\n<p>在這個範例中，user 物件的清單中有部分的使用者缺少了 <code>address</code> 這個屬性，但是大部分的使用者都具有該屬性時，就可以使用可選鍊修飾符來避免程式噴錯而中斷，但是需注意避免<strong>過度使用</strong>可選鍊修飾符</p>\n<h1 id=\"空值合併運算子-Nullish-coalescing-operator\"><a href=\"#空值合併運算子-Nullish-coalescing-operator\" class=\"headerlink\" title=\"空值合併運算子(Nullish coalescing operator) ??\"></a>空值合併運算子(Nullish coalescing operator) <code>??</code></h1><p>舉個栗子</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>空值合併運算子</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">function</span> <span class=\"title function_\">notNullish</span> (a, b) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a ?? b);</span><br><span class=\"line\">}</span><br><span class=\"line\">notNullish (<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-literal\">null</span>); <span class=\"hljs-comment\">// null</span></span><br><span class=\"line\">notNullish (<span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">undefined</span>); <span class=\"hljs-comment\">// undefined</span></span><br><span class=\"line\">notNullish (<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 0</span></span><br><span class=\"line\">notNullish (<span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">''</span>); <span class=\"hljs-comment\">// ''</span></span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>ES2020（ES11）提供的「空值合併運算子」，支援度需要搭配 babel 套件。</li>\n<li><code>??</code>常常與邏輯運算子 <code>||</code> 比較，前者返回非 <code>undefined</code> 與 <code>null</code> 的表達式，後者返回非 falsy 的表達式。過濾的條件上有區別，可以依照需求使用。</li>\n</ul>\n<h3 id=\"的短路解析-1\"><a href=\"#的短路解析-1\" class=\"headerlink\" title=\"?? 的短路解析\"></a><code>??</code> 的短路解析</h3><p>當左邊的表達式為 非 <code>undefined</code> 與 <code>null</code> 就返回左邊的表達式結果，並且<strong>直接忽視</strong>右邊的表達式結果，反之執行右邊的表達式。</p>\n</body></html>",
            "tags": [
                "javascript",
                "shortCircuit",
                "optionalChaining",
                "tricks"
            ]
        }
    ]
}