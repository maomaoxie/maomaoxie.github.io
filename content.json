{"pages":[{"title":"關於我","text":"熱愛平面設計與貓咪的前端蔡蔡子，仍在前端的路上努力中。","link":"/zh-tw/about/index.html"},{"title":"文章列表","text":"","link":"/zh-tw/archives/index.html"}],"posts":[{"title":"建構子方法與實例化方法","text":"在某天好奇想了解 Vue 3 的 defineProperty 原理搜尋了 Object.defineProperty() 這個方法時，看見以下說明： 靜態方法 Object.defineProperty() 會直接對一個物件定義、或是修改現有的屬性。執行後會回傳定義完的物件。備註：這個方法會直接針對 Object 呼叫建構子（constructor），而不是 Object 型別的實例。 MDNObject.defineProperty() 其中的直接針對 Object 呼叫建構子（constructor），而不是 Object 型別的實例這句話突然讓我驚醒了，以前一直不能理解 javascript 中呼叫原生方法時，為何會有以下的區別： 透過建構器呼叫Object.methods(objInstance) -&gt; 例如 Object.keys(someObj)這裡的 Object 是建構函式本身，未實例的藍圖（constructor）。 透過實例呼叫objInstance.methods(parameters) -&gt; 例如 someObj.hasOwnProperty(‘prop’)這裡的 Object 是實例化的物件（instance）。 Constructor Static Methods構造器 靜態方法以下的例子是呼叫 Object 建構子中的原生 keys 方法，而不需要 new 一個物件實例就可以使用，靜態方法的特色是無需使用任何建構子中的 this 資料就可以直接使用。 建構子方法12345678const someone = { name: 'Adam', carrer: 'teacher', sex: 'male'};const dataKeys = Object.keys(someone);console.log(dataKeys);// [\"name\",\"carrer\",\"sex\"] Instance methods等號賦值 實例化方法以下則是呼叫 Array 的實例化 push 方法，雖然也不是透過 new 來建立一個陣列，卻也是使用賦值一個陣列來建立陣列的實例，並且使用原生 push 方法。 實例化方法 - 賦值1234const friends = [ 'Cally', 'Donna', 'Jell' ];friends.push('Liang');console.log(friends);// [\"Cally\",\"Donna\",\"Jell\",\"Liang\"] 建構器 實例化方法透過 new 來建立一個陣列。 實例化方法 - 構造器1234const animals = new Array('bunny', 'cat', 'puppy', 'hamster');animals.unshift('bird');console.log(animals);// [\"bird\",\"bunny\",\"cat\",\"puppy\",\"hamster\"] 構造器靜態方法補充無法取得構造器的this資料 The static method also cannot see the instance variable state so if we try to call the nonstatic method from the static method compiler will complain. The static method can be used to create utility functions.https://www.educba.com/javascript-static-method/ 從上述可以得知靜態方法是不能取用構造器建構子（constructor）內的變數的（this binding），通常會撰寫純函式（pure function）以保持無狀態的特性，如同 Math 方法。靜態方法適合用來當作全局複用的函式，適合較無副作用的邏輯。 兩種方法的原型鍊關係若展開一個實例化的物件，會發現： 建構器方法存在於建構子物件中（constructor），且只能透過建構器呼叫，例如 Object.assign()； 實例化方法則存在於原型上（prototype），需要實例化之後才能呼叫，例如 objInstance.toLocaleString()","link":"/2022/05/14/zh-tw/constructor-vs-instance/"},{"title":"Express 路由模組化","text":"圖片來源: https://inmywordz.com/archives/504當路由越寫越多變成霍爾的移動城堡一樣雜亂肥大時，自己都看得眼花撩亂啦～考慮使用模組化的概念來統整自己的後端路由是很好的選擇，那麼就來開始吧！ Express.js 4.0 Router 的誕生Express 輕量框架提供很多整理路由的方式，Express.js 4.0 導入了新的 Router 功能，可以更彈性的撰寫子路由規則以及中介軟體啦！ Express.js 4.0 有加入一個新的 Router 功能，它就像一個迷你的應用程式，可以讓應用程式內部的路由撰寫更方便、更有彈性。Express.js 在 4.0 版中有許多新的功能，其中一項主要的功能就是 Router，以下我們介紹如何使用 Router 功能來撰寫應用程式。https://blog.gtwang.org/programming/learn-to-use-the-new-router-in-expressjs-4/ app.use() 產生父路由與路由頭中介app.use(); mounts middleware for all routes of the app (or those matching the routes specified if you use app.use(‘/ANYROUTESHERE’, yourMiddleware());). app.use() 是啟用一個路由頭（父路由），並且只要符合該路由頭的每一個子路由，該中介軟體都會啟用，很適合用在登入後驗證是否有登入的會員，是否有訪問路由頁面的權限，以撰寫一些驗證信息。 router.methods() 產生子路由舊的子路由寫法123456789101112const express = require('express');const app = express();const router = express.Router();const port = 5500;app.get('/', function(req, res) { res.send('舊的寫法：歡迎來到首頁')})app.listen(port, () =&gt; { console.log(`Example app listening on port ${port}`)}) 新的子路由寫法123456789101112131415161718const express = require('express');const app = express();const router = express.Router();const port = 5500;router.get('/', function(req, res) { res.send('新的寫法：歡迎來到首頁')})router.get('/page', function(req, res) { res.send('新的寫法：歡迎來到分頁')})// 制定一個路由頭（父路由）app.use('/api', router)app.listen(port, () =&gt; { console.log(`Example app listening on port ${port}`)}) 我自己是看不太出來差別，不過文章都是寫道 router 就像一個小型 app 提供你整理路由系統更好的方法，而具體的差異如下： “A Router doesn’t .listen() for requests on its own”. That might be the main difference.It’s useful for separating your application into multiple modules – creating a Router in each that the app can require() and .use() as middleware. Router 不能單個路由做 port 監聽 Router 可以使用 require() 與 use() 模組化管理子路由 哪一種比較好眾說紛紜，基本上能適合專案模式的都是好方法。 router.use(); mounts middleware for the routes served by the specific routerrouter.get is only for defining subpaths.Consider this example: 12345var router = express.Router();app.use('/first', router); // Mount the router as middleware at path /firstrouter.get('/sud', smaller);router.get('/user', bigger); If you open /first/sud, then the smaller function will get called. If you open /first/user, then the bigger function will get called. In short, app.use('/first', router) mounts the middleware at path /first, then router.get sets the subpath accordingly. https://stackoverflow.com/questions/27227650/difference-between-app-use-and-router-use-in-express router.use() 子路由中介router.use() 是產生子路由中介（middleware）的方式： 在使用 middleware 時必須要注意他的放置位置必須要在 routes 之前，程式在執行的時候會依據 middleware 與 routes 的先後順序來執行，如果不小心將 middleware 放在 routes 之後，那麼在 routes 處理完請求之後就會結束處理的流程，這樣 middleware 就根本不會執行。https://blog.gtwang.org/programming/learn-to-use-the-new-router-in-expressjs-4/ 1234567891011121314// 中介軟體要寫在 router 上面router.use(function(req, res, next) { // 輸出記錄訊息至終端機 const url = `${req.protocol}://${req.hostname}:${port}${req.baseUrl}${req.path}`; console.log(url, '子路由會經過我'); // 繼續路由處理 next();})router.get('/', function(req, res) { res.send('新的寫法：歡迎來到首頁')})router.get('/page', function(req, res) { res.send('新的寫法：歡迎來到分頁')}) router 模組化子路由模塊將幾個子路徑依功能切開可以更方便的統整路由： ./routers/cat.js12345678910111213141516171819202122const express = require('express');const router = express.Router();const port = 5500router.use(function(req, res, next) { // 輸出記錄訊息至終端機 const url = `${req.protocol}://${req.hostname}:${port}${req.baseUrl}${req.path}`; console.log(url, '喵喵子路由會經過我'); // 繼續路由處理 next();})router.get('/', function(req, res) { const url = `${req.protocol}://${req.hostname}:${port}${req.baseUrl}${req.path}`; res.send('來到喵喵子路由');});router.get('/meow', function(req, res) { res.send('喵喵分頁');});module.exports = router; 引用模塊在入口引入模塊： index.js123456789101112const express = require('express');const app = express();const router = express.Router();const catsRouter = require('./routes/cat')const port = 5500;// 模組寫法app.use('/cat', catsRouter) app.listen(port, () =&gt; { console.log(`Example app listening on port ${port}`)}) 參考文章： https://stackoverflow.com/questions/27227650/difference-between-app-use-and-router-use-in-expresshttps://blog.gtwang.org/programming/learn-to-use-the-new-router-in-expressjs-4/http://expressjs.com/zh-tw/api.html#req","link":"/2022/02/20/zh-tw/express-router-module/"},{"title":"Github 主分支更名 master 為 main","text":"每每 github 搞了一些新招就得重新適應一次（菸 這兩天在做小專案 git init 之後準備推上去 github 時，執行以下的老樣子： 1git remote add origin https://github.com/mawchu/baby-bill.git 看到這裡不免疑惑了一下，不是印象中的 branch 名字呀： 1git branch -M main 果然執行之後出現噴錯的內容： error: refname refs/heads/master not foundfatal: Branch rename failed 這個 main 分支從哪裡冒出來的？暗暗覺得這個行為很雞肋= =？ 為響應黑人平權運動，GitHub宣布從10月1日起改變新Git儲存庫的預設命名，以main來取代原本的master。受到年中佛洛依德（George Floyd）遭警方執法過當死亡，引發的黑人平權抗議風潮影響，美國科技界也相繼思考去除慣用名稱中有種族歧視色彩的字眼，例如不要使用master/slave、blacklist/whitelist。GitHub執行長Nat Friedman也決定進行相關改變。 開發人員也可以不要變更，隨時到設定區，把個人、組織和公司的新儲存庫預設命名從main改成別的。GitHub呼籲用戶可以先保持不動，到了年底會再釋出新工具以協助現有branch改成新的預設名稱。在支持黑人平權風潮下，包括Google、微軟、IBM、Red Hat、甲骨文下的MySQL及Linux社群都相繼變更了軟體流程的命名。本月微軟也提案修改Chromium中black/whitelist為較中性的blocklist/allowlist。https://www.ithome.com.tw/news/140094 查看了一下網路說明，原來是美國的政治與歷史因素，生活跟科技真是息息相關呢，自己的見識尚淺默默反省了一下XD科普了一會怎麼切換現今的分支變成 main： 1git add . 1git commit -m \"要推的備註內容\" 都 OK 就可以推上去囉！ 1git push -u origin main 推上去發現自己忘了切換帳號又噴錯啦！ remote: Permission to mawchu/baby-bill.git denied to maomaoxie.fatal: unable to access ‘https://github.com/mawchu/baby-bill.git/': The requested URL returned error: 403 由於 git bash 切換帳戶不是那麼方便，就偷吃步一下重複 Github 登入新制 PAT X Sourcetree 這篇的步驟就可以囉！ 參考文章： https://blog.csdn.net/taoshihan/article/details/116824815?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=1","link":"/2022/02/17/zh-tw/git-main-branch/"},{"title":"Github 登入新制 PAT X Sourcetree","text":"在2022年某天，嘗試使用 sourcetree 推上去新 code 時，在 Github 時出現了以下錯誤訊息： remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.fatal: unable to access “…” : The requested URL returned error: 403 以上說明大概就是 Github 已經不支援密碼登入的方式，從 2021/08/13 開始必須替換為 PAT 的 token 登入方式進行認證。 這個過程採了一些小坑，為了避免自己忘記趕緊的筆記一下： Github 創建 token From your GitHub account, go to Settings =&gt; Developer Settings =&gt; Personal Access Token =&gt; Generate New Token (Give your password) =&gt; Fillup the form =&gt; click Generate token =&gt; Copy the generated Token, it will be something like ghp_sFhFsSHhTzMDreGRLjmks4Tzuzgthdvfsrta 按下右上角頭像，選取 settings 按下 developer settings 點選 personal accesss token 填寫 token 用途與勾選 token 權限之後，申請一個 token 並且妥善保存 sourceTree 修改遠端 URL 專案的 repo 點選 settings 修改 remote URL 的格式如下， 1https://&lt;USERNAME&gt;:&lt;TOKEN&gt;@&lt;GIT_URL&gt;.git 查詢 GIT_URL 可以透過這個指令： 1$ git config --get remote.origin.url 並且記得 GIT_URL 要刪除 https:// 的部分才不會出錯，類似這樣 1https://mawchu:&lt;你的Github token&gt;@github.com/mawchu/mawchu.github.io.git 驗證 Sourcetree 的身分 切換 OAuth 為 Basic 驗證方式，輸入方才申請好的 token 密碼 驗證 OK 就可以推上去囉！ 參考文章： https://stackoverflow.com/questions/68775869/support-for-password-authentication-was-removed-please-use-a-personal-access-tohttps://stackoverflow.com/questions/68191968/source-tree-fix-for-git-password-authentication-is-temporarily-disabled-as-parthttps://stackoverflow.com/questions/4089430/how-can-i-determine-the-url-that-a-local-git-repository-was-originally-cloned-fr","link":"/2022/02/10/zh-tw/git-pat/"},{"title":"Graph QL 新世代 API","text":"隨著行動裝置越來越多元，服務與資料需求越來越錯綜複雜，因應這樣背景的 Graph QL API 就誕生啦！ 2012 年 facebook 內部研發出來的新形態 API，2015 年提出發表，特點是前端可以直接進資料庫，不需要透過後端查詢撈取資料。概念有一點類似用前端語言操作 MySQL。前端也擁有更彈性的空間來制定查詢資料的規則與方式，有更大話語權，但相對來講也增加資料設計的難度，在思考的維度上需要更廣更深才能靈活應付多變的資料需求。 Graph QL 操作概念 使用者透過輸入定義好的語法，取得所需的資料 (如 SELECT) 或是修改指定的資料 (如 CREATE 、 UPDATE)。 資料的格式前端 request 長相example1234567891011query { User(id: 'aefk34kasl9') { name posts{ title } followers(last: 3){ name } }} 資料庫 response 長相example123456789101112131415{ \"data\": { \"User\": { \"name\": \"Mawchu\" \"posts\":[ { title: \"喵喵的一天\" } ] \"followers\": [ { \"name\": \"Cally\" }, { \"name\": \"Donna\" }, { \"name\": \"Jell\" }, ] } }} 補充 Schema，香港和中國大陸翻譯為模式或架構，在資料庫系統中是形式語言描述的一種結構，是對象的集合，可包含各種對象如：表、欄位、關係模型、視圖、索引、包、存儲過程、子程序、隊列、觸發器、數據類型、序列、物化視圖、同義詞（synonym）、database link、directory、XML schema等。 參考資料： hiskio 課程 API 整合實戰｜RESTful 第三方串接應用https://ithelp.ithome.com.tw/articles/10200678","link":"/2022/02/25/zh-tw/graph-ql-api/"},{"title":"感謝您的閱讀","text":"這裡撰寫的都是一些自己在前端之路上每天一小步的學習，希望透過記錄與陳述來加強學習成效以及融會貫通的能力，文章內有任何問題歡迎一起討論呦!","link":"/2022/02/08/zh-tw/hello-world/"},{"title":"HTTP 超文本傳輸協定","text":"圖片來源：https://www.itpro.com/web-browser/33349/slew-of-vulnerabilities-detected-in-https HTTP 的誕生網路應用程式早期在互相傳遞資料時沒有固定的格式，在資料解析上就會很麻煩混亂，就像一個國家一旦陷入各自為政的困擾就需要政治來規範管理，網路世界也是一樣道理的。超文本傳輸協定(Hyper Text Transfer Protocol)就是網路資料傳遞的統整者，是 client 端向 server 端要求資料的關卡，必須要按照正確的格式才能取得資料。 Origin Server 是甚麼server 負責 response先介紹 Origin 這個單辭為什麼會被拿來當作 server 端，它的同義詞有 root、source 與 beginning，有起源、來源與原產地的意思，相當於網路世界中網站資料的起源與來源，github 在推 commits 上去遠端也可以看到指令： 1git push -u origin master Origin 代表的就是擁有資料的角色，通常是 server端： An origin server is a computer that runs programs designed to listen to and respond to incoming requests or traffic. It contains the original version of the web page and is responsible for delivering the content to end users when requested.Origin servers take in requests and serve up content for a website or web page. Origin server 是負責監聽以及回應（response）來自四面八方的要求（requests）與通訊的電腦計算機程式，包含原版的網頁資料並且傳遞該內容給發出請求的使用者端口。 Origin server 會接收需求並且提供網站的資料內容。 client 負責 requestedClient 代表的是上網並請求網站資料的使用者，也就是 user 端： When a user opens a web page on a website, a request is sent to the origin server to retrieve the content. 當使用者試圖用瀏覽器（browser）打開一個網頁或網站，就已經發送了該網站資料的要求給 origin server。 Port 是甚麼一個網站就如同銀行，而服務人員的櫃檯提供多元的銀行業務來消化前去等候的民眾，這個案例中：銀行機構就是 Origin server，服務人員就是 port，而民眾就是 client（user agent）；而一個網站 Origin 可以包山包海擁有各種資料，並開啟多個窗口的埠號（port）來服務傳送過來的需求（requests），讓每個埠號更專注在一個服務的品質與細節上。早期沒有瀏覽器的時代，使用的是終端機(terminal)來發送請求而非瀏覽器，而今 server 端口會檢查要求是否來自瀏覽器而非機器人（爬蟲），來過濾一些資安問題的黑手。 HTTPs 的誕生隨著網路世界日興發達，不安好心的資訊竊取駭客就會出現，它可以偽裝成使用者也可以偽裝成服務器，為了避免這種資料截取的資安問題，資訊傳遞的加密就很重要！HTTPS 如同 HTTP 但是多了一把開啟資訊傳遞的鑰匙，將來往資料都加密過防止有心人士解讀： 參考資料： https://www.cdnetworks.com/knowledge-center/what-is-origin-server/hiskio 課程 API 整合實戰｜RESTful 第三方串接應用","link":"/2022/02/28/zh-tw/http-and-https/"},{"title":"HTTP 的訊息頭 header","text":"個人對這一塊知識又愛又恨，每每串接 api 打開 Network 都會看到卻似懂非懂的感覺真討厭！來認真釐清一下吧！ 甚麼是 Header 與 Body訊息頭header在 request 與 response 裡佔有很大一席之地，它的作用相當於寄件時包裹上的訊息，記錄著包裹的相關內容，譬如該包裹要通過海關時必須申報內容物是甚麼類別，是否是急件還是一般，要寄往哪個國家、寄給誰等等的屬性。訊息本體 body 就是你包裹裡面的東西，或者信件裡的文字訊息。之於網頁的資料傳遞則是記錄該次要求 request 與回應 response 的通訊內容．是一個 http 行為的概覽與說明。 Header 存在於那裡request 與 response 都有 header，通常是 client 端發出的 request 會寫得比較詳盡，譬如使用者在搜尋引擎上點選一個網站就完成數個 request（一個網站會有很多資源的要求．例如圖片、網頁或 Api 資料）或者使用者在電腦填寫表單之後送出，而 server 端接收之後回應也會有訊息頭。 HTTP 通訊的組成 一個 request 跟 response 由 header 訊息頭跟 body 訊息本體所組成： Request Header 請求頭 屬性 說明 範例 Accept request 要求 response 的類型 text/html, image/* Accept-charset request 的編碼 utf-8, iso-8859-1;q=0.5 Authorization request 要通過的驗證授權檢查 Basic YWxhZGRpbjpvcGVuc2VzY… Cookie client 的暫存資料 PHPSESSID=124141;csrftoken=45746454 Content-type request 要求所發送的資料型態 multipart/form-data, text/plain, application/x-www-form-urlencoded, text/html, application/json Origin request 要求的資料機器來源 https://developer.mozilla.org User-Agent request 端的 client 資訊 Mozilla/5.0(Macintosh;Intel Mac OS X_10_14_3) AppleWebKit/537.36 X-Csrf-Token 防止 csrf(跨站請求偽造) 攻擊 eyjpdil6lmc4bjhQMmFrays… Authorization其中的 Authorization 在 API 的安全驗證非常重要，當 API server 接收到來自遠方的 request 時，可以透過該鑰匙密碼確認來源的 request 是合法、通過認證的，如此才能通過關卡進行資料交換。 Cookie瀏覽器的暫存資料，是 Web API 的一種，Cookie 提供前端或後端一個存取少量資料在瀏覽器的空間，資料格式是一個鍵值對(key-value)，常用來做廣告追蹤紀錄客戶的瀏覽喜好，進而針對客群行銷與增加廣告投放的精準度，例如 Google Analytics；亦或是用來保持使用者的登入狀態。 身為 Web 開發人員一定要瞭解 HTTP 本身無狀態 (Stateless) 的特性，要在網路上識別瀏覽者的身份，必須透過一些機制來保存狀態，而 Cookie 就是其中一種保存狀態的機制。https://blog.miniasp.com/post/2008/02/22/Explain-HTTP-Cookie-in-Detail Cookies 會被每一個請求發送出去，所以可能會影響效能（尤其是行動裝置的資料連線）。現代客戶端的 storage APIs 為 Web storage API (en-US) （localStorage 和 sessionStorage）以及 IndexedDB。https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Cookies Content-type紀錄 client 端發出的 request 要求發送出去的資料格式與型態，例如表單或影音多元媒體就是 multipart/form-data，網頁就是 text/html，而 API axios 等技術傳遞的資料格式常為 application/json等。 一般的 Content-Type 往往只能傳送一種形式的資料，但在網頁的應用當中我們還可能想要上傳檔案、圖片、影片在表單裡頭，這樣的需求促成了 multipart/form-data 規範的出現。https://blog.kalan.dev/2021-03-13-html-form-data/。 Origin該 request 要求的來源，比如瀏覽的網站是 https://google.com 等，延伸的議題就是跨網站要求(CORS)，經常會默認要同一個**網站來源(domain)**伺服器端才可以接受該要求。 User-Agent發送 Request 的對象，通常是瀏覽器本身的相關資訊，例如 chrome 瀏覽器就會顯示 Mozilla/5.0 (Windows NT 10.0; Win64; x64)；也可能不是瀏覽器，例如 postman 就是 postman、終端機就是空白，User-Agent 主要是拿來防止爬蟲軟體等非瀏覽器或機器人來獲取網站資料。 X-Csrf-Token該 token 用以防止 csrf 的跨站偽造攻擊，使用者送出表單時加上一傳鑰匙密碼，避免有心人士撰寫一隻程式發送表單登入或註冊網站會員竊取資料。 Response Header 回應頭回應的內容也會記錄伺服器端的資料，以及接收的 request 資訊。 屬性 說明 範例 Access-Control-Allow-Origin 限定此回應的資源是否要限制某個 Origin *, https://developer.mozilla.org Server 後端 Web server 伺服器類型 Apache/2.4.1(Unix), Nginx Status 回報這次 request 是否成功的代碼 sessionid=38afes7a8, id=a3fWa, Max-Age=2592000 Access-Control-Allow-Origin該技術常用來判定前後端分離的網站，後端 server 限定只能接受自己**官方網站(domain)**前端打出的 API Request，才會做出回應；該技術與 Request Header 提到的 Origin 前後呼應，由後端 server 判定前端 Request Header 裡面備註的 Origin 來源是否合法，延伸的議題一樣就是跨網站要求(CORS)。 Set-cookie伺服器端在瀏覽器設定 cookie 資料以記錄客戶端的瀏覽行為，以利行銷追蹤，或是做後續 request 發送給後端要包含的 cookie 內容。而後端發送 Set-Cookie 是主動的，而前端接收 Cookie 是被動的： The Set-Cookie HTTP response header is used to send a cookie from the server to the user agent, so that the user agent can send it back to the server later. Cookie 的運作是這樣的： Server 端回應給 Browser 一個或多個 “Set-Cookie” HTTP Header Client 端 ( Browser ) 接收到 Set-Cookie 指令時，會將 Cookie 的名稱與值儲存在 Browser 的 Cookie 存放區，並記錄該 Cookie 隸屬的網域、網址路徑、過期時間、是否為安全連線 當 Browser 再次發出 HTTP Request 指令到 Server 時，就會比對目前在 Browser 內的 Cookie 存放區有沒有「該網域」、「該目錄」、「過期時間尚未過期」且「是否為安全連線」的 Cookie，如果有的話就會包含在 HTTP Request 指令的 “Cookie” Header 中。 如果Request 要傳送 Cookie 到後端除了在 前端 Request 要設定 credentials後端 Express 的 Access-Control-Allow-Origin 不可以為’*’ 要設定成一個指定域名(前端的ip或域名)，例如：Access-Control-Allow-Origin：”http://localhost:3000\" 圖片來源：hiskio 課程 API 整合實戰｜RESTful 第三方串接應用","link":"/2022/02/28/zh-tw/http-header/"},{"title":"HTTP Status code 狀態碼解析","text":"圖片來源：https://alicialin2020.medium.com/status-code-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-4%E5%AD%97%E9%A0%AD%E7%B3%BB%E5%88%97-4826b7e07ae5 常常看到網站出現 404 找不到，或者是後端噴錯顯示了 Bad Gateway 卻不曉得箇中原因，而前後端打 API 也必須要讀懂狀態碼（HTTP Status code）代表的意涵，才能更有效率的除錯找出原因，以下是常見的狀態碼： Level 200 發送成功 狀態碼 意涵 情境 200 OK API 要求與回應都OK 201 Created 成功建立了資料，例如 facebook 建立貼文 203 Http proxy 該伺服器是代理的伺服器，非原始 Origin 204 No Content 伺服器成功處理了請求，沒有返回任何內容 Level 400 要求內容有誤 狀態碼 意涵 情境 400 Bad Request 發送要求但是需要的參數沒填、填寫的參數不符合規則，這個錯誤是客戶端造成的 401 Unauthorized 身分未明或是瀏覽的權限不夠、沒有登入會員或付費 403 Forbidden 黑名單而被禁止該項服務 404 Not Found 找不到該網站的某頁面 409 Conflict 服務流量過大導致衝突，或帳號/Email已被使用 Level 500 伺服器有誤 狀態碼 意涵 情境 500 Internal Server Error 該服務伺服器出現不明問題，需要聯絡開發人員 503 Service Unavailable 該服務因為流量爆炸等原因無法使用了 501 Not Implemented 該服務有接收到要求，但還未實作未完成 502 Bad Gateway 連線伺服器成功，但中間軟體出錯 504 Gateway Timeout 連線伺服器成功，程式也沒問題，但經過中間軟體時出錯（過期） 599 Network Timeout 網路連線逾時，連不上 參考資料： hiskio 課程 API 整合實戰｜RESTful 第三方串接應用 延伸閱讀： https://alicialin2020.medium.com/status-code-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-4%E5%AD%97%E9%A0%AD%E7%B3%BB%E5%88%97-4826b7e07ae5","link":"/2022/03/01/zh-tw/http-status-code/"},{"title":"HTTP Methods 介紹","text":"圖片來源：https://www.jianshu.com/p/ac29da71601d 身為技術人不可不知的技術事：其實你每天都在使用 HTTP 的 Methods，但你不知道而已。當你在瀏覽器輸入一串網址並且按下 enter 或者是按下一個 google 搜尋的超連結，就已經完成一個 HTTP GET Methods 的流程了！Client 端網路資料的傳輸，按照功能屬性分為幾個類別： Methods 目的 說明 GET 取得資料 經常會搭配 query string 參數使用，使用者可以在 URL 看到資料 POST 傳送資料 可以將要求內容隱藏在 body 中，使用者看不見 PUT 更改整筆資料 通常是一個註冊表單提供第一次來訪的使用者填寫，server 端會整筆更新 PATCH 更改部分資料 可能是會員中心的部分資料修改，例如地址或手機，server 端會只更新修改的部分 DELETE 刪除資料 比較單純的功能，就是刪除資料 GET 方法（READ） 圖片來源：hiskio 課程 API 整合實戰｜RESTful 第三方串接應用 GET 取得資料（read）的條件是寫在 query string 的?後方，key-value 的鍵值對來代表欄位跟內容。例如 ?name=jobe&amp;email=jobe，name 對應form 表單裡面的 input name ，為欄位名稱，等號後方的值就是使用者自己填寫的 value 內容： 1234567891011&lt;form action=\"http://localhost:4000\"&gt; &lt;div&gt; &lt;label for=\"name\"&gt;Name&lt;/label&gt; &lt;input type=\"text\" name=\"name\"&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"email\"&gt;Email&lt;/label&gt; &lt;input type=\"text\" name=\"email\"&gt; &lt;/div&gt; &lt;button type=\"submit\"&gt;送出&lt;/button&gt;&lt;/form&gt; GET 網址最多只能兩千多個字，包含參數等。 URL 的萬國編碼機制需要經過 encodeURI()、encodeURIcomponent() 等方法解密過才可閱讀。 POST 方法（CREATE） 圖片來源：hiskio 課程 API 整合實戰｜RESTful 第三方串接應用 POST 方法旨在創造一筆新的資料，發送到 Origin server 接收，可以將資料隱藏在 body 中避免被使用窺視，使用者在網頁 URL 看起來也乾淨簡潔。 POST 方法可傳送的資料量基本沒有限制，端看 server 這邊的程式是否有特別限制多少 mb。 PUT &amp; PATCH（UPDATE）這兩個方法旨在更新現有的資料內容：PUT會將整個表單內容根據填寫的資料全部更新，有空白沒填的地方照樣更新成空白的狀態，適合用在第一次填寫資料的訪客，例如註冊會員、初診的病患要掛號。PATCH則是只更新部分內容而已，沒有變動的地方維持原樣，適合用在填寫過完整資料而只想部分更改的情境，例如修改會員寄送地址、復診的病患要掛號等。 這兩個方法並非 HTTP 創造的，而是方便網站開發人員依據自己的資料取向需求來設計表單欄位給訪客填寫，再選擇適合的 HTTP Methods。 DELETE（DELETE）由於刪除是一個不能回頭的行為，雖然有的網站在後端機制不會真的讓使用者刪除，只是讓你看不到而已，不過刪除的要求還是被特別獨立出來，警示開發人員慎用這個方法。 圖片來源：hiskio 課程 API 整合實戰｜RESTful 第三方串接應用","link":"/2022/02/28/zh-tw/http-methods/"},{"title":"克服 Javascript 的奇怪部分 ES6","text":"ES6 let不同於 var 的宣告方式，let 宣告的變數在宣告時會出現暫時性死區不可取用，沒有 hoisting 現象，且變數的作用域只存在於 block 區塊中，例如 if 陳述句，而 var 則是函式作用域，若撰寫在 if 陳述句內外部仍可取用。最經典的應用就是 for 迴圈，可以在每一次的 console 正確印出數值： for loop12345for(let i=0; i&lt;5; i++) { setTimeout(()=&gt;{ console.log(i) },1000)}","link":"/2022/07/24/zh-tw/js-weird-parts-ES6/"},{"title":"克服 Javascript 的奇怪部分 Hoisting","text":"課程作者提到，Hoisting 大約是 JavaScript 裡最奇怪的行為了，而且是其他語言無法做到的特性，來了解一下怎麼回事吧！ Hoisting這一段程式碼若在其他語言執行可是會發生錯誤的！但是在 JavaScript 裡卻可以安然無恙： 123456b();console.log(a);var a = '123';function b () { console.log('b is called!');} a 竟然在還未被宣告以前使用，會回傳 undefined；b 函式正常運作。這就是 JavaScript 的 Hoisting 在搞鬼，但不要被 Hoisting 的提升之意混淆了，該現象並非程式碼被靜態的（physically）提升到最上方，我們來解析一下編譯器是如何執行這一段程式碼： 執行環境執行的兩階段There are two phases when it came to the execution context within the Javacript engine:The first phase was the creation phase, when it sets up the variables and functions in memory. And the second phase was the execution phase, all those things already being set up, so now it runs your code line by line. 創造階段在第一個章節有提到，Javascript 並非是完全直譯的語言，其中一個佐證就是 Hoisting 的行為，如果程式碼真的是逐行翻譯然後執行，它是怎麼知道變數 a 與函式 b 會被創建的呢？ 這裡就能理解編譯器在執行程式以前仍存在一段編譯完成才執行的過程：Javascript 引擎先將整個程式碼審視一遍，找出所有具有名稱（variable name）、並非透過區塊作用域（Block scope）的關鍵字 const 與 let ，而是 var 所宣告的的值或函式找出來，然後歸納：誰是變數就給予一個記憶體空間，存放著未定義的值（undefined）；誰是函式就給予一個記憶體空間，存放著整個函式的內容。 也就是說創造階段可以這樣理解： 1234var a;function b () { console.log('b is called!');} 變數 a 與函式 b 都各自被建立一個記憶體空間，接著存放著對應的值，變數 a 的記憶體空間內存放了 undefined，函式 b 的記憶體空間則直接放置整個函式內容。關鍵就在變數的創造階段，只是宣告（declared）而已，這個階段 JavaScript 引擎並不清楚變數 a 將來的值會是甚麼，直到執行階段才會被指派（assigned）。 undefined 不等於 not defined當變數通過 var 關鍵字宣告，記憶體就被建立並且放入 undefined 的值，如果變數未宣告就使用，則瀏覽器會噴錯誤訊息： 12console.log(a);// Uncaught ReferenceError: a is not defined 這是瀏覽器表示：嘿！我在任何記憶體都找不到這個名稱的參照，甚至連 undefined 都不是。 小知識Since undefined is a longer string than null, the JIT compiler has to save 4 bytes more to memory when using undefined instead of null while parsing. Consider that memory aswell. undefined 並非不存在的值，它是 Javacript 中的原始型別，也是純值的一種，甚至占了記憶體 4 個 bytes ，比空值null還要多。 良好的 coding 習慣(X)在宣告以前使用變數為了避免在執行過程被 Hoisting 汙染，最好養成先宣告後調用或賦值的習慣，可以避免一些錯誤發生，這也是為什麼 Eslint 或 Airbnb 等大宗規範都建議的撰寫規則。 (X)將變數賦值為 undefined1a = undefined; 倘若你這麼做了，會在除錯的時候難以辨認是 Javacript 引擎設定的還是後來你撰寫的程式所賦值的。 結論若要將 Hoisting 給予一個較好的解釋，我想就是「創建初始化」，給予一個初始的值以便後續利用：函式就直接賦值，變數的則填補上執行等號（=）以後的值，不過那已經是下一個執行階段的任務了。","link":"/2022/06/04/zh-tw/js-weird-parts-II/"},{"title":"Git 常用的指令","text":"這裡記錄一些工作上會用到的 git 指令，太容易忘記了阿（扶額 分支查看分支1git branch 遠端 URL更換遠端 URL因應 PAT 新制，remote origin 格式必須更改如下： 1git remote set-url origin https://&lt;USERNAME&gt;:&lt;TOKEN&gt;@&lt;GIT_URL&gt;.git 查看遠端 URL1git remote -v 將專案推上去遠端 URL1git push -u origin master","link":"/2022/02/21/zh-tw/git-command-line/"},{"title":"克服 Javascript 的奇怪部分 如何執行非同步","text":"瀏覽器在運作的時候有三大功能要執行：render engine 畫面渲染 -&gt; JavaScript 引擎 -&gt; Http Request。 A browser engine (also known as a layout engine or rendering engine) is a core software component of every major web browser. The primary job of a browser engine is to transform HTML documents and other resources of a web page into an interactive visual representation on a user’s device. 雖然名詞解釋上為非同步，但在 JavaScript 運作上實際仍是 line by line，而且具有先後順序的，對瀏覽器而言以下三項機制才是同時運作（asynchronous）： Http request &amp; response客戶端發送了頁面請求後，Http 機制開始運行收發請求與回應網路資源的文本協定，建立瀏覽器與伺服器的溝通橋樑，作為 TCP/IP 的應用層，並且將資料回應提供給 JavaScript 來處理。 Javascript一旦提及非同步就不可埋沒一大功臣，JavaScript 引擎中的事件佇列（Event Queue）。 事件佇列（Event Queue）當 Javascript 引擎執行完執行佇列（Execution Stack）的內容後，也就是執行佇列已經清空後，會定期（periodic）來檢視事件佇列（Event Queue）的事件排序並且執行，例如 Click 事件的回呼函式，或者是 API 收發資料的任務，才會被放置到執行佇列（Execution Stack）然後執行。在 Javascript 中的運作仍是同步的，並沒有非同步在執行程式。 微任務與宏任務部分的執行任務會被放置在事件佇列中，待執行佇列（Execution Stack）所有任務完成後才會開始執行，例如 SetTimeout（宏任務） 或是 promise（微任務） 等。 Render engineJavaScript 的必須仰賴瀏覽器的引擎，當瀏覽器讀取一個頁面時， JavaScript 具有觸發畫面渲染的鉤子促使渲染引擎（Render Engine）來改變畫面。 Asynchronous means that the rendering engine, the javascript engine and the HTTP requests are running asynchrounously inside the browser, what’s happening just inside the javascript is synchrounous.","link":"/2022/07/24/zh-tw/js-weird-parts-asynchronous/"},{"title":"克服 Javascript 的奇怪部分 單執行緒與同步執行","text":"這一個章節要來講解 JavaScript 的幾個觀念。 單執行緒（Single Threaded）一次一件事是重點。這個特性不是瀏覽器的特性，瀏覽器一次可能同時處理多件事情，JavaScript 引擎則是單執行緒的，就像排隊買早餐，老闆娘一次只能處理一位客人，而 JavaScript 也是一次只處理一項指令。 同步執行（Synchronous）順序是重點。事情有先後順序，按照順序執行，一次執行一行（或者說一個單元的程式碼，可能是一個陳述式或表達式）。 呼叫函式（Function Invocation）觸發或執行一個函式，使用的符號為大括號（parenthesis）。JavaScript 引擎在執行函式呼叫時，會發生幾件事情延續前面的章節： 呼叫函式123456function b () {}function a () { b();}a(); 創造階段 全域執行環境（Global Execution Context）首先被創造。 全域物件（Global object）被創造。 全域 this 被創造。 開始編譯階段（Parsing），編譯器巡過一遍所有程式碼發現了函式 b 與 a，在記憶體創造兩個函式的空間並且存放整個函式內容。 執行階段 整個程式碼的記憶體準備完畢後，開始執行程式。 編譯器解析到函式 a被呼叫，立即於全域執行環境上方，產生並堆疊一個函式 a 的執行環境（Execution Context），放進執行佇列堆（Execution Stack）中，每個執行環境都有自己得記憶體空間存放著變數或函式。 最上方的執行佇列會優先執行，進入函式 a 的執行環境（Execution Context）並且解析到函式 b，程序暫停，立即於函式 a 的執行環境上方，產生並堆疊一個函式 b 的執行環境（Execution Context），放進執行佇列堆（Execution Stack）中。 以上執行階段也可以拆分成好幾個創造（執行環境），與執行（執行佇列堆最上方的執行環境）階段，在當下的執行環境執行過程中，只要觸發另一個函式，執行暫停然後創造（執行環境）、與執行（執行佇列堆最上方的執行環境），而下方的程式碼不會被解析，除非該執行環境執行完畢並且離開執行佇列堆（Execution Stack）後才會繼續逐行執行。 Everytime a function is called, a new execution context is created for that function, the this variable is created for that function, the variables in it were set up in the creation phase, then the code is executed line by line.whatever is on the top of the execution stack, is currently running synchronously. 重點整理：當一個函式被觸發或是呼叫，JS 引擎會創造一個屬於該函式的執行環境（execution context）並且放置在執行緒的最上方等待被執行，而該堆疊中具有該函式獨有的執行環境與 This，開始執行並且完成後離開堆疊中（pop out）繼續執行下一個堆疊，只要解析到新的函式被呼叫就會反覆以上行為，直到堆疊不斷（pop out）剩下全域執行環境本身為止。","link":"/2022/06/05/zh-tw/js-weird-parts-III/"},{"title":"克服 Javascript 的奇怪部分 名詞解釋篇","text":"先前滿常看到別人推薦的 Udemy 課程：克服JS的奇怪部分，原來自己已經購買且塵封在閱讀清單已久XD馬上來匹乓一下吧！ 執行篇語法解析器（Syntax Parser）將你撰寫的 Javascript 編譯成電腦可以理解的一套程式語言（program），並且決定語法執行的方式以及是否合乎規範的角色，也與直譯（interprets）、轉譯（Compiler）概念雷同，其中直譯的編譯方式為逐字編譯後由電腦執行，大部分的 Javascript 程式都是直譯的，但並非全部情況。編譯的過程會將 Javascript 拆解分類，依變數、函式等轉換成電腦硬體可以閱讀的語言，然後執行。 可以想像成生產線上的作業員，持有原料工序可以生產產品。 靜態詞法作用域（Lexical Environments）Where something sits physically in the code you write,determines how it interacts with other elements in the program. 撰寫的時候決定如何運作。你撰寫語法的靜態物理位置，決定了該對象（變數、函式等）與其他對象的互動與執行關係，並且被直譯器透過這個物理關係，或者說詞彙或文法關係來統整歸坐落在硬體記憶體中的位置，但須注意的是並非所有語言皆如此（java、C# 等為動態作用域）。這有助於上方的語法解析器來決定程式怎麼運作，你撰寫 code 的位置在哪？周圍有甚麼、被甚麼包圍都很重要！可以想像成生產線上的主管，歸納好產品的原料工序與存放倉庫的規則。 執行環境（Execution Context）A wrapper to help manage the code that is running.There are lots of lexical environments, which one is currently running is managed via execution context. 執行的時候決定如何運作。靜態作用域很多，但是執行的當下順序則是由執行環境決定，也可以稱為上下文，最常見的就是每個函式建立之後產生的this keyword，通常為 block 作用域所包覆，在呼叫的時候決定 this 對象。而執行環境不是只有與你撰寫的程式碼相關而已，也包含其他東西，例如上述的 this 就是執行函式當下的編譯過程動態產生的，編譯器在幫你翻譯給電腦讀懂以前，加油添醋了一些程序使程式碼更完整、具有前後順序給電腦執行。可以想像成工廠的老闆，決定好哪批產品先出後出、出到哪裡。 變數篇一個名稱對應一個值一個變數名可以更改很多次，但都只會包含一個值，而一個值裡面是更多的鍵值對。 物件更多鍵值對（key-value pairs）的集合。 全域物件與全域環境篇（Global）info12345The base execution context is your global execution context.Things that are accessible everywhere to everything to your code.And it creates 2 things that you don't have to write about:1. Global object2. this 全域執行環境全域執行環境是所有 Javascript code 執行的基礎，所有的執行起點都存在於該環境內（being wrapped）。並且 Javascript 引擎會在執行初始建立兩個對象：全域物件與 this，即使你沒有撰寫任何程式碼，Javascript 引擎仍會自動產生。 this其中全域執行環境中，瀏覽器底下的 this 就是指向 window (Global Object)。weird-parts-I/3.png 600 200 js-weird-parts-I %} 全域物件若 Javascript 引擎是在後端執行，例如 node.js，則 全域物件就不會是 window。當你在全域執行環境下靜態的撰寫變數或函式，並且詞法作用域上開放而沒有撰寫在其他函式內，就會自動附著（attached to）在全物域物件底下，全域物件意味著整個 Javascript 中的任何其他詞法作用域或者任何對象乃至整個檔案，都可以取用（accessible）這些資料。 以下都是指向同一個記憶體位置、同一個值： 在執行環境中，還有一個外部環境（Outer Environment）沒有提到，而在全域執行環境的層級中，外部環境是 null，因為全域本身就是最外層的 wrapper，沒有更外層的環境了。","link":"/2022/06/04/zh-tw/js-weird-parts-parsing/"},{"title":"克服 Javascript 的奇怪部分 型別","text":"Dynamic TypingJavascript 的型別為動態型別（Dynamic Typing），不同於 C# 等強型別語言的靜態型別（Static Typing），無須指派型別而是在引擎執行的階段（at runtime）辨認變數記憶體內的型別為何： Dynamically-typed languages are those (like JavaScript) where the interpreter assigns variables a type at runtime based on the variable’s value at the time. 這有可能導致一個變數在每次程式執行的結果都產生不同的型別（例如 == 型別隱式轉換），而造成不如預期的結果，所以使用三等號是比較良好的撰寫習慣。","link":"/2022/07/30/zh-tw/js-weird-parts-types/"},{"title":"克服 Javascript 的奇怪部分 範圍鍊","text":"以下探討的幾個議題都離不開函式（function）本身： 環境變數每個執行環境（execution context）都有屬於其中的變數，可以把執行環境想作是一個空間範圍，而環境變數都附著在其中，例如全域變數（global variable）會附著在全域物件下，瀏覽器的全域執行環境則是屬於 window 物件，宣告在其中的變數都會隸屬於全域執行環境。 函式變數函式變數在函式被呼叫並觸發後創造了一個獨特的函式執行環境，該函式內有自己的變數，此變數式在函式內宣告（declaration）並且創造的，只能在該函式執行環境中可以取得，稱為區域變數（scoped variable），而變數可取用的範圍稱之作用域（scope）。 範圍鍊根據函式的靜態作用域、詞法作用域，也就是坐落的物理位置來向外查找可用的變數（accessible variables），而非呼叫的位置；每個函式的執行環境（execution context）都是獨立的執行堆疊（execution stack），並且都指向外部的執行環境（outer environment），一層一層的鏈結稱為範圍鍊（scope chain）。 值得注意的一點：函式 b 是在函式 a 呼叫並且執行之後才建立了函式 b 的執行環境。","link":"/2022/07/10/zh-tw/js-weird-parts-scope-chain/"},{"title":"克服 Javascript 的奇怪部分 原始型別","text":"只要不是物件型別的值都可以看做是原始型別，例如： undefined當一個變數還未指派任何值之前，記憶體位置會被賦予一個 undefied 的值，通常是 Javascript 引擎指派的，應該避免將任何值的預設值設定為 undefined，避免與 Hoisting 行為混淆了。 null若需要再資料回來之前給予判斷，可以將變數設定為 null 來表示該變數還未拿到任何值，也非 Javascript 引擎指派的值。 booleantrue 或 false 的判斷型別，值得注意的是當值存在 localstorage 或者 cookie 時應避免儲存 true 或 false，轉換過程會強制變成 string 而造成錯誤的判斷。 number唯一的數字型別（numeric），不同於其他語言可能具有細緻的數字型別，例如 interger 或是 demicals，Javascript 只有一個 number type，為浮點運算（floating point number），這種運算法為一個有效數字加上冪數來表示，電腦本身的二進制無法實現十進制的數字精確性，會造成數字計算上浮點位數的不正確，只能計算出近似值而已。 string字串型別，一串使用雙引號或單引號標記起來的文字。 symbolES6 引入的新原始型別，用來表示一個獨一無二的值。產生的原因來自於物件的屬性通常都是字串（property），這樣容易造就重複的屬性而衝突，新的符號型別（symbol）於是誕生，兩個 symbol 永遠不會相等，是絕對的獨一無二。ES6 允許使用表達式 (expression) 作為屬性的名稱，語法是將 expression 放在中括號 [ ] 裡面： symbol1234let s = Symbol();let obj = { [s]: function() {}};","link":"/2022/07/30/zh-tw/js-weird-parts-value/"},{"title":"Laravel 專案包初探","text":"Laravel 專案包建立好之後，有以下幾個主要的資料夾，一一介紹其作用： 先打預防針，其實整個 Larevel 專案包預設並沒有任何 UI 框架，此專案包內名為 bootstrap 的檔案都跟該框架無半點毛關係！不要被混淆了。 知識小學堂：bootstrap 的意思為鞋帶，衍生的動詞涵義是啟動機制，符合 Laravel 框架中用來充當 glue 黏著任何相關檔案或 app 啟動機制的程序。 vendorComposer 相依套件的目錄，類似 node modules。 app核心的 code 會放在這裡，大部分的類別（class）程式放置處，重要的 MVC 架構中的 Controller 類別會放在 Http/Controllers 資料夾中，以處理 View 與 Model 中間的繫結處理器。 bootstrap這裡的 bootstrap 並非 UI 框架，而是啟動整個 Laravel app 需要使用的元件放置處，增進性能優化的快取設定（cache）會放在這，不需要編寫這邊的檔案。 databaseModel factories 會放在這裡，亦可處理 database 的遷移。 lang語言的切換檔案。 public網站的靜態檔案如 js、css 及 images 放置處，以及網站的所有入口點（entry points）index.php 與設定自動加載（autoloading）的地方。 resourceMVC 架構中的 Views 類別會放在這裡，通常是 blade 模板檔案，也存放一些初胚的、未經壓縮與處理的 js、css 檔案，在網站打包之後會被壓縮並且優化性能，需要 loader 去編譯的檔案可以放在這裡，例如 less 或 sass。 resource/bootstrap.js該文件夾底下的 bootstrap.js 檔案並非 UI 框架，而是放置 CSRF Token 自動夾帶在 header 的程序，並且使用 $axios 發送 request 出去，以避免 XSRF 跨站偽造攻擊之用！ 警告：不想整個 app 掛掉的話請不要亂動我！ routes路由檔案，預設會有 web.php, api.php, console.php, and channels.php 幾支提供設定，也可以使用 app 裡面的 Controller Class 來渲染路由對應的 view 檔。 routes/web.php提供 session state、CSRF 保護與 cookie 加密，可以放置除了 server 提供的 RESTful API 以外的網頁路由設定。 routes/api.phpAPI 中介軟體的設定處，是無狀態（stateless）的，所有進入該介面的路由都需要攜帶 Token 認證且無法隨意進入。 routes/console.php可以將自定義的指令碼撰寫在這，例如 Artisan 的相關指令。 routes/channels.php定義授權請求監聽的邏輯，以註冊相應的回呼函式。 storage放置經過編譯的 blade php 模板，以及快取與其他框架處理過後的檔案，其中storage/app/public路徑放置使用者操作後產生的檔案，例如頭像圖片。 config整個網站應用程式的設定檔案，建議熟讀並且活用其中的多樣選擇。可以把一些全域使用的環境變數放置其中。 參考文章： https://laravel.com/docs/9.x/structure","link":"/2022/04/03/zh-tw/laravel-folder-intro/"},{"title":"Windows 搭建 Laravel 環境的各種跌坑","text":"使用 Window 10 搭建 Laravel 框架的過程採了一堆大坑 QQ，經過幾番努力終於成功！千萬不要認為裝套件都是敲一敲指令就可以了，工程師的路從來都沒有那麼好走，是天堂路阿孩子！工欲善其事，必先利其器，先將裝備整頓好才能打 BOSS： 安裝 Composer簡單介紹一下 composer 的用處，npm 是用來安裝 node.js 的套件管理工具，那麼 composer 就是用來安裝 php 套件的管理工具。windows 這一步很簡單，按這裡就可以下載，設定那些一路按下去就好。 安裝 Ubuntu &amp; Windows terminal兩個都可以到 Microsoft store 下載。 安裝 WSL2Laravel 環境有要求： 在新建 Laravel 應用前，請確保你的 Windows 電腦已經安裝了 Docker Desktop。之後，請確保已經安裝並啟用了適用於 Linux 的 Windows 子系統 2（WSL2）。WSL 允許你在 Windows 10 上執行 Linux 二進位制檔案。關於如何安裝並啟用 WSL2，請參閱微軟 開發者環境檔案。 補充一下 WSL2 在幹嘛，看不懂就略過 XD： WSL 1 使用了一個轉譯層（translation layer）來轉換 Linux 與 Windows 底層的系統呼叫（system calls），而 WSL 2 已經不再需要這個轉譯層，因為它有了自己的 Linux 核心，而這個核心是執行於一個輕巧版本的 Hyper-V hypervisor 之上。 看一下安裝大師這個影片就懂了： 看完影片可以優先執行以下步驟來安裝 Windows WSL2，注意！要使用 windows powershell 並且以管理員身分來執行指令： 安裝 Linux 子系統 WSL2 步驟 11dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 安裝 Linux 子系統 WSL2 步驟 21dism.exe /online /enable-feature /featurename:VirutalMachinePlatform /all /norestart 重啟電腦後下載影片提供的 Windows 補丁 WSL2 Linux kernel update package for x64 machines 才能執行新的 Linux 子系統 以及 Ubuntu 作業系統！下載之後安裝起來就可以囉！ 查看系統版本 安裝 DockerDocker 4.5.0 版本裝完之後會出現設定區塊不斷讀取轉圈圈的 Bug，這裡在 windows 是一個巨坑！ 問題剖析Docker 轉圈圈類似這樣，借別人的圖來演示一下： 沒有辦法將 Ubuntu 與 WSL2 的設定開起來，讓人從開始就決定放棄 XD你一定在想為什麼還要用到 Ubuntu 與 WSL2？上面有提到，Laravel 框架需要依賴 Linux 的 Windows 子系統 2（WSL2）才能執行，所以安裝 WSL2 在先而 Docker 應該在後，一開始就是順序錯誤踩了大坑跑不起來。查看這一篇 Docker does not work after installation #12545 發現我不孤單，這裡有提到可以先降版安裝 4.4.2 的 docker，裝好之後再 update 就可以解決轉圈圈的問題了！ After I downloaded 4.4.2 it worked on the first try (well second try but basically all I did was restart it. There was some different error the first time and i clicked continue or ignore or try again or something. Anyways, it just then started. The WSL2 integration option box was still grayed out but it was selected so I didnt need to change it anyways. Then I did try to update to 4.4.4 but it actually installed 4.5.0. But it worked fine and my container was still there and working fine. So it seems that by installing 4.4.2 and then updating to 4.5.0 worked ok. 下載降板 Docker 4.4.2Docker 官方釋出的版本號裡面下載 4.4.2。 更新 Docker 4.5.0安裝完畢記得到 settings 更新到 Docker 4.5.0 版本。 修改設定更改設定為 WSL2 並且開啟 Ubuntu 到這裡總算收拾好了一個 windows 才有的大坑阿~（累） 安裝 Laravel &amp; sail瞧瞧這份 Laravel 官方安裝文件，我以為在 vscode 命令行輸入這一句就可以搭載 Laravel 了！真的是好傻好天真呀！全忘了剛才安裝的 Ubuntu XD 1curl -s https://laravel.build/example-app | bash 使用 Ubuntu 系統 sail up在命令行輸入就會發現指令怪怪的，必須要去剛才安裝好的 Windows terminal 點選下拉符號的企鵝（剛剛下載的 Ubuntu作業系統）： 就可以在這裡使用剛才的命令行來安裝 Laravel &amp; sail 1./vendor/bin/sail up 到這裡終於可以啟航啦~（痛哭）啟航沒多久你可以看到很多 Laravel 的專案被啟動，然後就報錯了～（崩潰） 問題剖析錯誤訊息是這樣的： docker: Error response from daemon: Ports are not available: listen tcp 0.0.0.0:80: bind: An attempt was made to access a socket in a way forbidden by its access permissions. 也就是我嘗試開啟的 Laravel Port 號被佔用了！指令查看一下 docker 容器列表：後來刪除 80 port 也無法解決問題 1docker container ls 在電腦查找了一下，發現是 window 系統執行的某程式（編號4）佔用了 1netstat -ano | findstr 0.0:80 ctrl + shift + esc 啟動工作管理員 &gt; 詳細資料 &gt; 使用 PID 排序查找是甚麼系統佔用： 修改 Laravel 環境檔不敢亂刪執行的系統背景程式，只好修改 Laravel 本身的 docker port 號，這裡要感謝課堂上的小夥伴們集思廣益查到方法了，參考 Unable to set the APP_PORT on .env for Laravel Sail將專案的 .env 加上這一行，關閉在打開： 1APP_PORT=3000 1sail down 1./vendor/bin/sail up 就成功了！整個很想大哭一場 QQ 修改指令碼最後修改一下啟動的指令更簡短些： 1alias sail='bash vendor/bin/sail' 就可以不必輸入那麼長的指令啟動 Laravel 啦！ 1sail up 打完收工。 參考文章： https://forums.docker.com/t/docker-engine-wsl2-stopped-settings-page-doesnt-load/82355https://github.com/docker/for-win/issues/12545https://www.youtube.com/watch?v=wJUHe4iof7whttps://ek21.com/news/3/19760/https://stackoverflow.com/questions/67053449/unable-to-set-the-app-port-on-env-for-laravel-sail還要感謝課程上的死神老師與許多小夥伴們大力幫忙（跪） 2022/04/04 更 Artisan cmdLaravel 的 artisan 指令有些需要 PHP 8 以上版本 才能支援，需要更新環境的 PHP 版本到 8 以上，並且移除 PHP 7 避免系統指定到舊版本，這樣一來 windows 系統中的 windows terminal 與 ubuntu 企鵝都可以使用各種 artisan 指令，例如自動建立 Controller： artisan cmd1php artisan make:controller Whatever Controller 建立完的檔案會自動出現在 app/Http/Controllers 路徑中，結構如下： WhateverController.php1234567891011121314&lt;?php namespace App\\Http\\Controllers; use Illuminate\\Foundation\\Auth\\Access\\AuthorizesRequests; use Illuminate\\Foundation\\Bus\\DispatchesJobs; use Illuminate\\Foundation\\Validation\\ValidatesRequests; use Illuminate\\Routing\\Controller as WhateverController; class Controller extends WhateverController { use AuthorizesRequests, DispatchesJobs, ValidatesRequests; }","link":"/2022/02/12/zh-tw/laravel-installation/"},{"title":"Laravel 資料庫版控工具 Migration","text":"Migration 位於 Laravel 專案包中的 database 資料夾，會使用建立日期來歸檔資料表的結構，為紀錄資料庫版本的版控，方便團隊共同開發資料表。 建立資料表建立 migration1php artisan make:migration create_users_table 建立成功會顯示： 重整之後會出現新的版控檔案，使用建立日期來命名： 檔案內容： 修改資料表在 \\\\wsl$ 路徑下執行 migrate 的坑需要以下步驟： 補上 php 8.0 的 sql-extension於 ubuntu 終端機輸入以下指令： 1輸入code 將註解 ;extension=pdo_mysql 打開","link":"/2022/04/24/zh-tw/laravel-migration/"},{"title":"Laravel 善用 layout 避免重複的模板","text":"在設計 UI 模板時重複使用的內容屢見不鮮，例如 header、footer 或是 sidebar 等多是網站中分頁裡的標配，這時候重複貼上一樣的模板就顯得有點呆，Laravel MVC 架構中 views 可以創建一個 layout 模板資料夾，重複的 UI 配置可以放置在這裡提供其他分頁的 blade 檔案使用，這樣一來也能省去 layout 修改時相關的檔案都要更改的麻煩事，統一在 layout 裡調整即可： 建立 layout 資料夾此資料夾可以存放共用的模板，例如 header、footer 或是 sidebar 的模板 html。在 project 裡的 resources/views 建立一個 layout 資料夾： 撰寫模板確立好 controller 中與 views 與 routes 的連結後，就可以著手進行模板的拆分啦！ @extends(‘layoutFolder/layout’)承接共用模板的其他 views 則使用此語法接收模板，撰寫資料夾路徑方式有兩種： 斜線 點 about.blade.php1@extends('layout.layout') about.blade.php1@extends('layout/layout') @yield(‘content’)yield 像是在告訴 php 說我這裡需要挖個洞，待會會丟 html 進來，請認名稱來辨識丟進來的檔案： layout/layout.blade.php12345很多要共用的 html...(通常是 header)@yield('content')很多要共用的 html...(通常是 footer) @section(‘content’) … @endsectionsection 類似 vue 的 slot，把其他網頁要替換的內容插入這個插槽中，在通過剛才的 @yield('content') 將page愈替換的內容塞進去共用的模板中： page.blade.php12345@extends('layout/layout')@section('content') 這裡是 page content ...@endsection 獨立每個頁面的 script插槽的概念同樣可以挖洞給每個獨立頁面放置專屬的 javascript，在 layout 的 之前放置 @yield(‘after_js’) 來承接 page 各自的 &lt;script&gt;...&lt;/script&gt;： layout/layout.blade.php1234567&lt;html&gt; ... &lt;body&gt; ... @yield('after_js') &lt;/body&gt;&lt;/html&gt; page.blade.php12345@section('content') &lt;script&gt; alert(\"Hey!It's about page.\"); &lt;/script&gt;@endsection 簡化 @section每個頁面會有不同的 SEO 內容，例如 title 或是其他的 meta data，這時候 @section 又派上用場了，不同的是第二個參數可以傳入文字檔來渲染內容： layout/layout.blade.php1234567&lt;html&gt; &lt;head&gt; &lt;title&gt;@yield('title')&lt;/title&gt; ... &lt;/head&gt; ...&lt;/html&gt; page.blade.php1@section('title', 'pageTitle') 參考資料：https://www.youtube.com/watch?v=AGE3wRKljkw&amp;t=2402s","link":"/2022/04/10/zh-tw/laravel-layout/"},{"title":"Laravel public 靜態檔案","text":"雖然檔案打包是現今網頁開發的趨勢，但網站難免需要引用未經編譯的靜態檔案，以避免編譯後的亂數檔名都要經過打包程序才能使用，Laravel 專案包中的 public 資料夾就是靜態檔案的去處，與之相對應會被壓縮及打包的動態檔案則要放置在 resources 資料中： 靜態 css 檔案在 public/css/style.css 存放網站的主要設計檔，並且在主模板 resources/views/layout/layout.blade.php 中引用該靜態檔案之路徑在 &lt;link&gt; 中： layout/layout.blade.php1234&lt;html&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\"&gt; ...&lt;/html&gt; 但問題來了！當路由來到巢狀或雙層的時候，絕對路徑的悲劇就會發生，若我們將路由改成： web.php1Route::get('/about/about', [homeController::class, 'about']); 你會看到 css 檔案的路徑改變成 http://localhost:3000/about/css/style.css，因為找不到 about 底下的 css 檔案，所以整個 style 返回 404： url function你想到的問題 Laravel 怎麼會漏掉？這時候可以使用 blade 模板引擎包裝好的 url 方法，傳入相對靜態檔案路徑當參數,，來抓取靜態檔案的正確路徑： layout/layout.blade.php1&lt;link rel=\"stylesheet\" href=\"{{ url('css/style.css') }}\"&gt; 運作正常：","link":"/2022/04/10/zh-tw/laravel-public/"},{"title":"Laravel 認識 controller","text":"當路由越來越多越來越雜亂的時候，express 可以模組化路由以分類各大項目的小路由，Laravel 是基於 MVC 架構的應用程式框架，這個分類工作可以交給 Controller 來執行： init controller使用優雅的 artisan cmd 就可以創建一個 Controller class 模板，在 windows powerShell 輸入wsl 即可切換至 Linux WSL 子系統，終端機輸入以下指令可以查詢所有 artisan cmd 的說明，記得 cd 進入專案包內才可使用 artisan 指令： terminal1php artisan 建立 Controller 模板的 artisan cmd： terminal1php artisan make:controller homeController 撰寫 Controller使用路由名稱創建 function 並且制定渲染內容，連接 Views： App/Https/Controllers/homeController.php1234567891011121314151617181920&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class homeController extends Controller{ public function index () { return view('welcome'); } // 參數要記得帶 public function dog ($dogName) { $datas = [ \"name\" =&gt; \"Abby\", \"dogName\" =&gt; $dogName ]; return view('routesTest', $datas); }} 記得將應用到的動態參數一並移植到 Controller 的 function arguments 中！ 對應 Routes 字串將路由路徑制定好並且傳入陣列參數： use 剛才創建的 Controller 檔案 索引[0]放置 ControllerName::class 索引[1]放置對應 function：routes/web.php12345678&lt;?phpuse Illuminate\\Support\\Facades\\Route;use App\\Http\\Controllers\\homeController;Route::get('/', [homeController::class, 'index']);Route::get('/dog/{dogName}', [homeController::class, 'dog']); 渲染結果： 以上就是 Controller 的常見功能。","link":"/2022/04/06/zh-tw/laravel-routes-controller/"},{"title":"Laravel 認識路由","text":"應用程式介面的主要目的就是提供使用者與介面互動（Interaction），其中 URL 可以取得使用者的資訊並且渲染在畫面中，例如 query string，就是透過最基本的 GET request 來獲取信息： routes在路由頁面設定想要回應到前端的資訊，有幾種方式： simple data回傳簡單的關聯式陣列： 關聯式陣列可以想做類似 javascript 的物件一樣，鍵值對（key-value pair）的形式． routes/web.php12345678Route::get('/greetings', function () { $datas = [ [ \"name\" =&gt; \"Abby\" ] ]; return $datas;}); Views回傳資料至 blade 模板，渲染 html routes/web.php12345678Route::get('/greetings', function () { $datas = [ [ \"name\" =&gt; \"Abby\" ] ]; return views('greetings', $datas);}); 直接將傳遞過來的關聯式陣列 key 傳進來當變數名 resource/views/greetings.blade.php123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Greetings&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello! {{ $name }}&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; query string 參數變數也可以使用既有的 request() 方法承接 URL ? 後方的 key 來渲染到畫面中，讀取 GET 參數： request()routes/web.php123456789Route::get('/cat', function () { // 這裡輸入 params key $catNumbers = request('catNumbers'); $datas = [ \"catNumbers\" =&gt; strip_tags($catNumbers) ]; // return \"這裡有${catNumbers}隻貓\"; return view('cat', $datas);}); resource/views/cat.blade.php123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Cat Route&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;這裡有{{ $catNumbers }}隻貓&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 為了避免 XSS 攻擊注入惡意程式到 app 中，可以為你的 request 包覆 strip_tags()，動態路由則不需要。 設置概覽資料若使用者沒有查詢任何關鍵字（例如衣服），可以設立一個預設顯示的資料（例如展示全部商品）： routes/web.php1234567891011121314151617Route::get('/cat', function () { // 這裡輸入 params key $catNumbers = request('catNumbers'); // 有指定的話顯示 if(isset($catNumbers)) { $datas = [ \"catNumbers\" =&gt; strip_tags($catNumbers) ]; return view('cat', $datas); } else { // 沒指定的話顯示 $datas = [ \"catNumbers\" =&gt; '很多' ]; return view('cat', $datas); }}); isset() 方法類似 javascript 的 if (variable === undefined)，判斷某變數是否存在。 dynamic routes可以渲染使用者輸入的資料，動態路由使用 {} 將路由變數名稱包起，爾後經過 GET URL 的方式取得信息，路由設定需要傳入變數至回呼函式中接收： 範例1. 對應的動態路由變數需要傳入回呼函式中routes/web.php1234567Route::get('/dog/{dogName}', function ($dogName) { $datas = [ \"name\" =&gt; \"Abby\", \"dogName\" =&gt; $dogName ]; return view('routesTest', $datas);}); resource/views/greetings.blade.php12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Greetings&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello! {{ $name }}&lt;/h1&gt; &lt;h2&gt;A dog name {{ $dogName }}&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 範例2. 傳入多個非必要的動態路由參數routes/web.php12345678Route::get('/shop/{category?}/{item?}', function ($a = null, $b = null) { if(isset($a)) { if(isset($b)) { return \"你正在瀏覽商店${a}分類的${b}品項\"; } } return '你正在瀏覽商店的所有商品';}); 對應的回呼函式必須接收一樣數量的變數當參數，名稱隨意不過最好與路由同名比較直覺，且位置要按照順序！非必要的路由參數需要設置： ?放置在{}內，表示為可選的。 非必要路由參數需設置預設值為空null才不會噴錯。","link":"/2022/04/04/zh-tw/laravel-routes/"},{"title":"Laravel 命名路由","text":"當路由越來越多，也越複雜甚至有巢狀結構的時候，相對路徑就會變得複雜不直覺，這時候可以借用 laravel 的命名路由工具，以及 blade 引擎的 route 方法 來輕鬆渲染路由： 命名路由在路由檔案 routes/web.php 中訪問 name 屬性方法並傳入制定好的路由專屬名稱： web.php12Route::get('/', [homeController::class, 'index'])-&gt;name('index.index');Route::get('/about/about', [homeController::class, 'about'])-&gt;name('index.about'); blade 檔案渲染路由將制定好的路由名稱由 name 方法傳入、blade 引擎透過 route 方法接收： layout/layout.blade.php1234...&lt;a href=\"{{ route('index.index') }}\" class=\"underline\"&gt;Home&lt;/a&gt;|&lt;a href=\"{{ route('index.about') }}\" class=\"underline\"&gt;About&lt;/a&gt;... 修改路由結構測試抓取的正確性： web.php12Route::get('/', [homeController::class, 'index'])-&gt;name('index.index');Route::get('/about', [homeController::class, 'about'])-&gt;name('index.about'); 可以看到渲染結果如預期更新了： 透過 blade 引擎封裝的 route 方法 解決了在腦中思考相對路徑結構的煩惱，棒！","link":"/2022/04/10/zh-tw/laravel-routes-namespace/"},{"title":"在 Laravel 專案導入 tailwind css","text":"導入 tailwind css 之前有幾個與 Laravel 執行環境有關的雷需要注意： 前情提要將 Laravel 專案放置在 \\\\wsl$ 路徑內可以更有效率的執行 WSL2，跑起來的速度也快，不過要注意專案環境包相關聯的耦合性，例如 Docker 設定、php 版本對於某些指令的支援度。 以下網址介紹了 WSL2 建置的專案具體位置究竟在哪：https://solidstudio.io/blog/windows-subsystem-for-linux-explained 由於在 windows 系統中建置 Laravel 需要 Linux 子系統 WSL2 的支持，而使用 artisan 相關的指令都建是使用 Windows Terminal 下的 ubuntu 終端機會更友善些： There is however one great application that makes running the WSL console easier. It’s Windows Terminal and it can be installed from Windows Store. It automatically detects any WSL distributions installed and adds an option to run its console. 至於為什麼要使用 Windows Terminal? 以上說明了自動偵測 WSL分佈的功能，當你打開終端機會發現他自動偵測到你使用 WSL 建置該專案包的路徑，甚至在終端機輸入 wsl 就能直接切換該系統環境。 系統包補丁由於每個終端機的環境檔案包是沒有共享的，你在 powershell 很開心的安裝了一包 php，之後當你切換到 ubuntu 會發現，php 指令居然找不到?? 因為你得重裝，導入 tailwind 至 WSL 專案需要補上： node.js安裝 node 在 ubuntu的步驟 新增Node.js PPA PPA 有點像是系統軟體包的 package.json，記錄著軟體及其版本信息，當你運行 sudo apt update 命令時 apt 工具會根據 /etc/apt 目錄中的 sources.list 文件來決定版本是否升級。 安裝 node PPA1sudo apt-get install curl 安裝 LTS 版本1curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash - 安裝Node.js 安裝 Node.js 至 Ubuntu1sudo apt-get install nodejs 查看一下版本號確保安裝成功 安裝 tailwind css至 vscode terminal 或者使用 windows terminal Ubuntu 都可以安裝 tailwind css： 指令安裝 tailwind1npm install -D tailwindcss postcss autoprefixer 安裝Node.js至Ubuntu1npx tailwindcss init 修改 config 加入 pluginwebpack.mix.js1234mix.js(\"resources/js/app.js\", \"public/js\") .postCss(\"resources/css/app.css\", \"public/css\", [ require(\"tailwindcss\"), // &lt;-- 加入這行 ]); 導入全域 css在 resources/css/app.css 檔案中加入以下： resources/css/app.css123@tailwind base;@tailwind components;@tailwind utilities; 設定 tailwind.config.jsresources/css/app.css12345678910module.exports = { content: [ \"./resources/**/*.blade.php\", \"./resources/**/*.js\", \"./resources/**/*.vue\", ], theme: { extend: {}, }, plugins: [],} npm install 將 mix module 裝上mix 指令可以打包 tailwind css 的預處理器編譯為 css，但不會自動安裝，需要 npm install： 1npm install 驗證是否成功 在 views/layout/layout.blade.php 檔案導入全域 css： 1&lt;link href=\"{{ asset('css/app.css') }}\" rel=\"stylesheet\"&gt; 加上 tailwind css 的 class resources/css/app.css1234567@tailwind base;@tailwind components;@tailwind utilities;.btn-primary { @apply py-2 px-4 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75 transition-all;} 套用在 blade 檔案中 welcome.blade.php123456789101112@section('content') &lt;div class=\"container mx-auto\"&gt; &lt;h1&gt;Hello you!&lt;/h1&gt; &lt;div class=\"flex flex-wrap\"&gt; &lt;div class=\"md:w-3/4.w-full\"&gt; &lt;div class=\"w-16 md:w-32 lg:w-48 transition-all bg-fuchsia-300 hover:bg-fuchsia-600 py-5 text-pink-800\"&gt;123&lt;/div&gt; &lt;button class=\"btn-primary\"&gt;My button&lt;/button&gt; &lt;/div&gt; &lt;div class=\"md:w-1/4.w-full\"&gt;aside&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;@endsection mix 指令打包 1npm run mix 成功導入畫面","link":"/2022/04/24/zh-tw/laravel-tailwind/"},{"title":"預處理器新朋友-Less","text":"圖片來源:https://www.oxxostudio.tw/img/articles/201601/css-less-01.jpg 在接觸了新的 Vue3 + Typescript + ant design vue 專案之後，認識了新的預處理器 Less，之前只有聽過 Scss 與 Sass，來認識一下甚麼是 Less 吧！ 為什麼要使用預處理器預處理器存在的目的方便開發者在撰寫 css 上可以更得心應手，使用類似程式語言開發的撰寫習慣來設計網頁畫面，例如變數、迴圈甚至是嵌套樣式讓寫法更多元與方便性，可以轉換成瀏覽器可閱讀的 css 樣貌，減少在刻畫面時只能瑣碎的處理細節與重複性很高的樣式名稱，造成維護的不友善。 Less v.s Sass ?現今常用的幾套預處理器如下： SASS（SCSS） LESS Stylus Turbine Switch CSS CSS Cacheer DT CSS Less 與 Sass 撰寫風格上很接近，以下舉例一些不同點： 變數的寫法 Sass 以錢字號 $ 做開頭12345678$mainColor: white;$siteWidth: 1024px;body { color: $mainColor; max-width: $siteWidth;} Less 以小老鼠 @ 做開頭12345678@mainColor: white;@siteWidth: 1024px;body { color: @mainColor; max-width: @siteWidth;} 嵌套的寫法 Sass 與 Less 一樣12345678910nav { a { color: red; header &amp; { color:green; } } } 繼承（延伸）的寫法 Sass 使用關鍵字 @extend，以某個樣式當作基底延伸12345678910.error { border: 1px solid red; background-color: #fdd; } .seriousError { @extend .error; border-width: 3px; } Less 使用關鍵字 :extend12345678910111213.a1:extend(.b) { color:#f00;}.a2:extend(.b all) {}.b { border:1px solid; font-size:20px;}.b.c { text-align:20px;} 混和的寫法 Sass 使用關鍵字 @mixin，與繼承很像，但寫法類似獨立的模塊（module），@include 提供其他樣式引入12345678910.error { border: 1px solid red; background-color: #fdd; } .seriousError { @extend .error; border-width: 3px; } Less 的混合與一般 class 樣式很像，以一個名稱後方的大括號承接外部樣式傳入的參數（parameters），編譯之後是看不到的1234567.fn1(@v) { border-width: @v;}.box1 { .fn1(10px);} 參考文章： https://www.astralweb.com.tw/introduction-to-css-preprocessor-sass-and-less/","link":"/2022/02/11/zh-tw/less-css/"},{"title":"Php 基礎知識","text":"在 javascript 裡面訪問屬性的方式很單純，都是使用 . 來進入傳參考的對象記憶體中存放的值、訪問類中的屬性還有創立物件內的 key 與 value，然而在 php 中則用三種不同的符號來達成不同目的： :: 範圍解析操作符用來訪問類（class）底下的對象。 layout/layout.blade.php1$classname::CONST_VALUE -&gt; 指向符號（瘦箭頭）用來訪問物件內某類別的值，類似 javascript 裡頭的 .。 layout/layout.blade.php1$object-&gt;property='value' =&gt; 指向符號（胖箭頭）用來創建物件內的鍵值對，一個 key 對上一個 value，類似 javascript 裡頭的 :。 layout/layout.blade.php1$array = array(\"key\" =&gt; \"value\");","link":"/2022/04/10/zh-tw/php-basic-knowledge/"},{"title":"Node如何設置.env環境檔","text":"圖片來源:https://dev.to/aadilraza339/what-is-env-file-in-node-js-3h6c 開發專案的時候機密文件如何保存很重要，可以保護不被有心人士竊取，像是 API 金鑰、client-ID 與 client-secret 等可以呼叫遠端資料的通關密碼都需要妥善保存不暴露到網站上。這邊來說明一下怎麼設置專案裡的環境檔案，並且讀取機密資料： 創建 .env 檔案首先在跟目錄新增一個 .env 檔案，甚至可以設置以下幾種檔案來撰寫想要的環境模式腳本： 根據環境模式建立 全局環境檔：.env 開發環境檔：.env.dev 測試環境檔：.env.sit 生產環境檔：.env.prod 環境檔變數內容很簡單，都是鍵值對（key-value）的方式撰寫變數： .env1YOUR_VARAIBLE_NAME=VALUE Node.js processNode 提供了一個全局可使用的模組 process 記錄了所有關於目前 Node.js 程式的資訊，不需要 require() 就可以使用，棒棒的。 The process object is a global that provides information about, and control over, the current Node.js process. As a global, it is always available to Node.js applications without using require(). process.envprocess.env 則提供了關於使用者的環境物件，而腳本檔案需要的資訊都可以放在這個物件中。該物件中的資料會自動轉換成字串（string）。在 windows 作業系統中環境變數的大小寫是不敏感的。 The process.env property returns an object containing the user environment.See environ(7). Assigning a property on process.env will implicitly convert the value to a string.On Windows operating systems, environment variables are case-insensitive. npm dotenv光有全局的 process.env 是不夠的，還需要使用一個神人創造的 npm 套件 dotenv 才能無痛讀取自己創建的 .env 資料唷！ 1npm i dotenv --save 在專案引用該套件： 12345678require('dotenv').config()const db = require('db')db.connect({ host: process.env.DB_HOST, username: process.env.DB_USER, password: process.env.DB_PASS})https://dev.to/aadilraza339/what-is-env-file-in-node-js-3h6c 善用 .gitignore通常搭配 git 使用時會放置在 env 檔中並且 .gitignore 避免 commit 到公開環境中。使用方式很簡單，在跟目錄創建一個 .gitignore 檔案之後，撰寫需要被 git 略過不被 commit 以及 push 的檔案類型： .gitignore1234.env.env.dev.env.sit.env.prod 參考資料： https://dev.to/aadilraza339/what-is-env-file-in-node-js-3h6chttps://dwatow.github.io/2019/01-26-node-with-env-first/https://nodejs.org/docs/latest-v8.x/api/process.html#process_process_env","link":"/2022/02/21/zh-tw/node-process-env/"},{"title":"初探 Web service","text":"圖片來源：hiskio 課程 API 整合實戰｜RESTful 第三方串接應用 串接 API 是前後端分離的框架興盛之後最重要的課題之一啦！但是對初探網頁程式領域的菜菜子來說這個世界太廣太深，讓人望之卻步，萬事起頭難，就先來理解一下 API 武林世界裡的的兩大流派吧！ SOAP &amp; XML企業類型成立已久的正宗流派，有許多資深企業的系統愛用的 API 串接方式，例如政府機構或是建案公司等老牌廠商。 資料格式傳遞資料多為較嚴謹與複雜的 SOAP﹑Xml 格式，由於規範的細節較多而且有一定的流程要走完，容易造成程式的肥大與艱澀，當用在小型專案時往往會有殺雞焉用牛刀之感，在準備期會比較漫長且學習曲線高，但是對於大型系統的整合還是有其優點。 程式取向當初由微軟所開發，所以程式取向多限制在 IIS 微軟開發體系，例如 .net。 RESTful API企業類型新興產業或新創公司等現代化的企業偏愛的 API 串接方式，為求快速開發多選用輕量的 RESTful API 以求在競爭激烈的市場上異軍突起。 資料格式傳遞資料多為簡單易懂的 Json，開發程式也容易快速，可以靈活地符合大或小的資料需求．不過相對來講規範與細節也比較粗糙與鬆散，需要在準備期規範好 API 的命名規則與資料邏輯，不然容易導致 API 很多但功能性重複等問題。 程式取向任何程式語言都可以開發出來的 API．不侷限於哪種體系的程式，例如 python﹑php﹑ruby﹑node.js等等。 而今的開發環境裡新興的流派已經逐漸為 RESTful API 所佔有，資深或金融機構也逐步轉型為輕量的 API 資料交換方式。 SOAP v.s RESTREST 優於 SOAPREST 提供更多元資料格式。SOAP 只有 XML。基於 JSON，REST 被公認是易於處理的。基於 JSON，REST 提供對瀏覽器更好的支援。REST 提供優越的性能。特別指快取資料。世界級大公司主要服務協定。REST 一般而言比較快且省頻寬。 SOAP 優於 RESTSOAP 是標準 HTTP 協定，能更方便通過防火牆和Proxy而不對協定本身進行修改。如果你需要處理 ACID 交易，那麼 SOAP 是不錯的方向。SOAP 擁有各種 WS- 擴充服務，擁有高可擴充性。B2B 的世界，安全與穩定重於一切。 Bruce 的一些心得 青菜蘿蔔各有所好，並不一樣是 REST 完勝，例如，之前有一陣子在忙的 B2B Biztalk 專案，在加解密(安全)部分，基於 XML 的 SOAP 就比 REST 更為合適。但基於 XML 的協定有個很明顯的缺點，就是當來源資料量成長一些些，產出的 XML 資料量會明顯成長很多。資料解析下，拜 JSON.NET 之類的框架(如之前介紹過的 Jil)幫忙，JSON 格式的處理是非常簡單的。但如果有一天，你真的碰到要處理 XML，那麼不要忘記 LINQ to XML 這個技術就好。 參考資料： https://blog.kkbruce.net/2018/04/soap-with-rest-good-parts.html#.YheofuhBxPY","link":"/2022/02/24/zh-tw/restful-api-and-web-service/"},{"title":"短路解析 & 可選鍊修飾符","text":"在開發的情境上無論是串接 API 或者是資料判斷，都需要追求便捷而好懂的方式來維護程式碼，以利於當資料判斷變得複雜臃腫時仍可以邏輯清晰。而對於程式新手來說undefined（未定義）、null（空值）或者是0（零）在判斷上是很容易掉進去的陷阱，因為判定的方法了解的不深而陷入困境。 理解真假值先介紹 truthy(真值) 與 falsy(假值)： truthy：非 falsy 的值，或者是表達式結果為 true falsy：undefined、null、非數字 NaN、數字 0、數字 -0、BigInt 0n、空字串''(字串長度為 0)，或者是表達式結果為 false 以下介紹幾種邏輯判斷的捷徑： 邏輯運算子 &amp;&amp; ||舉個栗子 邏輯運算子12345678const numberAND = 6const numberOR = -1if(numberAND &gt; 5 &amp;&amp; numberAND &lt; 7) { console.log('哎呀')}if(numberOR &gt; 5 || numberOR &lt; 7) { console.log('黑唷')} 人類的理解當 numberAND 大於 5 且同時小於 7 值執行 console.log('符合 &amp;&amp;')；當 numberOR 大於 5 或者小於 7 值執行 console.log('符合 ||') 電腦的理解當左邊的表達式 numberAND &gt; 5 結果為 false 則跳過右邊不執行 numberAND &lt; 7，直接跳出程式。當左邊的表達式 numberOR &gt; 5 結果為 true 則跳過右邊不執行 numberAND &lt; 7，直接進入程式。 結論為，當左邊的表達式符合條件，&amp;&amp; 的 if 直接跳出；|| 的 if 直接進入。來理一理箇中原由吧！ 短路解析(Short Circuit)短路我個人覺得沒有捷徑來得好懂，短路比較讓人聯想為損毀或壞掉的電子產品，而捷徑則代表透過偷吃步或者抄捷徑的方式以取得一樣的結果。這裡的短路較接近後者，js 運行上的偷吃步： &amp;&amp; 的短路解析當左邊的表達式為 false 就返回左邊的表達式結果，並且直接忽視右邊的表達式結果，反之執行右邊的表達式。 || 的短路解析當左邊的表達式為 true 就返回左邊的表達式結果，並且直接忽視右邊的表達式結果，反之執行右邊的表達式。 以上可以知道 js 執行完左邊的表達式之後，若符合條件則直接跳過右邊的表達式(不解析亦不執行)，相對來講當開發人員在理解短路解析時就可以按照這樣的邏輯去快速判斷結果。 速記法：ANDfalse跳出、ORtrue進入(執行)。 if you use || to provide some default value to another variable foo, you may encounter unexpected behaviors if you consider some falsy values as usable (e.g., '' or 0). 可選鍊修飾符(Optional chaining)舉個栗子 可選鍊修飾符1234567let user = {};console.log(user.address);// undefinedconsole.log(user.address.street);// errorconsole.log(user.address?.street);// undefined 在這個範例中，user 物件的清單中有部分的使用者缺少了 address 這個屬性，但是大部分的使用者都具有該屬性時，就可以使用可選鍊修飾符來避免程式噴錯而中斷，但是需注意避免過度使用可選鍊修飾符 空值合併運算子(Nullish coalescing operator) ??舉個栗子 空值合併運算子1234567function notNullish (a, b) { console.log(a ?? b);}notNullish (undefined, null); // nullnotNullish (null, undefined); // undefinednotNullish (undefined, 0); // 0notNullish (undefined, ''); // '' ES2020（ES11）提供的「空值合併運算子」，支援度需要搭配 babel 套件。 ??常常與邏輯運算子 || 比較，前者返回非 undefined 與 null 的表達式，後者返回非 falsy 的表達式。過濾的條件上有區別，可以依照需求使用。 ?? 的短路解析當左邊的表達式為 非 undefined 與 null 就返回左邊的表達式結果，並且直接忽視右邊的表達式結果，反之執行右邊的表達式。","link":"/2022/03/12/zh-tw/short-circuit-and-optional-chaining/"},{"title":"Vue3 + Vite + Ts 專案建置","text":"Vite 問世以後總算不用再看著打包的百分比甚麼時候跑完了（灑花，按下 ctrl S 直接查看效果棒棒的！不過再也沒有藉口可以喝口拿鐵啦XD 簡單介紹一下 Vite 是甚麼： Vite（法语意为 “快速的”，发音 /vit/，发音同 “veet”）是一种新型前端构建工具，能够显著提升前端开发体验。它主要由两部分组成： 一个开发服务器，它基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的模块热更新（HMR）。 一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。 先打預防針，小菜雞本人對於類別的物件導向了解尚淺，ts 的運用也不熟悉，導入使用再一步一步學習，這裡著重於專案是否能啟用。本篇簡略說明建置 Vue3 + Vite + Ts 的專案過程中使用的方法： 快速建置專案 12# npm 6.xnpm create vite@latest my-vue-app --template vue 123cd my-projectnpm installnpm run dev 使用 ant design vue UI antd 的介面優雅簡約個人滿喜歡的，配色切換的設定也很方便 安裝套件 1npm i --save ant-design-vue@next 新建 libs 資料夾在 src 底下，新增 antdv.ts antdv.ts12345678import type { App } from \"vue\";import Antd from \"ant-design-vue\";import \"ant-design-vue/dist/antd.less\";export function setupAntd(app: App&lt;Element&gt;): void { app.use(Antd);} 全局入口引用 antd，並且註冊 antd icon main.ts1234567891011121314151617import { createApp } from 'vue'import App from './App.vue'import { setupAntd } from \"./libs/antdv\"; // 新增++import * as Icons from '@ant-design/icons-vue';const app = createApp(App);const icons :any = Icons;setupAntd(app); createApp(App);// 父組件全局註冊ICONSfor(const i in icons) { app.component(i, Icons[i]);}app.mount('#app') 在 vite.config.ts 修改主要配色 primary 變數，這裡踩了很多坑，處理器的設定物件結構一直不對（哭 由於 antd 使用的 css 預處理器是不熟悉的 less，無奈一個專案還是選擇一個預處理器就好，只能新學一個寫法來制定自己的全局 css 囉！scss 先放一邊啦。套用全局 css 只需在 additionalData 裡面放置路徑的字串。 vite.config.ts12345678910111213141516171819import { defineConfig } from 'vite'import vue from '@vitejs/plugin-vue'// https://vitejs.dev/config/export default defineConfig({ plugins: [vue()], css: { preprocessorOptions: { less: { javascriptEnabled: true, modifyVars: { 'primary-color': '#94D0C9', 'link-color': 'red', }, additionalData: '@import \"./src/assets/style/global.less\";', } }, },}) vuex4 導入與建置 mapStates 模組 安裝 vuex4 1npm install vuex@next 全局入口引用 vuex，多了一把鑰匙（key）需要設置並且傳入 useStore() 中才能啟用 vuex，鑰匙的型態是 symbol() main.ts12345678910111213141516171819import { createApp } from 'vue'import App from './App.vue'import { setupAntd } from \"./libs/antdv\"import * as Icons from '@ant-design/icons-vue'import { store, key } from './store/store' // 新增++const app = createApp(App);const icons :any = Icons;app.use(store, key) // 新增++setupAntd(app); createApp(App);// 父組件全局註冊ICONSfor(const i in icons) { app.component(i, Icons[i]);}app.mount('#app') 撰寫 vuex 配置檔案，為了方便後續使用模組導入 mapStates 的方式，統一放在 src 底下的資料夾 store 內： 與 vuex3寫法上的不同點：以前使用 new Store()，vuex4改用 createStore() 建立倉庫。 store.ts12345678910111213141516171819202122232425import { InjectionKey } from 'vue'import { createStore, Store } from 'vuex'import axios from 'axios'import ApiClient from '../ApiClient'// 为 store state 声明类型export interface State { count: number}// 定义 injection keyexport const key: InjectionKey&lt;Store&lt;State&gt;&gt; = Symbol()export const store = createStore&lt;State&gt;({ state: { count: 0 }, getters: { }, mutations: { }, actions: { },}) 在 Vue3.x 版本中使用 vuex4 需要透過 useStore() 方法才能訪問 store 內容： store.ts12","link":"/2022/02/18/zh-tw/vue3-vite-ts/"},{"title":"Vue 3 的變革","text":"本篇尚未完整，持續更新中… 你還在用 Vue 2 整理那些物件包裹起來的 data、方法與生命週期的鉤子嗎？還在頭痛父子元件之間傳遞資料的複雜寫法嗎？如果想尋找更接近 typescript 易於維護的團隊開發方式，可以考慮無痛升級 Vue 3 唷！特快車來了還不跟上！ Vue 3 用法隨著版本更新越來越精進與簡潔，尤其是使用漸進式 API 的寫法大大提升了整 code 的整潔與好維護度，以下是一些常用到的整理： Composition APIVue3 一項顯著的變革就是 Composition API，提升撰寫每一個元件專屬方法與資料的便利性： Composition API is a set of APIs that allows us to author Vue components using imported functions instead of declaring options. It is an umbrella term that covers the following APIs.Composition API 使得元件得以直接使用 import 進來的 functions，而不是透過選項來宣告，該特性封裝了以下的 API方法： Reactivity API 例如 ref() 和 reactive() 可創造響應式（reactive）、計算式（computed）與監聽（watchers）的資料狀態 Lifecycle Hooks 例如 onMounted() 和 onUnmounted(), 容許使用編成方式撰寫元件的生命週期鉤子 Dependency Injection 例如 provide() and inject(), 提供一個祖父 -&gt; 父(跳過) -&gt; 子元件之間依賴注入（Dependency Injection）的接口，可以更好的分化元件之間的需求，了解更多內容可以詳讀這篇 簡單下個速記法： provide() 與 inject() 看做是 prop 的昇級版，看個示意圖吧！ Setup scriptVue 3 將 Composition API 整合在單個元件的 &lt;script setup&gt; 標籤中，可以直接默認寫在裡面的內容都是提升到 created() 和 beforeCreated()的生命週期階段去實踐的 In Vue 3, it is also primarily used together with the &lt;script setup&gt; syntax in Single-File Components. component.vue1234567891011121314151617181920&lt;script setup&gt; import { ref, onMounted } from 'vue' // reactive state const count = ref(0) // functions that mutate state and trigger updates function increment() { count.value++ } // lifecycle hooks onMounted(() =&gt; { console.log(`The initial count is ${count.value}.`) }) &lt;/script&gt; &lt;template&gt; &lt;button @click=\"increment\"&gt;Count is: &lt;/button&gt; &lt;/template&gt; Reactivity API多了一層代理（proxy）包裹所有的資料（data），使得 vue3 在處理 data 上有些變革： ref() 傳入 primative value reactive() 傳入 object value該選擇哪一種可以參考這篇 ref vs reactive in Vue 3?，滿有助益的解釋非常通透呢！ ref ()當你需要將資料型態重新賦值（reassign）時可以選用 ref()，其實該方法背後也調用了 reactive() 只是你不知道而已，原始型別非常適合使用此代理包裹，另外當你的物件型別資料並沒有一開始的屬性值，例如空物件或空陣列，也可以考慮使用這個方式。需要特別注意的點就是該方法取值要添加 .value 才能取得。 ref() Use-CaseYou’ll always use ref() for primitives, but ref() is good for objects that need to be reassigned, like an array. When you write ref([]) it is equivalent to ref(reactive([])). reactive ()當需要將物件型別的資料型態其中某個屬性值透過指向參考（dot notation）來修改值的時候可以選用 reactive()，前提在於你知道該物件內容的屬性值有哪些，屬性值彼此之間的牽動關聯性是甚麼，甚至可以直接撰寫 computed() 來決定某屬性值，該方法須注意不能被重新賦值更改指向參考，完全不會理你。 看到透過 reactive 包裝後的資料連 computed 都包裝了進去，是不是覺得非常的方便，不需要再另外切開去寫computed ，在尋找相依性的資料也變簡單。https://medium.com/i-am-mike/vue-3-ref-%E8%B7%9F-reactive-%E6%88%91%E8%A9%B2%E6%80%8E%E9%BA%BC%E9%81%B8-2fb6b6735a3c reactive() Use-CaseA good use-case for reactive() is a group of primitives that belong together: props非必要的 props只需要在非必要的 props 加上? 就可以囉！不然 typescript 會一直跳出警語 ts(2322) 1234567891011121314const props = defineProps&lt;{ span: number, label: string, name: string, placeholder: string, prefix?: { type: string, default: '' }, suffix?: { type: string, default: '' }, }&gt;() 方法toRaw轉換透過vue創造的代理物件為普通物件，可轉換的代理物件有 reactive(), readonly(), shallowReactive() 或 shallowReadonly()。This is an escape hatch that can be used to temporarily read Returns the raw, original object of a Vue-created proxy.","link":"/2022/02/16/zh-tw/vue3-composition-api/"},{"title":"Web Socket v.s Web Hook","text":"API 的形式有兩大宗：Web Hook 與 Web Socket，而他們有甚麼差異呢？ 被動式 Web Hook例如 Line Bot，server 會先預測使用者的動作與需求（events），設計出相對的程式並維護，等待使用者發出要求才動作。 主動式 Web Socket兩方的資料交互，例如 client 與 server、server 與 server。應用場景如聊天功能：facebook messenger 或 Line 等，Web Socket 的技術可以「即時的」(real time)做出資料傳遞。當你打開 facebook messenger 的視窗，Web Socket server 就會與 client 瀏覽器端 handshake 保持通訊暢通，持續監聽對話要求並回應(opened and persistent connection) 參考資料： hiskio 課程 API 整合實戰｜RESTful 第三方串接應用","link":"/2022/02/25/zh-tw/web-socket-and-web-hook/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"constructor","slug":"constructor","link":"/tags/constructor/"},{"name":"instance","slug":"instance","link":"/tags/instance/"},{"name":"methods","slug":"methods","link":"/tags/methods/"},{"name":"backEnd","slug":"backEnd","link":"/tags/backEnd/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"router","slug":"router","link":"/tags/router/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"sourceTree","slug":"sourceTree","link":"/tags/sourceTree/"},{"name":"api","slug":"api","link":"/tags/api/"},{"name":"graphQL","slug":"graphQL","link":"/tags/graphQL/"},{"name":"facebook","slug":"facebook","link":"/tags/facebook/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"request","slug":"request","link":"/tags/request/"},{"name":"response","slug":"response","link":"/tags/response/"},{"name":"httpHeader","slug":"httpHeader","link":"/tags/httpHeader/"},{"name":"status","slug":"status","link":"/tags/status/"},{"name":"httpMethods","slug":"httpMethods","link":"/tags/httpMethods/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"type","slug":"type","link":"/tags/type/"},{"name":"laravel","slug":"laravel","link":"/tags/laravel/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"blade","slug":"blade","link":"/tags/blade/"},{"name":"wsl2","slug":"wsl2","link":"/tags/wsl2/"},{"name":"migration","slug":"migration","link":"/tags/migration/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"layout","slug":"layout","link":"/tags/layout/"},{"name":"public","slug":"public","link":"/tags/public/"},{"name":"static","slug":"static","link":"/tags/static/"},{"name":"tailwind","slug":"tailwind","link":"/tags/tailwind/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"less","slug":"less","link":"/tags/less/"},{"name":"processors","slug":"processors","link":"/tags/processors/"},{"name":"env","slug":"env","link":"/tags/env/"},{"name":"process","slug":"process","link":"/tags/process/"},{"name":"dotenv","slug":"dotenv","link":"/tags/dotenv/"},{"name":"webService","slug":"webService","link":"/tags/webService/"},{"name":"restfulApi","slug":"restfulApi","link":"/tags/restfulApi/"},{"name":"shortCircuit","slug":"shortCircuit","link":"/tags/shortCircuit/"},{"name":"optionalChaining","slug":"optionalChaining","link":"/tags/optionalChaining/"},{"name":"tricks","slug":"tricks","link":"/tags/tricks/"},{"name":"vue3","slug":"vue3","link":"/tags/vue3/"},{"name":"vite","slug":"vite","link":"/tags/vite/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"compositionAPI","slug":"compositionAPI","link":"/tags/compositionAPI/"},{"name":"WebSocket","slug":"WebSocket","link":"/tags/WebSocket/"},{"name":"WebHook","slug":"WebHook","link":"/tags/WebHook/"}],"categories":[{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"node.js","slug":"node-js","link":"/categories/node-js/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"graphQL","slug":"graphQL","link":"/categories/graphQL/"},{"name":"intro","slug":"intro","link":"/categories/intro/"},{"name":"http","slug":"http","link":"/categories/http/"},{"name":"laravel","slug":"laravel","link":"/categories/laravel/"},{"name":"tailwind","slug":"tailwind","link":"/categories/tailwind/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"php","slug":"php","link":"/categories/php/"},{"name":"webService","slug":"webService","link":"/categories/webService/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"vue3","slug":"vue/vue3","link":"/categories/vue/vue3/"},{"name":"webSocket","slug":"webSocket","link":"/categories/webSocket/"}]}