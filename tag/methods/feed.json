{
    "version": "https://jsonfeed.org/version/1",
    "title": "Mawchu 貓奴前端的天空 • All posts by \"methods\" tag",
    "description": "Mawchu 貓奴前端，為熱愛平面設計與貓咪的前端工程師 - 謝佳芳（毛球）的技術部落格，喜歡撰寫技術文章幫助自己在前端之路成長，涉及 Javascript、Vue、Laravel 與其他程式相關的討論與學習",
    "home_page_url": "http://maomaoxie.github.io",
    "items": [
        {
            "id": "http://maomaoxie.github.io/2022/05/14/zh-tw/constructor-vs-instance/",
            "url": "http://maomaoxie.github.io/2022/05/14/zh-tw/constructor-vs-instance/",
            "title": "建構子方法與實例化方法",
            "date_published": "2022-05-14T20:37:03.000Z",
            "content_html": "<html><head></head><body><img src=\"/images/constructor-vs-instance/0.png\" class=\"\" width=\"800\" height=\"200\" title=\"constructor-vs-instance\">\n\n<p>在某天好奇想了解 Vue 3 的 defineProperty 原理搜尋了 <code>Object.defineProperty()</code> 這個方法時，看見以下說明：</p>\n<blockquote><p>靜態方法 <code>Object.defineProperty()</code> 會直接對一個物件定義、或是修改現有的屬性。執行後會回傳定義完的物件。<br>備註：這個方法會直接針對 Object 呼叫建構子（constructor），而不是 Object 型別的實例。</p>\n<footer><strong>MDN</strong><cite><a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\">Object.defineProperty()</a></cite></footer></blockquote>\n<p>其中的<strong>直接針對 Object 呼叫建構子（constructor），而不是 Object 型別的實例</strong>這句話突然讓我驚醒了，以前一直不能理解 javascript 中呼叫原生方法時，為何會有以下的區別：</p>\n<h2 id=\"透過建構器呼叫\"><a href=\"#透過建構器呼叫\" class=\"headerlink\" title=\"透過建構器呼叫\"></a>透過建構器呼叫</h2><p><code>Object.methods(objInstance)</code> -&gt; 例如 Object.keys(someObj)<br>這裡的 Object 是建構函式本身，未實例的藍圖（constructor）。</p>\n<h2 id=\"透過實例呼叫\"><a href=\"#透過實例呼叫\" class=\"headerlink\" title=\"透過實例呼叫\"></a>透過實例呼叫</h2><p><code>objInstance.methods(parameters)</code> -&gt; 例如 someObj.hasOwnProperty(‘prop’)<br>這裡的 Object 是實例化的物件（instance）。</p>\n<h2 id=\"Constructor-Static-Methods\"><a href=\"#Constructor-Static-Methods\" class=\"headerlink\" title=\"Constructor Static Methods\"></a>Constructor Static Methods</h2><h4 id=\"構造器-靜態方法\"><a href=\"#構造器-靜態方法\" class=\"headerlink\" title=\"構造器 靜態方法\"></a>構造器 靜態方法</h4><p>以下的例子是呼叫 Object 建構子中的原生 keys 方法，而不需要 new 一個物件實例就可以使用，靜態方法的特色是無需使用任何建構子中的 this 資料就可以直接使用。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>建構子方法</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> someone = {</span><br><span class=\"line\">  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Adam'</span>,</span><br><span class=\"line\">  <span class=\"hljs-attr\">carrer</span>: <span class=\"hljs-string\">'teacher'</span>,</span><br><span class=\"line\">  <span class=\"hljs-attr\">sex</span>: <span class=\"hljs-string\">'male'</span></span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"hljs-keyword\">const</span> dataKeys = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(someone);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dataKeys);</span><br><span class=\"line\"><span class=\"hljs-comment\">// [\"name\",\"carrer\",\"sex\"]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Instance-methods\"><a href=\"#Instance-methods\" class=\"headerlink\" title=\"Instance methods\"></a>Instance methods</h3><h4 id=\"等號賦值-實例化方法\"><a href=\"#等號賦值-實例化方法\" class=\"headerlink\" title=\"等號賦值 實例化方法\"></a>等號賦值 實例化方法</h4><p>以下則是呼叫 Array 的實例化 push 方法，雖然也不是透過 new 來建立一個陣列，卻也是使用賦值一個陣列來建立陣列的實例，並且使用原生 push 方法。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>實例化方法 - 賦值</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> friends = [ <span class=\"hljs-string\">'Cally'</span>, <span class=\"hljs-string\">'Donna'</span>, <span class=\"hljs-string\">'Jell'</span> ];</span><br><span class=\"line\">friends.<span class=\"title function_\">push</span>(<span class=\"hljs-string\">'Liang'</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(friends);</span><br><span class=\"line\"><span class=\"hljs-comment\">// [\"Cally\",\"Donna\",\"Jell\",\"Liang\"]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"建構器-實例化方法\"><a href=\"#建構器-實例化方法\" class=\"headerlink\" title=\"建構器 實例化方法\"></a>建構器 實例化方法</h4><p>透過 new 來建立一個陣列。</p>\n<figure class=\"highlight javascript hljs\"><figcaption><span>實例化方法 - 構造器</span></figcaption><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> animals = <span class=\"hljs-keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"hljs-string\">'bunny'</span>, <span class=\"hljs-string\">'cat'</span>, <span class=\"hljs-string\">'puppy'</span>, <span class=\"hljs-string\">'hamster'</span>);</span><br><span class=\"line\">animals.<span class=\"title function_\">unshift</span>(<span class=\"hljs-string\">'bird'</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(animals);</span><br><span class=\"line\"><span class=\"hljs-comment\">// [\"bird\",\"bunny\",\"cat\",\"puppy\",\"hamster\"]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"構造器靜態方法補充\"><a href=\"#構造器靜態方法補充\" class=\"headerlink\" title=\"構造器靜態方法補充\"></a>構造器靜態方法補充</h2><h4 id=\"無法取得構造器的this資料\"><a href=\"#無法取得構造器的this資料\" class=\"headerlink\" title=\"無法取得構造器的this資料\"></a>無法取得構造器的this資料</h4><blockquote><ul>\n<li>The static method also cannot see the instance variable state so if we try to call the nonstatic method from the static method compiler will complain.</li>\n<li>The static method can be used to create utility functions.<br><a href=\"https://www.educba.com/javascript-static-method/\">https://www.educba.com/javascript-static-method/</a></li>\n</ul>\n</blockquote>\n\n<p>從上述可以得知靜態方法是不能取用構造器建構子（constructor）內的變數的（this binding），通常會撰寫純函式（pure function）以保持無狀態的特性，如同 Math 方法。<br>靜態方法適合用來當作全局複用的函式，適合較無副作用的邏輯。</p>\n<h2 id=\"兩種方法的原型鍊關係\"><a href=\"#兩種方法的原型鍊關係\" class=\"headerlink\" title=\"兩種方法的原型鍊關係\"></a>兩種方法的原型鍊關係</h2><p>若展開一個實例化的物件，會發現：</p>\n<ol>\n<li>建構器方法存在於建構子物件中（constructor），且只能透過建構器呼叫，例如 Object.assign()；</li>\n<li>實例化方法則存在於原型上（prototype），需要實例化之後才能呼叫，例如 objInstance.toLocaleString()</li>\n</ol>\n</body></html>",
            "tags": [
                "javascript",
                "constructor",
                "instance",
                "methods"
            ]
        }
    ]
}